%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=2,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{PlasmaC introduction}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}


\title{PlasmaC Documentation}
\date{Aug 09, 2020}
\release{19.2}
\author{Robert Marskar}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}
\sphinxstylestrong{This is an alpha release of PlasmaC. Development is still in progress, and various bugs may or may not be present. User interfaces can and will change.}



\sphinxtitleref{PlasmaC} is a modular and scalable computer code for Cartesian two\sphinxhyphen{} and three\sphinxhyphen{}dimensional simulations of low\sphinxhyphen{}temperature plasmas in complex geometries.
\begin{itemize}
\item {} 
Electrostatics with support for electrodes and dielectrics

\item {} 
Radiative transport as a diffusion or Monte Carlo process

\item {} 
Scalar advection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction transport in complex geometries, with support for fluctuating hydrodynamics

\item {} 
Îto particle models for microscopic drift\sphinxhyphen{}diffusion\sphinxhyphen{}reaction processes

\item {} 
Parallel I/O with HDF5

\item {} 
Sensible and simple\sphinxhyphen{}to\sphinxhyphen{}use physics interfaces

\item {} 
Various time integration schemes

\item {} 
Dual\sphinxhyphen{}grid simulations with separate fluid and particle grids.

\end{itemize}

Numerical solvers are designed to run on their own, but are best used through physics interfaces.

For scalability, \sphinxtitleref{PlasmaC} is built on top of \sphinxhref{https://commons.lbl.gov/display/chombo/Chombo+-+Software+for+Adaptive+Solutions+of+Partial+Differential+Equations}{Chombo}, and therefore additionally features
\begin{itemize}
\item {} 
Cut\sphinxhyphen{}cell representation of multi\sphinxhyphen{}material geometries

\item {} 
Patch based adaptive mesh refinement

\item {} 
Good weak and strong scalability to thousands of computer cores

\end{itemize}

Our goal is that users will be able to use \sphinxtitleref{PlasmaC} without modifying the underlying solvers.
There are interfaces for describing the plasma physics, setting up boundary conditions, ensuring mesh refinement, and so on.
As \sphinxtitleref{PlasmaC} evolves, so will these interfaces.
We aim for (but cannot guarantee) backward compatibility such that existing \sphinxtitleref{PlasmaC} models can be run on future versions.
This documentation is the user documentation \sphinxtitleref{PlasmaC}. There is a separate \sphinxhref{../doxygen/html/index.html}{Doxygen API} that can be compiled together with the source code.


\chapter{Introduction}
\label{\detokenize{index:introduction}}\label{\detokenize{index:chap-introduction}}

\section{Getting started}
\label{\detokenize{GettingStarted:getting-started}}\label{\detokenize{GettingStarted:chap-gettingstarted}}\label{\detokenize{GettingStarted::doc}}
This chapter discusses how you may obtain \sphinxcode{\sphinxupquote{PlasmaC}} and compile it.


\subsection{Obtaining \sphinxtitleref{PlasmaC}}
\label{\detokenize{GettingStarted:obtaining-plasmac}}\label{\detokenize{GettingStarted:chap-obtaining}}
\sphinxtitleref{PlasmaC} is obtained by cloning the following repository:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
git clone ssh://git@git.code.sintef.no/\PYGZti{}robertm/plasmac
\end{sphinxVerbatim}


\subsection{Prerequisites}
\label{\detokenize{GettingStarted:prerequisites}}\label{\detokenize{GettingStarted:chap-prerequisites}}
From the ground up, \sphinxcode{\sphinxupquote{PlasmaC}} is built on top of the \sphinxhref{https://commons.lbl.gov/display/chombo/Chombo+-+Software+for+Adaptive+Solutions+of+Partial+Differential+Equations}{Chombo} framework.
To compile \sphinxtitleref{PlasmaC}, you must first install the following:
\begin{itemize}
\item {} 
A Fortran compiler, usually gfortran or Intel Fortran

\item {} 
A C++ compiler, usually g++ or Intel C++

\item {} 
An MPI installation

\item {} 
A parallel HDF5 installation

\item {} 
LAPACK and BLAS

\end{itemize}

Usually, laptops and desktops already have appropriate Fortran and C++ compilers installed, as well as a version of MPI.
On clusters, HDF5 is (usually) preinstalled, and in this case, it will be sufficient to modify the \sphinxtitleref{Chombo} build files in order to compile \sphinxtitleref{PlasmaC}.
Following some changes that we’ve made to the way \sphinxtitleref{Chombo} generates its embedded boundaries, \sphinxtitleref{Chombo} is released together with \sphinxtitleref{PlasmaC}.

If you already have HDF5 installed, you may skip directly to {\hyperref[\detokenize{GettingStarted:chap-environment}]{\sphinxcrossref{\DUrole{std,std-ref}{Setting up your environment}}}}.


\subsubsection{Installing HDF5}
\label{\detokenize{GettingStarted:installing-hdf5}}\label{\detokenize{GettingStarted:chap-hdf5}}
If you do not have HDF5 installed, you may do the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Compile and install zlib, which is a compression library used by HDF5. zlib can be installed by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{zlib1g}\PYG{o}{\PYGZhy{}}\PYG{n}{dev}
\end{sphinxVerbatim}

\item {} 
Download HDF5 (version 1.8 or newer) and install it for parallel execution

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{p}{.}\PYG{o}{/}\PYG{n}{configure} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{prefix}\PYG{o}{=}\PYG{o}{/}\PYG{n}{usr}\PYG{o}{/}\PYG{n}{local}\PYG{o}{/}\PYG{n}{hdf5\PYGZus{}parallel} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{enable}\PYG{o}{\PYGZhy{}}\PYG{n}{production} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{enable}\PYG{o}{\PYGZhy{}}\PYG{n}{fortran} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{enable}\PYG{o}{\PYGZhy{}}\PYG{n}{parallel}
\PYG{n}{make}
\PYG{n}{make} \PYG{n}{install}
\end{sphinxVerbatim}

This will install HDF5 in /usr/local/hdf5\_parallel.
You may need to install both parallel and serial versions of HDF5.

\end{enumerate}


\subsubsection{Setting up your environment}
\label{\detokenize{GettingStarted:setting-up-your-environment}}\label{\detokenize{GettingStarted:chap-environment}}
In \sphinxtitleref{Chombo},the system information is supplied through a file known as Make.defs.local, which resides in the \sphinxtitleref{Chombo} library itself.
This file contains a number of build settings, such as dimension, compilers, paths to HDF5 and so on.
The configuration file is /lib/mk/Make.defs.local in your \sphinxtitleref{Chombo} folder.
The build parameters can also be controlled through the command line.

Here are the configuration variables that have been used used on the \sphinxhref{https://www.top500.org/system/179072}{fram} supercomputer

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{DIM}           \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{DEBUG}         \PYG{o}{=} \PYG{n}{FALSE}
\PYG{n}{OPT}           \PYG{o}{=} \PYG{n}{HIGH}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{PRECISION     =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{PROFILE       =}
\PYG{n}{CXX}            \PYG{o}{=} \PYG{n}{icpc}
\PYG{n}{FC}             \PYG{o}{=} \PYG{n}{ifort}
\PYG{n}{MPI}            \PYG{o}{=} \PYG{n}{TRUE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{\PYGZsh{} Note: don\PYGZsq{}t set the MPICXX variable if you don\PYGZsq{}t have MPI installed}
\PYG{n}{MPICXX}         \PYG{o}{=} \PYG{n}{mpicxx}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{OBJMODEL      =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{XTRACONFIG    =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{\PYGZsh{} Optional features}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{USE\PYGZus{}64        =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{USE\PYGZus{}COMPLEX   =}
\PYG{n}{USE\PYGZus{}EB}         \PYG{o}{=} \PYG{n}{TRUE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{USE\PYGZus{}CCSE      =}
\PYG{n}{USE\PYGZus{}HDF}        \PYG{o}{=} \PYG{n}{TRUE}
\PYG{n}{HDFINCFLAGS}    \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{I}\PYG{o}{/}\PYG{n}{cluster}\PYG{o}{/}\PYG{n}{software}\PYG{o}{/}\PYG{n}{HDF5}\PYG{o}{/}\PYG{l+m+mf}{1.10}\PYG{l+m+mf}{.1}\PYG{o}{\PYGZhy{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2017}\PYG{n}{a}\PYG{o}{/}\PYG{n}{include}
\PYG{n}{HDFLIBFLAGS}    \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{L}\PYG{o}{/}\PYG{n}{cluster}\PYG{o}{/}\PYG{n}{software}\PYG{o}{/}\PYG{n}{HDF5}\PYG{o}{/}\PYG{l+m+mf}{1.10}\PYG{l+m+mf}{.1}\PYG{o}{\PYGZhy{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2017}\PYG{n}{a}\PYG{o}{/}\PYG{n}{lib} \PYG{o}{\PYGZhy{}}\PYG{n}{lhdf5} \PYG{o}{\PYGZhy{}}\PYG{n}{lz}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{\PYGZsh{} Note: don\PYGZsq{}t set the HDFMPI* variables if you don\PYGZsq{}t have parallel HDF installed}
\PYG{n}{HDFMPIINCFLAGS} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{I}\PYG{o}{/}\PYG{n}{cluster}\PYG{o}{/}\PYG{n}{software}\PYG{o}{/}\PYG{n}{HDF5}\PYG{o}{/}\PYG{l+m+mf}{1.10}\PYG{l+m+mf}{.1}\PYG{o}{\PYGZhy{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2017}\PYG{n}{a}\PYG{o}{/}\PYG{n}{include}
\PYG{n}{HDFMPILIBFLAGS} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{L}\PYG{o}{/}\PYG{n}{cluster}\PYG{o}{/}\PYG{n}{software}\PYG{o}{/}\PYG{n}{HDF5}\PYG{o}{/}\PYG{l+m+mf}{1.10}\PYG{l+m+mf}{.1}\PYG{o}{\PYGZhy{}}\PYG{n}{intel}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2017}\PYG{n}{a}\PYG{o}{/}\PYG{n}{lib} \PYG{o}{\PYGZhy{}}\PYG{n}{lhdf5} \PYG{o}{\PYGZhy{}}\PYG{n}{lz}
\PYG{n}{USE\PYGZus{}MF}         \PYG{o}{=} \PYG{n}{TRUE}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{USE\PYGZus{}MT        =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{USE\PYGZus{}SETVAL    =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{CH\PYGZus{}AR         =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{CH\PYGZus{}CPP        =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{DOXYGEN       =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{LD            =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{PERL          =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{RANLIB        =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cppdbgflags   =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cppoptflags   =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cxxcppflags   =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cxxdbgflags   =}
\PYG{n}{cxxoptflags}    \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{Ofast} \PYG{o}{\PYGZhy{}}\PYG{n}{xCORE}\PYG{o}{\PYGZhy{}}\PYG{n}{AVX2} \PYG{o}{\PYGZhy{}}\PYG{n}{march}\PYG{o}{=}\PYG{n}{native}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{cxxprofflags  =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{fcppflags     =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{fdbgflags     =}
\PYG{n}{foptflags}      \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{Ofast} \PYG{o}{\PYGZhy{}}\PYG{n}{xCORE}\PYG{o}{\PYGZhy{}}\PYG{n}{AVX2}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{fprofflags    =}
\PYG{n}{flibflags}      \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{lblas} \PYG{o}{\PYGZhy{}}\PYG{n}{llapack}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{lddbgflags    =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ldoptflags    =}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ldprofflags   =}
\PYG{n}{syslibflags}    \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{ldl} \PYG{o}{\PYGZhy{}}\PYG{n}{lm} \PYG{o}{\PYGZhy{}}\PYG{n}{lz}
\end{sphinxVerbatim}

We also recommend that you create environment variables that hold the path to your \sphinxcode{\sphinxupquote{PlasmaC}} version. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{PLASMAC\PYGZus{}HOME}\PYG{o}{=}\PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{foo}\PYG{o}{/}\PYG{n}{plasmac}
\end{sphinxVerbatim}

This environment variables is used in the \sphinxcode{\sphinxupquote{PlasmaC}} makefile system so that our makefiles can find \sphinxcode{\sphinxupquote{PlasmaC}}.

We recommend that you take care of your \sphinxcode{\sphinxupquote{Make.defs.local}} for all your computers.
If you want, you may place your \sphinxcode{\sphinxupquote{Make.defs.local}} for all your computers into \sphinxcode{\sphinxupquote{/src/local}} and push to the main repository.


\subsection{Compiling \sphinxtitleref{PlasmaC}}
\label{\detokenize{GettingStarted:compiling-plasmac}}\label{\detokenize{GettingStarted:chap-compiling}}
In \sphinxtitleref{PlasmaC}, each problem is compiled as a mini\sphinxhyphen{}application into a subfolder.
Mini\sphinxhyphen{}apps are usually set up through a Python pre\sphinxhyphen{}compilation script that generates the required source code, makefiles, and simulation parameters.
There is no separate build for the \sphinxcode{\sphinxupquote{PlasmaC}} source code and your own application files and you will \sphinxstyleemphasis{not} be able to install \sphinxcode{\sphinxupquote{PlasmaC}} as a separate library.

Once an application has been set up, the makefile system tracks the necessary \sphinxtitleref{Chombo} and \sphinxcode{\sphinxupquote{PlasmaC}} source files.
Compiling is done in the subfolder that houses your mini\sphinxhyphen{}app:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
make \PYGZhy{}s \PYGZhy{}j8 \PYG{n+nv}{DIM}\PYG{o}{=}\PYG{l+m}{2} \PYG{n+nv}{OPT}\PYG{o}{=}HIGH \PYGZlt{}application\PYGZus{}name\PYGZgt{}
\end{sphinxVerbatim}

We generally recommend that you compile with \sphinxcode{\sphinxupquote{OPT=HIGH}} for performance reasons.


\subsection{Visualization}
\label{\detokenize{GettingStarted:visualization}}
PlasmaC writes output files to HDF5. Users can decide what data to output, as well as restrict plot depth to a certain grid levels level. There are also options for including ghost cells in the output files.

Our favorite tool for visualization is \sphinxhref{https://wci.llnl.gov/codes/visit/}{VisIt}, which can be freely downloaded. Our experience is that client\sphinxhyphen{}server visualization is beneficial for visualization of three\sphinxhyphen{}dimensional simulation data. For information on how to set up host profiles for VisIt, please contact your local guru or refer to the \sphinxhref{http://visit-sphinx-user-manual.readthedocs.io/en/latest/index.html}{VisIt documentation}.


\subsection{My first compilation}
\label{\detokenize{GettingStarted:my-first-compilation}}\label{\detokenize{GettingStarted:chap-myfirstcompilation}}
Before moving on with more complex descriptions of \sphinxtitleref{PlasmaC}, we will try to compile a test problem which simply advects a scalar.
The application we will use is a part of the regression testing in \sphinxtitleref{PlasmaC}.

To run this application, navigate to \sphinxcode{\sphinxupquote{/regression/advection\_diffusion}} and compile with

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
make \PYGZhy{}s \PYGZhy{}j4 \PYG{n+nv}{DIM}\PYG{o}{=}\PYG{l+m}{2} main
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{\sphinxhyphen{}j4}} is the number of cores used for the compilation. If you want to compile this example in 3D, you should put DIM=3.
If the application compiles successfully, you will see a file called \sphinxcode{\sphinxupquote{main2d.\textless{}bunch\_of\_options\textgreater{}.ex}}.
If you see this file, you will be able to compile all of \sphinxtitleref{PlasmaC}. If you don’t, you won’t be able to compile any of it.
Before moving on further, please make sure that your model compiles.

Once we have compiled our application, we are ready to run it.
The example that we will run is a very simple setup of scalar advection and diffusion of a rotating flow, where the base code is provided in \sphinxcode{\sphinxupquote{/physics/advection\_diffusion}}.
To run the example, you can do

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
mpirun \PYGZhy{}np \PYG{l+m}{4} main2d.\PYGZlt{}bunch\PYGZus{}of\PYGZus{}options\PYGZgt{}.ex regression2d.inputs
\end{sphinxVerbatim}

Output files should now appear in \sphinxcode{\sphinxupquote{/regression/advection\_diffusion/plt}}.


\subsection{Troubleshooting}
\label{\detokenize{GettingStarted:troubleshooting}}
If the prerequisites are in place, compilation of \sphinxcode{\sphinxupquote{PlasmaC}} is usually straightforward.
However, due to dependencies on \sphinxtitleref{Chombo} and HDF5, compilation can sometimes be an issue.
Our experience is that if \sphinxtitleref{Chombo} compiles, so does \sphinxtitleref{PlasmaC}.
For that reason we refer you to the \sphinxtitleref{Chombo} user guide for troubleshooting.


\subsection{Using this documentation}
\label{\detokenize{GettingStarted:using-this-documentation}}
This documentation was built using \sphinxtitleref{reStructuredText} with \sphinxtitleref{Sphinx}. If you want to build a PDF version of this documentation, please navigate to \sphinxcode{\sphinxupquote{plasmac/doc/sphinx}} and execute

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
make latexpdf
\end{sphinxVerbatim}

A PDF version of this documentation named \sphinxcode{\sphinxupquote{PlasmaC.pdf}} will appear in \sphinxcode{\sphinxupquote{plasma/doc/sphinx/build/latex}}.


\section{The \sphinxstyleliteralintitle{\sphinxupquote{PlasmaC}} code}
\label{\detokenize{Model:the-plasmac-code}}\label{\detokenize{Model:chap-model}}\label{\detokenize{Model::doc}}
The \sphinxcode{\sphinxupquote{PlasmaC}} code is a loosely coupled code targeted at solving plasma problems.
The code uses an embedded boundary (EB) adaptive mesh refinement (AMR) formalism where the grids frequently change and are adapted to the solution as simulations progress.
By design, the \sphinxcode{\sphinxupquote{PlasmaC}} does not subcycle and all the grids are advanced using the same time step.
\sphinxcode{\sphinxupquote{PlasmaC}} also supports the concept of a {\hyperref[\detokenize{Realm:chap-realm}]{\sphinxcrossref{\DUrole{std,std-ref}{Realm}}}}, which in short means that \sphinxcode{\sphinxupquote{PlasmaC}} supports using one set of grids for Eulerian solvers and a different set of grids for Lagrangian solvers.

The core functionality is centered around a set of solvers, for example a Poisson solver and a convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solver, and then using the built\sphinxhyphen{}in solver functionality to advance the equations of motion.
This is done through a class \sphinxcode{\sphinxupquote{time\_stepper}}, which is an abstract class that advances the equations of motion within the \sphinxcode{\sphinxupquote{PlasmaC}} framework.
The \sphinxcode{\sphinxupquote{time\_stepper}} can instantiate an arbitrary number of solvers, and allows developers to use a fairly high\sphinxhyphen{}level description of their problem.
For example, all \sphinxstyleemphasis{solvers} have functions like \sphinxcode{\sphinxupquote{write\_plot\_data(...)}} that the user may use within the \sphinxcode{\sphinxupquote{time\_stepper}} output routines.

Although many abstractions are in place so that user can describe a new set of physics, or write entirely new solvers into \sphinxcode{\sphinxupquote{PlasmaC}} and still use the EBAMR formalism, \sphinxcode{\sphinxupquote{PlasmaC}} also provide some physics modules for describing various types of problems.
These modules reside in \sphinxcode{\sphinxupquote{/physics}} and they are intended to both be problem\sphinxhyphen{}solving physics modules, and as well acting like benchmarks, regression tests, and examples for extension to new types of physics modules in the future.


\subsection{Main functionality}
\label{\detokenize{Model:main-functionality}}
The main functionality in \sphinxcode{\sphinxupquote{PlasmaC}} is centered around the concept of a {\hyperref[\detokenize{Solver:chap-solver}]{\sphinxcrossref{\DUrole{std,std-ref}{Solver}}}}.

In this section we summarize how components in \sphinxcode{\sphinxupquote{PlasmaC}} are connected, such that users may understand more readily how the code is designed.

There are four major components \sphinxtitleref{PlasmaC}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
A computational geometry which describes a level\sphinxhyphen{}set geometry consisting of electrodes and possibly also dielectrics.
This functionality is encapsulated by {\hyperref[\detokenize{ComputationalGeometry:chap-computational-geometry}]{\sphinxcrossref{\DUrole{std,std-ref}{computational\_geometry}}}}.

\item {} 
An AMR mesh which contains the grids, grid generation routines, and functionality for handling data coarsening and refinement.
This functionality is encapsulated by {\hyperref[\detokenize{AmrMesh:chap-amr-mesh}]{\sphinxcrossref{\DUrole{std,std-ref}{amr\_mesh}}}}.
The \sphinxcode{\sphinxupquote{amr\_mesh}} class acts as a centralized repository for grid generation, performing AMR operations like filling ghost cells, allocating data over the AMR hierarchy and so on.
\sphinxcode{\sphinxupquote{amr\_mesh}} is a standalone class \sphinxhyphen{} it has no view over the rest of \sphinxcode{\sphinxupquote{PlasmaC}}.

\item {} 
A time stepper which advances the equations of motion (whatever they are).
This class has been made abstract with a public interface that is used by the \sphinxcode{\sphinxupquote{driver}} class (see below).
In order to actually use \sphinxcode{\sphinxupquote{PlasmaC}} for anything the user must either write his own derived {\hyperref[\detokenize{TimeStepper:chap-time-stepper}]{\sphinxcrossref{\DUrole{std,std-ref}{time\_stepper}}}} class, or use one of the pre\sphinxhyphen{}defined physics modules.
The \sphinxcode{\sphinxupquote{time\_stepper}} is purposefully quite general so that the whole \sphinxcode{\sphinxupquote{PlasmaC}} framework can be set up to solve completely new sets of equations without affecting the rest of the framework.

\item {} 
A cell tagger which flags cells for refinement and coarsening.
This functionality is encapsulated by the {\hyperref[\detokenize{CellTagger:chap-cell-tagger}]{\sphinxcrossref{\DUrole{std,std-ref}{cell\_tagger}}}} class and it, too, is abstract.

\end{enumerate}

Instantiations of the above four classes are fed into the {\hyperref[\detokenize{Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{driver}}}} class which contains calling functions for generation the geometry, having the time integrator to perform and time step, performing, I/O, setting checkpoint/restart and so on.
The reason for the above division of labor is that we have wanted to segregate responsibilities in order to increase flexibility.
For that reason, the computational geometry does not have any view of the actual AMR grids; it only contains the level\sphinxhyphen{}set functions and some meta\sphinxhyphen{}information (such as the permittivity of a dielectric).
Likewise, the {\hyperref[\detokenize{AmrMesh:chap-amr-mesh}]{\sphinxcrossref{\DUrole{std,std-ref}{amr\_mesh}}}} class only acts a centralized repository of useful functions for AMR simulations.
These functions include algorithms for generating AMR grids, allocating data across AMR, and synchronizing AMR levels (e.g. interpolating ghost cells).

All the physics is encapsulated by the {\hyperref[\detokenize{TimeStepper:chap-time-stepper}]{\sphinxcrossref{\DUrole{std,std-ref}{time\_stepper}}}} class.
This class will have direct ownership of all the solvers and the functions required to advance them over a time step.
Instantiations of the class will also contain the routines for setting up a simulation, e.g. instantiating solvers, setting up boundary conditions.
Typically, implementation new physics consists of writing a new \sphinxcode{\sphinxupquote{time\_stepper}} class that allocates the relevant solvers, and then implement the time integration algorithms that advances them.
The folder \sphinxcode{\sphinxupquote{/physics}} contains implementation of a few different physics modules.
Since problems within a physics module tend to be conceptually similar, all of these modules also have a Python setup script so that users can quickly set up new types of problems within the same module.

The {\hyperref[\detokenize{Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{driver}}}} class is only responsible for \sphinxstyleemphasis{running} a simulation, and it uses \sphinxcode{\sphinxupquote{time\_stepper}} to do so.
The {\hyperref[\detokenize{Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{driver}}}} class will call for regrids at certain intervals, call the {\hyperref[\detokenize{TimeStepper:chap-time-stepper}]{\sphinxcrossref{\DUrole{std,std-ref}{time\_stepper}}}} for writing plot and checkpoint data, and also call for the {\hyperref[\detokenize{TimeStepper:chap-time-stepper}]{\sphinxcrossref{\DUrole{std,std-ref}{time\_stepper}}}} to advance the equations of motion through a function \sphinxcode{\sphinxupquote{advance(...)}}.
In order to understand how \sphinxcode{\sphinxupquote{PlasmaC}} runs a simulation, it will be useful to first understand how {\hyperref[\detokenize{Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{driver}}}} works.


\subsubsection{Solvers}
\label{\detokenize{Model:solvers}}
Various solvers are implemented in \sphinxcode{\sphinxupquote{PlasmaC}}, see {\hyperref[\detokenize{index:chap-supportedsolvers}]{\sphinxcrossref{\DUrole{std,std-ref}{Supported Solvers}}}}.
All solvers are designed to run through the \sphinxcode{\sphinxupquote{time\_stepper}} class.
Therefore, in order to run only a single solver (e.g. advection\sphinxhyphen{}diffusion or Poisson), one must have a \sphinxcode{\sphinxupquote{time\_stepper}} implementation that allocates the appropriate solver, sets it up, and runs it.
Currently, there are separate physics modules for each type of solver such that users may see how they are set up and run.
These are located in \sphinxcode{\sphinxupquote{/physics/}}.

The solvers may be abstract or non\sphinxhyphen{}abstract.
All solvers that are \sphinxstyleemphasis{not} abstract are supplemented by an options file that contain all the possible run\sphinxhyphen{}time configurations that can be made to the solver.
Such options can include multigrid parameters, how to handle particle deposition with refinement boundaries, slope limiters, etc.
For example, all numerical solvers have independent adjustment of output.
The input parameters for each solver class is included in a separate file named \sphinxcode{\sphinxupquote{\textless{}solver\textgreater{}.options}} that resides in the same folder as the solver.
For example, the input parameters for the default Poisson solver defined in \sphinxcode{\sphinxupquote{/src/poisson/poisson\_multifluid\_gmg.H}} is contained in a file \sphinxcode{\sphinxupquote{/src/poisson/poisson\_multifluid\_gmg.options}}.


\subsubsection{Simulation inputs}
\label{\detokenize{Model:simulation-inputs}}
\sphinxcode{\sphinxupquote{PlasmaC}} simulations take their input from a single simulation input file, possibly appended with overriding options on the command line.
Simulations may consist of several hundred possible switches for altering the behavior of a simulation, and physics models in \sphinxcode{\sphinxupquote{PlasmaC}} are therefore equipped with Python setup tools that collect all such options in a single file.
Generally, these input parameters are fetched from the options file of each class that is used in a simulation.
Simulation options usually consist of a prefix, a suffix, and a configuration value.
For example, the configuration options that adjusts the number of time steps that will be run in a simulation is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
driver.max\PYGZus{}steps \PYG{o}{=} \PYG{l+m}{100}
\end{sphinxVerbatim}


\subsubsection{Simulation outputs}
\label{\detokenize{Model:simulation-outputs}}
Mesh data from \sphinxcode{\sphinxupquote{PlasmaC}} simulations is by default written to HDF5 files.
Users that wish to write or output other types of data must supply code themselves.

In addition to plot files, MPI ranks can output information to separate files so that the simulation progress can be tracked.
See {\hyperref[\detokenize{Control:chap-control}]{\sphinxcrossref{\DUrole{std,std-ref}{Controlling PlasmaC}}}} for details.
This is also useful for debugging purposes.


\subsection{Spatial discretization}
\label{\detokenize{Model:spatial-discretization}}\label{\detokenize{Model:chap-spatialdiscretization}}
\sphinxtitleref{PlasmaC} uses structured adaptive mesh refinement (SAMR provided by Chombo \sphinxcite{References:ebchombo}.
SAMR exists in two separate categories, patch\sphinxhyphen{}based and tree\sphinxhyphen{}based AMR.
Patch\sphinxhyphen{}based AMR is the more general type and contain tree\sphinxhyphen{}based grids as a subset; they can use refinement factors other than 2, as well as accomodate anisotropic resolutions and non\sphinxhyphen{}cubic patches.
In patch\sphinxhyphen{}based AMR the domain is subdivided into a collection of hierarchically nested overlapping patches (or boxes).
Each patch is a rectangular block of cells which, in space, exists on a subdomain of the union of patches with a coarser resolution.
Patch\sphinxhyphen{}based grids generally do not have unique parent\sphinxhyphen{}children relations: A fine\sphinxhyphen{}level patch may have multiple coarse\sphinxhyphen{}level parents.
An obvious advantage of a patch\sphinxhyphen{}based approach is that entire Cartesian blocks are sent into solvers, and that the patches are not restricted to squares or cubes that align with the coarse\sphinxhyphen{}grid boundary.
A notable disadvantage is that additional logic is required when updating a coarse grid level from the overlapping region of a finer level.
Tree\sphinxhyphen{}based AMR use quadtree or octree data structures that describe a hierarchy of unique parent\sphinxhyphen{}children relations throughout the AMR levels: Each child has exactly one parent, whereas each parent has multiple children (4 in 2D, 8 in 3D).
In \sphinxcode{\sphinxupquote{PlasmaC}} and Chombo, computations occur over a set of levels with different resolutions, where the resolution refinement between levels can be a factor 2 or 4.
On each level, the mesh is described by a set of disjoint patches (rectangular box in space), where the patches are distributed among MPI processes.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=480\sphinxpxdimen]{{complex_patches}.png}
\caption{Patch\sphinxhyphen{}based refinement (factor 4 between levels) of a complex surface. Each color shows a patch, which is a rectangular computational unit.}\label{\detokenize{Model:id2}}\end{figure}

Embedded boundary applications are supported by additionally describing the mesh with a graph near cut\sphinxhyphen{}cells.
This allows us to combine the efficiency of patch\sphinxhyphen{}based AMR with complex geometries.
However, there is significant overhead with the embedded boundary approach and, furthermore, arbitrarily complex geometries are not possible.


\subsubsection{Mesh generation}
\label{\detokenize{Model:mesh-generation}}\label{\detokenize{Model:chap-meshgeneration}}
\sphinxtitleref{PlasmaC} offers two algorithm for AMR grid generation.
Both algorithms work by taking a set of flagged cells on each grid level and generating new boxes that cover the flags.
The first algorithm that we support is the classical Berger\sphinxhyphen{}Rigoustous grid algorithm that ships with Chombo, see the figure below.
The classical Berger\sphinxhyphen{}Rigoustous algorithm is serial\sphinxhyphen{}like in the sense that is collects the flagged cells onto each MPI rank and then generates the boxes.
The algorithm is typically not used at large scale because of its memory consumption.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=240\sphinxpxdimen]{{amr}.png}
\caption{Classical cartoon of patch\sphinxhyphen{}based refinement. Bold lines indicate entire grid blocks.}\label{\detokenize{Model:id3}}\end{figure}

As an alternative, we also support a tiled algorithm where the grid boxes on each block are generated according to a predefined tiled pattern.
If a tile contains a single tag, the entire tile is flagged for refinement.
The tiled algorithm produces grids that are similar to octrees, but it is more general since it also supports refinement factors other than 2, and is not restricted to domain extensions that are an integer factor of 2 (e.g. \(2^{10}\) cells in each direction).

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=360\sphinxpxdimen]{{tiled}.png}
\caption{Classical cartoon of tiled patch\sphinxhyphen{}based refinement. Bold lines indicate entire grid blocks.}\label{\detokenize{Model:id4}}\end{figure}


\subsubsection{Geometry generation}
\label{\detokenize{Model:geometry-generation}}\label{\detokenize{Model:chap-ebmesh}}
Geometry generation for \sphinxcode{\sphinxupquote{PlasmaC}} follows that of Chombo. In Chombo, the geometries are generated from an implicit function \(f(\mathbf{x}) = 0\) that describes the level\sphinxhyphen{}set surface.

In \sphinxtitleref{Chombo}, geometry generation is done by first constructing a set of boxes that covers the finest AMR level.
If the function intersects one of these boxes, the box will allocate a \sphinxstyleemphasis{graph} that describes the connectivity of the volume\sphinxhyphen{}of\sphinxhyphen{}fluid indices in the entire box.
The geometric data in the box is allocated sparsely so that memory consumption due to EB information storage is typically not very high.
In general, there should be no graphs in boxes that are all\sphinxhyphen{}covered or all\sphinxhyphen{}regular.

When EB information is first generated across the AMR hierarchy, one begins by computing the information on the finest grid level.
From there, coarser levels are generated through \sphinxstyleemphasis{coarsening} of the fine\sphinxhyphen{}information data.
The default load\sphinxhyphen{}balancing for geometry generation in \sphinxtitleref{Chombo} is an even division of the grid level among the ranks.
This is a reasonable approach for porous media where the cut\sphinxhyphen{}cells distribute evenly through the computational domain.
However, most geometries consists of a small 2D surface in 3D space and the default Chombo approach wastes a lot of time looking for cut\sphinxhyphen{}cells where they don’t exist.

To achieve scalable geometry generation, we have changed how \sphinxtitleref{Chombo} generates the geometry generation on the various levels.
Our new approach first generates a map on a \sphinxstyleemphasis{coarse} level which is specified by the user.
On the specified level the domain is broken up into equal\sphinxhyphen{}sized chunks and cut\sphinxhyphen{}cell boxes are located.
Uncut and cut boxes are load balanced among the various ranks.
We then proceed towards the next finer level where the cut\sphinxhyphen{}cell boxes are identified by a refinement of the box distribution on the previous level.
Boxes that resulted from a refinement of the coarse level cut boxes are again broken up into equal\sphinxhyphen{}sized chunks, whereas the uncut boxes are not.
This is again followed by load\sphinxhyphen{}balancing of the cut boxes, and this process is repeated recursively down to the finest AMR level.
In essence, the geometry generation is load balanced based on where the cut cells are going to be.
For the user, he will be able to switch between the \sphinxtitleref{Chombo} and \sphinxcode{\sphinxupquote{PlasmaC}} approaches to geometry generation load balancing by flipping a flag in an input script.


\section{Chombo basics}
\label{\detokenize{Basics:chombo-basics}}\label{\detokenize{Basics:chap-basics}}\label{\detokenize{Basics::doc}}
To fully understand this documentation the user must be familiar with Chombo.
This documentation uses class names from Chombo and the most relevant Chombo data structures are summarized here.
What follows is a \sphinxstyleemphasis{very} brief introduction to these data structures, for in\sphinxhyphen{}depth explanations please see the Chombo manual.


\subsection{Real}
\label{\detokenize{Basics:real}}
\sphinxcode{\sphinxupquote{Real}} is a typedef’ed structure for holding a single floating point number.
Compilating with double precision will typedef \sphinxcode{\sphinxupquote{Real}} as \sphinxcode{\sphinxupquote{double}}, otherwise it is typedef’ed as \sphinxcode{\sphinxupquote{float}}


\subsection{RealVect}
\label{\detokenize{Basics:realvect}}
\sphinxcode{\sphinxupquote{RealVect}} is a spatial vector.
It holds two \sphinxcode{\sphinxupquote{Real}} components in 2D and three \sphinxcode{\sphinxupquote{Real}} components in 3D.
The \sphinxcode{\sphinxupquote{RealVect}} class has floating point arithmetic, e.g. addition, subtraction, multiplication etc.

Most of \sphinxcode{\sphinxupquote{PlasmaC}} is written in dimension\sphinxhyphen{}independent code, and for cases where \sphinxcode{\sphinxupquote{RealVect}} is initialized with components the constructor uses Chombo macros for expanding the correct number of arguments.
For example

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RealVect} \PYG{n+nf}{v}\PYG{p}{(}\PYG{n}{D\PYGZus{}DECL}\PYG{p}{(}\PYG{n}{vx}\PYG{p}{,} \PYG{n}{vy}\PYG{p}{,} \PYG{n}{vz}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

will expand to \sphinxcode{\sphinxupquote{RealVect(vx,vy)}} in 2D and \sphinxcode{\sphinxupquote{RealVect(vx, vy, vz)}} in 3D.


\subsection{IntVect}
\label{\detokenize{Basics:intvect}}
\sphinxcode{\sphinxupquote{IntVect}} is an integer spatial vector, and is used for indexing data structures.
It works in much the same way as \sphinxcode{\sphinxupquote{RealVect}}, except that the components are integers.


\subsection{Box}
\label{\detokenize{Basics:box}}
The \sphinxcode{\sphinxupquote{Box}} object describes a Box in Cartesian space.
The boxes are indexed by the low and high corners, both of which are \sphinxcode{\sphinxupquote{IntVect\textasciigrave{}\textasciigrave{}s.
The \textasciigrave{}\textasciigrave{}Box}} may be cell\sphinxhyphen{}centered or face\sphinxhyphen{}centered.
To turn a cell\sphinxhyphen{}centered \sphinxcode{\sphinxupquote{Box}} into a face\sphinxhyphen{}centered box one would do

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Box} \PYG{n+nf}{bx}\PYG{p}{(}\PYG{n}{IntVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Zero}\PYG{p}{,} \PYG{n}{IntVect}\PYG{o}{:}\PYG{o}{:}\PYG{n}{Unit}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Default constructor give cell centered boxes}
\PYG{n}{bx}\PYG{p}{.}\PYG{n}{surroundingNodes}\PYG{p}{(}\PYG{p}{)}\PYG{o}{:}                \PYG{c+c1}{// Now a cell\PYGZhy{}centered box}
\end{sphinxVerbatim}

This will increase the box dimensions by one in each coordinate direction.


\subsection{EBCellFAB and FArrayBox}
\label{\detokenize{Basics:ebcellfab-and-farraybox}}
The \sphinxcode{\sphinxupquote{EBCellFAB}} object is an array for holding cell\sphinxhyphen{}centered data in an embedded boundary context.
The \sphinxcode{\sphinxupquote{EBCellFAB}} is defined over a \sphinxcode{\sphinxupquote{Box}} and the cut\sphinxhyphen{}cell geometry in the same \sphinxcode{\sphinxupquote{Box}}.
For cut\sphinxhyphen{}cells, there is a chance that the boundaries intersect the grid in such a way that a cell has more than one degree of freedom.
Data therefore needs to live on more complex data structures than simple arrays.

The \sphinxcode{\sphinxupquote{EBCellFAB}} has two data structures: An \sphinxcode{\sphinxupquote{FArrayBox}} that holds the data on the cell centers, and is supported by a graph that additionally holds data in cells that are multiply cut.
The \sphinxcode{\sphinxupquote{FArrayBox}} is essentially a Fortran array that can be passed to Fortran for performance reasons.
Doing arithmetic with \sphinxcode{\sphinxupquote{EBCellFAB}} usually requires one to iterate over all the cell in the \sphinxcode{\sphinxupquote{FArrayBox}}, and then to iterate over the \sphinxstyleemphasis{irregular cells} (i.e. cut\sphinxhyphen{}cells) later.
The \sphinxcode{\sphinxupquote{VofIterator}} can iterate over any number cells, but is typically used only to iterate over the cut\sphinxhyphen{}cells in a \sphinxcode{\sphinxupquote{Box}}.
Typically, code for doing anything with the \sphinxcode{\sphinxupquote{EBCellFAB}} looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Call fortran code}
\PYG{n}{FORT\PYGZus{}DO\PYGZus{}SOMETHING}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}

\PYG{c+c1}{// Iterate over cut\PYGZhy{}cells}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{VoFIterator} \PYG{n}{vofit}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;} \PYG{n}{vofit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{vofit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Vector}
\label{\detokenize{Basics:vector}}
\sphinxcode{\sphinxupquote{Vector\textless{}T\textgreater{}}} is a one\sphinxhyphen{}dimensional array with constant\sphinxhyphen{}time random access and range checking.
It uses \sphinxcode{\sphinxupquote{std::vector}} under the hood and can access the most commonly used \sphinxcode{\sphinxupquote{std::vector}} functionality through the public member functions.
E.g. to obtain an element in the vector

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{my\PYGZus{}vector}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{T}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{element} \PYG{o}{=} \PYG{n}{my\PYGZus{}vector}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

Likewise, \sphinxcode{\sphinxupquote{push\_back}}, \sphinxcode{\sphinxupquote{resize}} etc works in much the same way as for \sphinxcode{\sphinxupquote{std::vector}}.


\subsection{RefCountedPtr}
\label{\detokenize{Basics:refcountedptr}}
\sphinxcode{\sphinxupquote{RefCountedPtr\textless{}T\textgreater{}}} is a pointer class in Chombo with reference counting.
That is, when objects that hold a reference to some \sphinxcode{\sphinxupquote{RefCountedPtr\textless{}T\textgreater{}}} object goes out of scope the reference counter is decremented.
If the reference counter reaches zero, the object that \sphinxcode{\sphinxupquote{RefCountedPtr\textless{}T\textgreater{}}} points to it deallocated.
Using \sphinxcode{\sphinxupquote{RefCountedPtr\textless{}T\textgreater{}}} is much preferred over using a bare pointer \sphinxcode{\sphinxupquote{T*}} to 1) avoid memory leaks and 2) compress code since no explicit deallocations need to be called.

In modern C++ speak, \sphinxcode{\sphinxupquote{RefCountedPtr\textless{}T\textgreater{}}} can be thought of as a bare\sphinxhyphen{}bones \sphinxcode{\sphinxupquote{std::shared\_ptr}} (without the move semantics and so on).


\subsection{DisjointBoxLayout}
\label{\detokenize{Basics:disjointboxlayout}}
The \sphinxcode{\sphinxupquote{DisjointBoxLayout}} describes a grid on an AMR level where all the boxes are \sphinxstyleemphasis{disjoint}, i.e. they don’t overlap.
\sphinxcode{\sphinxupquote{DisjointBoxLayout}} is built upon a collection of boxes and the MPI rank ownership of those boxes.
The constructor is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Box}\PYG{o}{\PYGZgt{}} \PYG{n}{boxes}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Vector of disjoint boxes}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{ranks}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Ownership of each box}

\PYG{n}{DisjointBoxLayout} \PYG{n+nf}{dbl}\PYG{p}{(}\PYG{n}{boxes}\PYG{p}{,} \PYG{n}{ranks}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In simple terms,  \sphinxcode{\sphinxupquote{DisjointBoxLayout}} is the decomposed grid on each level in which MPI ranks have unique ownership of specific parts of the grid.

The \sphinxcode{\sphinxupquote{DisjointBoxLayout}} view is global, i.e. each MPI rank knows about all the boxes and the box ownership on the entire AMR level.
However, ranks will only allocate data on the part of the grid that they own.
Data iterators also exist, and the most common is to use iterators that only iterate over the part of the \sphinxcode{\sphinxupquote{DisjointBoxLayout}} that the specific MPI ranks own:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit} \PYG{o}{=} \PYG{n}{dbl}\PYG{p}{.}\PYG{n}{dataIterator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{c+c1}{// Do something}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Each MPI rank will then iterate \sphinxstyleemphasis{only} over the part of the grid where it has ownership.

Other data iterators exist that iterate over the \sphinxstyleemphasis{whole} grid:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{for} \PYG{p}{(}\PYG{n}{LayoutIterator} \PYG{n}{dit} \PYG{o}{=} \PYG{n}{dbl}\PYG{p}{.}\PYG{n}{layoutIterator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{c+c1}{// Do something}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This is typically used if one wants to do some global operation, e.g. count the number of cells in the grid or somesuch.
If you try to use \sphinxcode{\sphinxupquote{LayoutIterator}} to retrieve data that was allocated locally, you will get a memory corruption.


\subsection{LevelData}
\label{\detokenize{Basics:leveldata}}
The \sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} template structure holds data on all the grid patches of one AMR level.
The data is distributed with the domain decomposition specified by \sphinxcode{\sphinxupquote{DisjointBoxLayout}}, and each patch contains exactly one instance of \sphinxcode{\sphinxupquote{T}}.
\sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} uses a factory pattern for creating the \sphinxcode{\sphinxupquote{T}} objects, so if you have new data structures that should fit the in \sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} structure you must also implement a factory method for \sphinxcode{\sphinxupquote{T}}.

To iterate over \sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} one will use the data iterator above:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{LevelData}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{myData}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit} \PYG{o}{=} \PYG{n}{dbl}\PYG{p}{.}\PYG{n}{dataIterator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{const} \PYG{n}{DataIndex}\PYG{o}{\PYGZam{}} \PYG{n}{d} \PYG{o}{=} \PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{o}{=} \PYG{n}{myData}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{{[}DataIndex{]}}} is an indexing operator for \sphinxcode{\sphinxupquote{LevelData}}.

\sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} also includes the concept of ghost cells and exchange operations.
Specifying ghost cells is primarily controlled in input scripts for simulations.


\subsection{EBISLayout and EBISBox}
\label{\detokenize{Basics:ebislayout-and-ebisbox}}
The \sphinxcode{\sphinxupquote{EBISLayout}} holds the geometric information over one \sphinxcode{\sphinxupquote{DisjointBoxLayout}} level.
Typically, the \sphinxcode{\sphinxupquote{EBISLayout}} is used to obtain information about the cut\sphinxhyphen{}cells.
\sphinxcode{\sphinxupquote{EBISLayout}} also has an indexing operator that can be used to extract a pointer to the geometric information in only one of the boxes on the level.
This indexing operator is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{EBISLayout} \PYG{n+nf}{ebisl}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit} \PYG{o}{=} \PYG{n}{dbl}\PYG{p}{.}\PYG{n}{dataIterator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{const} \PYG{n}{DataIndex}\PYG{o}{\PYGZam{}} \PYG{n}{d} \PYG{o}{=} \PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{EBISBox}\PYG{o}{\PYGZam{}} \PYG{n}{ebisbox} \PYG{o}{=} \PYG{n}{ebisl}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{EBISBox}} contains the geometric information over only one \sphinxcode{\sphinxupquote{Box}}.

As an example, to iterate over all the cut\sphinxhyphen{}cells defined for a cell\sphinxhyphen{}centered data holder an AMR\sphinxhyphen{}level one would do:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{comp} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{n}{LevelData}\PYG{o}{\PYGZlt{}}\PYG{n}{EBCellFAB}\PYG{o}{\PYGZgt{}} \PYG{n}{myData}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{EBISLayout} \PYG{n+nf}{ebisl}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit} \PYG{o}{=} \PYG{n}{dbl}\PYG{p}{.}\PYG{n}{dataIterator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{const} \PYG{n}{DataIndex}\PYG{o}{\PYGZam{}} \PYG{n}{d} \PYG{o}{=} \PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{const} \PYG{n}{Box} \PYG{n}{bx}       \PYG{o}{=} \PYG{n}{dbl}\PYG{p}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{EBCellFAB}\PYG{o}{\PYGZam{}} \PYG{n}{ebcell} \PYG{o}{=} \PYG{n}{myData}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{EBISBox}\PYG{o}{\PYGZam{}} \PYG{n}{ebisbox}  \PYG{o}{=} \PYG{n}{ebisl}\PYG{p}{[}\PYG{n}{d}\PYG{p}{]}\PYG{p}{;}

   \PYG{k}{const} \PYG{n}{IntVectSet}\PYG{o}{\PYGZam{}} \PYG{n}{ivs} \PYG{o}{=} \PYG{n}{ebisbox}\PYG{p}{.}\PYG{n}{getIrregIVS}\PYG{p}{(}\PYG{n}{box}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{const} \PYG{n}{EBGraph}\PYG{o}{\PYGZam{}}        \PYG{o}{=} \PYG{n}{ebisbox}\PYG{p}{.}\PYG{n}{getEBGraph}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{for} \PYG{p}{(}\PYG{n}{VoFIterator} \PYG{n}{vofit}\PYG{p}{(}\PYG{n}{ivs}\PYG{p}{,} \PYG{n}{ebgraph}\PYG{p}{)}\PYG{p}{;} \PYG{n}{vofit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{vofit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k}{const} \PYG{n}{VolIndex}\PYG{o}{\PYGZam{}} \PYG{n}{vof} \PYG{o}{=} \PYG{n}{vofit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

      \PYG{n}{ebcell}\PYG{p}{(}\PYG{n}{vof}\PYG{p}{,} \PYG{n}{comp}\PYG{p}{)} \PYG{o}{=} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

Here, \sphinxcode{\sphinxupquote{EBGraph}} is the graph that describes the connectivity of the cut cells.


\chapter{Understanding PlasmaC}
\label{\detokenize{index:understanding-plasmac}}\label{\detokenize{index:chap-usingplasmac}}

\section{Realm}
\label{\detokenize{Realm:realm}}\label{\detokenize{Realm:chap-realm}}\label{\detokenize{Realm::doc}}
The \sphinxcode{\sphinxupquote{realm}} class is a class for centralizing EBAMR\sphinxhyphen{}related grids and operators for a specific AMR grid.
For example, a \sphinxcode{\sphinxupquote{realm}} consists of a set of grids (i.e. a \sphinxcode{\sphinxupquote{Vector\textless{}DisjointBoxLayout\textgreater{}}}) as well as \sphinxstyleemphasis{operators}, e.g. functionality for filling ghost cells or averaging down a solution from a fine level to a coarse level.

The terminology \sphinxstyleemphasis{dual grid} is used when more than one \sphinxcode{\sphinxupquote{realm}} is used in a simulation.
With dual grid the user/developer has chosen to solve the equations of motion over a different set of \sphinxcode{\sphinxupquote{DisjointBoxLayout}} on each level.
This approach is very useful when particle solvers are involved since users can quickly generate an Eulerian set of grids and a set of grids for the Lagrangian particles, and the grids can be load balanced separately.

In general, users will not interact with \sphinxcode{\sphinxupquote{realm}} directly.
Every \sphinxcode{\sphinxupquote{realm}} is owned by \sphinxcode{\sphinxupquote{amr\_mesh}}, and the user will only interact with realms through the public \sphinxcode{\sphinxupquote{amr\_mesh}} interface.

Internally, an instantiation of \sphinxcode{\sphinxupquote{realm}} contains the grids and the geometric information (e.g. EBISLayout), as well as any operators that the user has seen fit to \sphinxstyleemphasis{register}.
If a solver needs an operator for, say, ghost cell interpolation, the solver needs to \sphinxstyleemphasis{register} that operator through the \sphinxcode{\sphinxupquote{amr\_mesh}} public interface.
Operator registration is a run\sphinxhyphen{}time procedure.
Once an operator has been registered, \sphinxcode{\sphinxupquote{realm}} will define those operators during e.g. regrids.
Run\sphinxhyphen{}time abortions with error messages are issued if an AMR operator is called for, but has not been registered.


\section{Understanding mesh data}
\label{\detokenize{MeshData:understanding-mesh-data}}\label{\detokenize{MeshData:chap-meshdata}}\label{\detokenize{MeshData::doc}}
Mesh datastructures in \sphinxcode{\sphinxupquote{PlasmaC}} are derived from a class \sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}}} which holds a typename \sphinxcode{\sphinxupquote{T}} at every box at every level in the AMR hierarchy.
Internally, the data is stored as a \sphinxcode{\sphinxupquote{Vector\textless{}RefCountedPtr\textless{}LevelData\textless{}T\textgreater{} \textgreater{} \textgreater{}}} and the user may fetch the data through \sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}::get\_data()}}.
Here, the \sphinxcode{\sphinxupquote{Vector}} holds a set of data on each AMR level; the data is allocated with a smart pointer called \sphinxcode{\sphinxupquote{RefCountedPtr}} which points to a \sphinxcode{\sphinxupquote{LevelData}} template structure, see {\hyperref[\detokenize{Basics:chap-basics}]{\sphinxcrossref{\DUrole{std,std-ref}{Chombo basics}}}}.

The reason for having class encapsulation of mesh data is due to {\hyperref[\detokenize{Realm:chap-realm}]{\sphinxcrossref{\DUrole{std,std-ref}{Realm}}}}, so that we can only keep track on which realm the mesh data is defined.
Users will not have to interact with \sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}}} directly, but will do so primarily through \sphinxcode{\sphinxupquote{amr\_mesh}}.
\sphinxcode{\sphinxupquote{amr\_mesh}} has functionality for defining most \sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}}} types on one of the realms, and \sphinxcode{\sphinxupquote{EBAMRData\textless{}T\textgreater{}}} itself it typically not used anywhere elsewhere within \sphinxcode{\sphinxupquote{PlasmaC}}.

A number of explicit template specifications also exist, and these are outlined below:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{MFCellFAB}\PYG{o}{\PYGZgt{}}        \PYG{n}{MFAMRCellData}\PYG{p}{;}  \PYG{c+c1}{// Cell\PYGZhy{}centered multifluid data}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{MFFluxFAB}\PYG{o}{\PYGZgt{}}        \PYG{n}{MFAMRFluxData}\PYG{p}{;}  \PYG{c+c1}{// Face\PYGZhy{}centered multifluid data}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{MFBaseIVFAB}\PYG{o}{\PYGZgt{}}      \PYG{n}{MFAMRIVData}\PYG{p}{;}    \PYG{c+c1}{// Irregular face multifluid data}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{EBCellFAB}\PYG{o}{\PYGZgt{}}        \PYG{n}{EBAMRCellData}\PYG{p}{;}  \PYG{c+c1}{// Cell\PYGZhy{}centered single\PYGZhy{}phase data}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{EBFluxFAB}\PYG{o}{\PYGZgt{}}        \PYG{n}{EBAMRFluxData}\PYG{p}{;}  \PYG{c+c1}{// Face\PYGZhy{}centered data in all coordinate direction}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{EBFaceFAB}\PYG{o}{\PYGZgt{}}        \PYG{n}{EBAMRFaceData}\PYG{p}{;}  \PYG{c+c1}{// Face\PYGZhy{}centered in a single coordinate direction}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIVFAB}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{EBAMRIVData}\PYG{p}{;}    \PYG{c+c1}{// Data on irregular data centroids}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{DomainFluxIFFAB}\PYG{o}{\PYGZgt{}}  \PYG{n}{EBAMRIFData}\PYG{p}{;}    \PYG{c+c1}{// Data on domain phases}
\PYG{k}{typedef} \PYG{n}{EBAMRData}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseFab}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}   \PYG{n}{EBAMRBool}\PYG{p}{;}      \PYG{c+c1}{// For holding bool at every cell}
\end{sphinxVerbatim}

There are many more data structures in place, but the above data structures are the most commonly used ones.
Here, \sphinxcode{\sphinxupquote{EBAMRFluxData}} is precisely like \sphinxcode{\sphinxupquote{EBAMRCellData}}, except that the data is stored on \sphinxstyleemphasis{cell faces} rather than cell centers.
Likewise, \sphinxcode{\sphinxupquote{EBAMRIVData}} is a typedef’ed data holder that holds data on each cut\sphinxhyphen{}cell center across the entire AMR hierachy.
In the same way, \sphinxcode{\sphinxupquote{EBAMRIFData}} holds data on each face of all cut cells.


\section{Understanding particle data}
\label{\detokenize{ParticleData:understanding-particle-data}}\label{\detokenize{ParticleData:chap-particledata}}\label{\detokenize{ParticleData::doc}}

\subsection{particle\_container}
\label{\detokenize{ParticleData:particle-container}}
The \sphinxcode{\sphinxupquote{particle\_container\textless{}T\textgreater{}}} is a container class that holds particles on an AMR hierarchy, inclusive of information on how to distribute them to grids and remap them.
Under the hood, it uses the Chombo structure \sphinxcode{\sphinxupquote{ParticleData\textless{}T\textgreater{}}} which holds the particles on each level, and also the mapping structure \sphinxcode{\sphinxupquote{ParticleValidRegion}} which dictates on which patch the particles belong.
To obtain the particles on one AMR level, the user will call something like

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{particle\PYGZus{}container}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{particleContainer}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ParticleData}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{levelParticles} \PYG{o}{=} \PYG{n}{particleContainer}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

The indexing operator \sphinxcode{\sphinxupquote{{[}int{]}}} yields the particles on one level.


\subsection{Allocating particles}
\label{\detokenize{ParticleData:allocating-particles}}
\sphinxcode{\sphinxupquote{amr\_mesh}} has a very simple function for allocating a \sphinxcode{\sphinxupquote{particle\_container}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{k+kt}{void} \PYG{n}{allocate}\PYG{p}{(}\PYG{n}{particle\PYGZus{}container}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}container}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}buffer}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

which will allocate a \sphinxcode{\sphinxupquote{particle\_container}} with a buffer zone on refined grid levels.
This buffer zone adjusts where on the fine levels the particles can live.


\subsection{ParticleData}
\label{\detokenize{ParticleData:particledata}}
On each grid level, particles live in templated data holders

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{o}{\PYGZgt{}}
\PYG{n}{ParticleData}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{T}} is the particle type.
Although \sphinxcode{\sphinxupquote{ParticleData\textless{}T\textgreater{}}} can be thought of as a \sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}}, it actually inherits \sphinxcode{\sphinxupquote{LayoutData\textless{}ListBox\textless{}T\textgreater{} \textgreater{}}}.
However, \sphinxcode{\sphinxupquote{ParticleData\textless{}T\textgreater{}}} still has routines for communicating particles with MPI.

On each patch, the particles are stored in a \sphinxcode{\sphinxupquote{ListBox\textless{}T\textgreater{}}}.
This class essentially consists of the domain box for the patch which holds the particles, and the particles themselves which are stored in a list \sphinxcode{\sphinxupquote{List\textless{}T\textgreater{}}}.
The particles are retrieved from a \sphinxcode{\sphinxupquote{ListBox\textless{}T\textgreater{}}} object with a \sphinxcode{\sphinxupquote{listItems()}} member function.
Here is an example:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Assume PD is our particle data and DBL is our grids}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit} \PYG{o}{=} \PYG{n}{DBL}\PYG{p}{.}\PYG{n}{dataIterator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{ListBox}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{lb} \PYG{o}{=} \PYG{n}{PD}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{particles} \PYG{o}{=} \PYG{n}{lb}\PYG{p}{.}\PYG{n}{listItems}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{c+c1}{// ... do something with the particles}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

There are routines for allocating a particle data holder in \sphinxcode{\sphinxupquote{amr\_mesh}}, which simply looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{typename} \PYG{n}{T} \PYG{o}{\PYGZgt{}}
\PYG{k+kt}{void} \PYG{n}{allocate}\PYG{p}{(}\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{ParticleData}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}particles}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This will simply create the \sphinxcode{\sphinxupquote{ParticleData\textless{}T\textgreater{}}} object on all the AMR levels (without any particles).


\subsection{Iterating over particles}
\label{\detokenize{ParticleData:iterating-over-particles}}
In order to iterate over particles, you will use an iterator without random access:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Assume PD is our particle data and DBL is our grids}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit} \PYG{o}{=} \PYG{n}{DBL}\PYG{p}{.}\PYG{n}{dataIterator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{ListBox}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{lb} \PYG{o}{=} \PYG{n}{PD}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}
   \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{particles} \PYG{o}{=} \PYG{n}{lb}\PYG{p}{.}\PYG{n}{listItems}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{ListIterator}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{lit}\PYG{p}{(}\PYG{n}{particles}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{for} \PYG{p}{(}\PYG{n}{lit}\PYG{p}{.}\PYG{n}{rewind}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{lit}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{lit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{T}\PYG{o}{\PYGZam{}} \PYG{n}{p} \PYG{o}{=} \PYG{n}{particles}\PYG{p}{[}\PYG{n}{lit}\PYG{p}{]}\PYG{p}{;}

      \PYG{c+c1}{// ... do something with this particle}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{ParticleValidRegion}
\label{\detokenize{ParticleData:particlevalidregion}}
The \sphinxcode{\sphinxupquote{ParticleValidRegion}} (PVR) allows particles to be transferred to coarser grid levels if they are within a specified number of grid cells from the refinement boundary.
A compelling reason to do this is that if the particle lives on the refinement boundary, its deposition cloud will hang over the refinement boundary and into the ghost cells.
So, it is useful to keep the particles on the grid in such a way that the deposition and interpolation kernels are entirel contained within the grid.
Another reason is that it might be useful to keep the deposition kernel on a specific AMR level for a number of time steps to reduce the number of times the particles must be moved across AMR levels.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=480\sphinxpxdimen]{{pvr}.png}
\caption{The ParticleValidRegion allows particles whose position fall into a fine grid patch to be moved to a coarser level if they are within a specified distance from the refinement boundary. In this case, the green particles that overlap with the fine\sphinxhyphen{}level grid are placed in a \sphinxcode{\sphinxupquote{ParticleData\textless{}T\textgreater{}}} holder on the coarse grid level.}\label{\detokenize{ParticleData:id1}}\end{figure}

To allocate a PVR,
Allocation of a PVR is done from \sphinxcode{\sphinxupquote{amr\_mesh}} (alternatively, call the constructor yourself) as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{allocate}\PYG{p}{(}\PYG{n}{EBAMRPVR}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}pvr}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}buffer}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// buffer is the number of cells from the refinement boundary}
\end{sphinxVerbatim}

Here, \sphinxcode{\sphinxupquote{EBAMRPVR}} is simply a typedef’ed \sphinxcode{\sphinxupquote{Vector\textless{}RefCountedPtr\textless{}ParticleValidRegion\textgreater{} \textgreater{}}}.


\subsection{Remapping particles}
\label{\detokenize{ParticleData:remapping-particles}}
Particle remapping to the correct MPI ranks must be done if a particle leaves a grid patch and enters a different one, or leaves over a refinement boundary.
The figure below shows some typical cases.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=480\sphinxpxdimen]{{outcast}.png}
\caption{Three cases of particle remapping. Here, the green particle stays on the fine level but needs to change MPI ownership.
The red particle moves from the coarse level and to the fine level and needs to change both ownership and will also be deposited on the fine AMR level.
The blue particle has moved to a different patch on the fine level but falls outside the fine level PVR must therefore be transferred to the coarse level.}\label{\detokenize{ParticleData:id2}}\end{figure}

\sphinxcode{\sphinxupquote{particle\_container}} has a function that will remap particles over the \sphinxstyleemphasis{whole} AMR hierarchy, including all three cases outlined above.
In addition, the class has one particle for remapping only one one level;

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{void} \PYG{n}{remap}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}                       \PYG{o}{/}\PYG{o}{/} \PYG{n}{Remap} \PYG{n}{everything}
\PYG{n}{void} \PYG{n}{levelRemap}\PYG{p}{(}\PYG{n}{const} \PYG{n+nb}{int} \PYG{n}{a\PYGZus{}level}\PYG{p}{)}\PYG{p}{;} \PYG{o}{/}\PYG{o}{/} \PYG{n}{Remap} \PYG{n}{only} \PYG{n}{one} \PYG{n}{level}
\end{sphinxVerbatim}


\subsubsection{Outcasts}
\label{\detokenize{ParticleData:outcasts}}
After particles have moved, \sphinxcode{\sphinxupquote{ParticleData\textless{}T\textgreater{}}} has a method for locally gathering particles that are no longer in the correct grid patch, and another method for distributing the particles to the correct grids.
This is done as follows

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Assume PD is a ParticleData\PYGZlt{}T\PYGZgt{} object}
\PYG{n}{PD}\PYG{p}{.}\PYG{n}{gatherOutcast}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{PD}\PYG{p}{.}\PYG{n}{remapOutcast}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We remark that this concerns remapping on one single level.
This means that:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Some particles may remain in the outcast list

\item {} 
The remapping does not respect the PVR on each level.

\end{enumerate}

This is the actual calls in \sphinxcode{\sphinxupquote{levelRemap(const int a\_level)}}.


\section{Controlling \sphinxstyleliteralintitle{\sphinxupquote{PlasmaC}}}
\label{\detokenize{Control:controlling-plasmac}}\label{\detokenize{Control:chap-control}}\label{\detokenize{Control::doc}}
In this chapter we show how to run a \sphinxcode{\sphinxupquote{PlasmaC}} simulation and control its behavior through input scripts or command line options.


\subsection{Basic compiling and running}
\label{\detokenize{Control:basic-compiling-and-running}}
To run simulations, the user must first compile his application. Once the application has been defined, the user may compile is by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
make \PYGZhy{}s \PYGZhy{}j \PYG{l+m}{32} \PYG{n+nv}{DIM}\PYG{o}{=}N \PYGZlt{}application\PYGZus{}name\PYGZgt{}
\end{sphinxVerbatim}

where \sphinxstyleemphasis{N} may be 2 or 3, and \textless{}application\_name\textgreater{} is the name of the file that holds the \sphinxcode{\sphinxupquote{main()}} function. This will compile an executable whose name depends on your application name and compiler settings. Please refer to the Chombo manual for explanation of the executable name. You may, of course, rename your application.

Next, applications are run by

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
mpirun \PYGZhy{}np \PYG{l+m}{32} \PYGZlt{}application\PYGZus{}executable\PYGZgt{} \PYGZlt{}input\PYGZus{}file\PYGZgt{}
\end{sphinxVerbatim}

where \textless{}input\_file\textgreater{} is your input file. On clusters, this is a little bit different and usually requires passing the above command through a batch system. Note that if you define a parameter multiple times in the input file, the last definition is canon.

You may also pass input parameters through the command line. For example, running

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
mpirun \PYGZhy{}np \PYG{l+m}{32} \PYGZlt{}application\PYGZus{}executable\PYGZgt{} \PYGZlt{}input\PYGZus{}file\PYGZgt{} driver.max\PYGZus{}steps\PYG{o}{=}\PYG{l+m}{10}
\end{sphinxVerbatim}

will set the \sphinxcode{\sphinxupquote{driver.max\_steps}} parameter to 10. Command\sphinxhyphen{}line parameters override definitions in the input\_file.


\subsection{Controlling output}
\label{\detokenize{Control:controlling-output}}\label{\detokenize{Control:chap-controllingoutput}}
\sphinxtitleref{PlasmaC} comes with controls for adjusting output. Through the {\hyperref[\detokenize{Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{driver}}}} class the user may adjust the option \sphinxcode{\sphinxupquote{driver.output\_directory}} to specify where output files will be placed. This directory is relative to the location where the application is run. If this directory does not exist, PlasmaC does it’s best at creating it. In addition, it will create four more directories
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{output\_directory/plt}} contains all plot files.

\item {} 
\sphinxcode{\sphinxupquote{output\_directory/chk}} contains all checkpoint files, which are used for restarting.

\item {} 
\sphinxcode{\sphinxupquote{output\_directory/mpi}} contains information about individual MPI ranks.

\item {} 
\sphinxcode{\sphinxupquote{output\_directory/geo}} contains geometric files that are written by PlasmaC (if you enable \sphinxcode{\sphinxupquote{driver.write\_ebis}}).

\end{itemize}

The files in \sphinxcode{\sphinxupquote{output\_directory/geo}} do \sphinxstyleemphasis{not} represent your geometry in the form of level sets. Instead, the files that are placed here are HDF5 representations of your embedded boundary graph, which can be \sphinxstyleemphasis{read} by PlasmaC if you enable \sphinxcode{\sphinxupquote{driver.read\_ebis}}. This is a shortcut that allows faster geometry generation when you restart simulations, but geometry generation is typically so fast that it is never used.

The reason for this structure is that PlasmaC can end up writing thousands of files per simulation and we feel that having a directory structure helps us navigate simulation data.

The driver class {\hyperref[\detokenize{Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{driver}}}} is responsible for writing output files at specified intervals, but the user is responsible for specifying what goes into those files. Since not all variables are always of interest, the solver classes themselves have options \sphinxcode{\sphinxupquote{plt\_vars}} that specify which output variables will be written to the output file. For example, our convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solver classes have the following output options:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
cdr\PYGZus{}gdnv.plt\PYGZus{}vars \PYG{o}{=} phi vel dco src ebflux \PYG{c+c1}{\PYGZsh{} Plot variables. Options are \PYGZsq{}phi\PYGZsq{}, \PYGZsq{}vel\PYGZsq{}, \PYGZsq{}dco\PYGZsq{}, \PYGZsq{}src\PYGZsq{}, \PYGZsq{}ebflux\PYGZsq{}}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{phi}} is the state density, \sphinxcode{\sphinxupquote{vel}} is the drift velocity, \sphinxcode{\sphinxupquote{dco}} is the diffusion coefficient, \sphinxcode{\sphinxupquote{src}} is the source term, and \sphinxcode{\sphinxupquote{ebflux}} is the flux at embedded boundaries. Which variables are available for output changes for one class to the next. If you only want to plot the density, then you should put \sphinxcode{\sphinxupquote{cdr\_gdnv.plt\_vars = phi}}. An empty entry like \sphinxcode{\sphinxupquote{cdr\_gdnv.plt\_vars =}} will lead to run\sphinxhyphen{}time errors, so if you do not want a class to provide plot data you may put \sphinxcode{\sphinxupquote{cdr\_gdnv.plt\_vars = \sphinxhyphen{}1}}.


\subsection{Controlling processor output}
\label{\detokenize{Control:controlling-processor-output}}
By default, Chombo will write a process output file \sphinxstyleemphasis{per MPI process} and this file will be named \sphinxcode{\sphinxupquote{pout.n}} where \sphinxcode{\sphinxupquote{n}} is the MPI rank. These files are written in the directory where you executed your application, and are \sphinxstyleemphasis{not} related to plot files or checkpoint files. However, PlasmaC prints information to these files as simulations advance (for example by displaying information of the current time step, or convergence rates for multigrid solvers). While it is possible to monitor the evolution of PlasmaC through each MPI, most of these files contain redundant information. To turn off the number of files that will be written, Chombo can read an environment variable \sphinxcode{\sphinxupquote{CH\_OUTPUT\_INTERVAL}}. For example, if you only want the master MPI rank to write \sphinxcode{\sphinxupquote{pout.0}}, you would do

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n+nb}{export} \PYG{n+nv}{CH\PYGZus{}OUTPUT\PYGZus{}INTERVAL}\PYG{o}{=}\PYG{l+m}{999999999}
\end{sphinxVerbatim}

You can, of course, put the definition in your \sphinxcode{\sphinxupquote{.bashrc}} file (for Bourne shell). Note that if you run simulations at high concurrencies, you \sphinxstyleemphasis{should} turn off the number of process output files since they impact the performance of the file system.


\subsection{Restarting simulations}
\label{\detokenize{Control:restarting-simulations}}\label{\detokenize{Control:chap-restartingsimulations}}
Restarting simulations is done in exactly the same way as running simulations, although the user must set the \sphinxcode{\sphinxupquote{driver.restart}} parameter. For example,

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
mpirun \PYGZhy{}np \PYG{l+m}{32} \PYGZlt{}application\PYGZus{}executable\PYGZgt{} \PYGZlt{}input\PYGZus{}file\PYGZgt{} driver.restart\PYG{o}{=}\PYG{l+m}{10}
\end{sphinxVerbatim}

will restart from step 10. If you set \sphinxcode{\sphinxupquote{driver.restart=0}}, you will get a fresh simulation. Specifying anything but an integer is an error. When a simulation is restarted, PlasmaC will look for a checkpoint file with the \sphinxcode{\sphinxupquote{driver.output\_names}} variable and the specified restart step. If this file is not found, restarting will not work and \sphinxcode{\sphinxupquote{PlasmaC}} will abort. You must therefore ensure that your executable can locate this file. This also implies that you cannot change the \sphinxcode{\sphinxupquote{driver.output\_names}} or \sphinxcode{\sphinxupquote{driver.output\_directory}} variables during restarts, unless you also change the name of your checkpoint file and move it to a new directory.


\subsection{Visualization}
\label{\detokenize{Control:visualization}}
\sphinxtitleref{PlasmaC} output files are written to HDF5 files in the format \sphinxcode{\sphinxupquote{\textless{}simulation\_name\textgreater{}.step\#.dimension.hdf5}} and the files will be written to the directory specified by {\hyperref[\detokenize{Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{driver}}}} runtime parameters. Currently, we have only used VisIt for visualizing the plot files.


\section{Visualization}
\label{\detokenize{Visualization:visualization}}\label{\detokenize{Visualization:chap-visualization}}\label{\detokenize{Visualization::doc}}
\sphinxtitleref{PlasmaC} output files are written to HDF5 files in the format \sphinxcode{\sphinxupquote{\textless{}simulation\_name\textgreater{}.step\#.dimension.hdf5}} and the files will be written to the directory specified by {\hyperref[\detokenize{Driver:chap-driver}]{\sphinxcrossref{\DUrole{std,std-ref}{driver}}}} runtime parameters. Currently, we have only used VisIt for visualizing the plot files.


\chapter{PlasmaC design}
\label{\detokenize{index:plasmac-design}}

\section{driver}
\label{\detokenize{Driver:driver}}\label{\detokenize{Driver:chap-driver}}\label{\detokenize{Driver::doc}}
The \sphinxcode{\sphinxupquote{driver}} class is the class that runs \sphinxtitleref{PlasmaC} simulations and is defined in \sphinxcode{\sphinxupquote{/src/driver/driver.cpp(H)}}.
The constructor for this class is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{driver}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{computational\PYGZus{}geometry}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}compgeom}\PYG{p}{,}
       \PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{time\PYGZus{}stepper}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}           \PYG{n}{a\PYGZus{}timestepper}\PYG{p}{,}
       \PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}               \PYG{n}{a\PYGZus{}amr}\PYG{p}{,}
       \PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{cell\PYGZus{}tagger}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}            \PYG{n}{a\PYGZus{}celltagger} \PYG{o}{=} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{cell\PYGZus{}tagger}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{,}
       \PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{geo\PYGZus{}coarsener}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}          \PYG{n}{a\PYGZus{}geocoarsen} \PYG{o}{=} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{geo\PYGZus{}coarsener}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Observe that the \sphinxcode{\sphinxupquote{driver}} class does not \sphinxstyleemphasis{require} an instance of {\hyperref[\detokenize{CellTagger:chap-cell-tagger}]{\sphinxcrossref{\DUrole{std,std-ref}{cell\_tagger}}}}.
If users decide to omit a cell tagger, regridding functionality is completely turned off and only the initially generated grids will be used.

The usage of the \sphinxcode{\sphinxupquote{driver}} class is primarily object construction with dependency injection of the geometry, the physics (i.e. \sphinxcode{\sphinxupquote{time\_stepper}}), the \sphinxcode{\sphinxupquote{amr\_mesh}} instance, and possibly a cell tagger.
The driver class will automatically retrieve run\sphinxhyphen{}time options from the input script during object creation.
Usually, only a single routine is used:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{setup\PYGZus{}and\PYGZus{}run}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

This routine will set up and run a simulation.
Simulation setup depends on the way a simulation is run.


\subsection{How fresh simulations are set up}
\label{\detokenize{Driver:how-fresh-simulations-are-set-up}}
If a simulation starts from the first time step, the \sphinxcode{\sphinxupquote{driver}} class will perform the following major steps within \sphinxcode{\sphinxupquote{setup\_and\_run()}}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Ask \sphinxcode{\sphinxupquote{computational\_geometry}} to generate the cut\sphinxhyphen{}cell moments.

\item {} 
Collect all the cut\sphinxhyphen{}cells and ask \sphinxcode{\sphinxupquote{amr\_mesh}} to set up an initial grid where all the cut\sphinxhyphen{}cells are refined.
It is possible to restrict the maximum level that can be generated from the geometric tags, or remove some of the cut\sphinxhyphen{}cell refinement flags through the auxiliary class \sphinxcode{\sphinxupquote{geo\_coarsener}}.

\item {} 
Ask the \sphinxcode{\sphinxupquote{time\_stepper}} to set up all the relevant solvers and fill them with initial data.

\item {} 
Perform the number of initial regrids that the user asks for.

\end{enumerate}

Step 3 will differ significantly depending on the physics that is solved for.


\subsection{How simulations are restarted}
\label{\detokenize{Driver:how-simulations-are-restarted}}
If a simulation \sphinxstyleemphasis{does not start} from the first time step, the \sphinxcode{\sphinxupquote{driver}} class will perform the following major steps within \sphinxcode{\sphinxupquote{setup\_and\_run()}}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Ask \sphinxcode{\sphinxupquote{computational\_geometry}} to generate the cut\sphinxhyphen{}cell moments.

\item {} 
Read a checkpoint file that contains the grids and all the data that have been checkpointed by the solvers.

\item {} 
Ask the \sphinxcode{\sphinxupquote{time\_stepper}} to perform a “post\sphinxhyphen{}checkpoint” step to initialize any remaining data so that a time step can be taken.
This functionality has been included because not all data in every solver needs to be checkpointed.
For example, an electric field solver only needs to write the electric potential to the checkpoint file because the electric field is simply obtained by taking the gradient.

\item {} 
Perform the number of initial regrids that the user asks for.

\end{enumerate}

Again, step 3 will differ significantly depending on the physics that is solved for.


\subsection{How simulations are run}
\label{\detokenize{Driver:how-simulations-are-run}}
The algorithm for running a simulation is very simple; the \sphinxcode{\sphinxupquote{driver}} class simply calls \sphinxcode{\sphinxupquote{time\_stepper}} for computing a reasonable time step for advancing the equations, and then it asks \sphinxcode{\sphinxupquote{time\_stepper}} to actually perform the advance.
Regrids, plot files, and checkpoint files are written at certain step intervals.
In essence, the algorithm looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{driver}\PYG{o}{:}\PYG{o}{:}\PYG{n}{run}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{\PYGZob{}}

   \PYG{k}{while}\PYG{p}{(}\PYG{n}{KeepRunningTheSimulation}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{RegridEverything}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{driver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{regrid}\PYG{p}{(}\PYG{p}{)}
      \PYG{p}{\PYGZcb{}}

      \PYG{n}{time\PYGZus{}stepper}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{computeTimeStep}\PYG{p}{(}\PYG{p}{)}
      \PYG{n}{time\PYGZus{}stepper}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{advanceAllEquationsOneStep}\PYG{p}{(}\PYG{p}{)}

      \PYG{k}{if}\PYG{p}{(}\PYG{n}{WriteAPlotFile} \PYG{o}{|}\PYG{o}{|} \PYG{n}{EndOfSimulatoin}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{driver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{writePlotFile}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
      \PYG{k}{if}\PYG{p}{(}\PYG{n}{TimeToWriteACheckpointFile} \PYG{o}{|}\PYG{o}{|} \PYG{n}{EndOfSimulation}\PYG{p}{)}\PYG{p}{\PYGZob{}}
         \PYG{n}{driver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{writeCheckpointFile}\PYG{p}{(}\PYG{p}{)}
      \PYG{p}{\PYGZcb{}}

      \PYG{n}{KeepRunningTheSimulation} \PYG{o}{=} \PYG{n+nb}{true} \PYG{n}{or} \PYG{n+nb}{false}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

None of the current physics modules use subcycling in time, but this \sphinxstyleemphasis{is} possible by having an implementation class of \sphinxcode{\sphinxupquote{time\_stepper}} that subcycles.
The biggest caveat is that the recursive type of regridding that is performed by subcycled algorithms is not yet supported.
It is possible to modify \sphinxcode{\sphinxupquote{driver}} such that this is supported, but this has not been a priority.


\subsection{How regrids are performed}
\label{\detokenize{Driver:how-regrids-are-performed}}
Regrids are called by the \sphinxcode{\sphinxupquote{driver}} class and occur as follows in \sphinxcode{\sphinxupquote{driver::regrid(...)}}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Ask \sphinxcode{\sphinxupquote{cell\_tagger}} to generate tags for grid refinement and coarsening.

\item {} 
The \sphinxcode{\sphinxupquote{time\_stepper}} class stores data that is subject to regrids.
How this happens depends on the solver that is run.
For grid\sphinxhyphen{}based solvers, e.g. CDR solvers, the scalar \(\phi\) is copied into a scratch space.
The reason for this backup is that during the regrid \(\phi\) will be allocated on the \sphinxstyleemphasis{new} AMR grids, but we must still have access to the previously defined data in order to interpolate to the new grids.

\item {} 
If necessary, \sphinxcode{\sphinxupquote{time\_stepper}} can deallocate unecessary storage.
Implementing a deallocation function for \sphinxcode{\sphinxupquote{time\_stepper}}\sphinxhyphen{}derived classes is not a requirement, but can in certain cases be useful, for example when using the Berger\sphinxhyphen{}Rigoutsous algorithm at large scale.

\item {} 
The \sphinxcode{\sphinxupquote{amr\_mesh}} class generates the new grids and defines new AMR operators.

\item {} 
The \sphinxcode{\sphinxupquote{time\_stepper}} class regrids its solvers and internal data.

\end{enumerate}

In C++ pseudo\sphinxhyphen{}code, this looks something like:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{driver}\PYG{o}{:}\PYG{o}{:}\PYG{n}{regrid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}

   \PYG{c+c1}{// Tag cells}
   \PYG{n}{cell\PYGZus{}tagger}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{tagCellsForRefinement}\PYG{p}{(}\PYG{p}{)}

   \PYG{c+c1}{// Store old data and free up some memory}
   \PYG{n}{time\PYGZus{}stepper}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{storeOldGridData}\PYG{p}{(}\PYG{p}{)}
   \PYG{n}{time\PYGZus{}stepper}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{deallocateUnneccesaryData}\PYG{p}{(}\PYG{p}{)}

   \PYG{c+c1}{// Generate the new grids}
   \PYG{n}{amr\PYGZus{}mesh}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{regrid}\PYG{p}{(}\PYG{p}{)}

   \PYG{c+c1}{// Regrid physics and all solvers}
   \PYG{n}{time\PYGZus{}stepper}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{regrid}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

The full code is defined in \sphinxcode{\sphinxupquote{driver::regrid()}} in file \sphinxcode{\sphinxupquote{/src/driver/driver.cpp}}.


\subsection{Class options}
\label{\detokenize{Driver:class-options}}
Various class options are available for adjusting the behavior of the \sphinxcode{\sphinxupquote{driver}} class.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{\PYGZsh{} ====================================================================================================}
\PYG{c+c1}{\PYGZsh{} DRIVER OPTIONS}
\PYG{c+c1}{\PYGZsh{} ====================================================================================================}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{verbosity}                       \PYG{o}{=} \PYG{l+m+mi}{2}             \PYG{c+c1}{\PYGZsh{} Engine verbosity}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{geometry\PYGZus{}generation}             \PYG{o}{=} \PYG{n}{plasmac}       \PYG{c+c1}{\PYGZsh{} Grid generation method, \PYGZsq{}plasmac\PYGZsq{} or \PYGZsq{}chombo\PYGZsq{}}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{geometry\PYGZus{}scan\PYGZus{}level}             \PYG{o}{=} \PYG{l+m+mi}{0}             \PYG{c+c1}{\PYGZsh{} Geometry scan level for plasmac geometry generator}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{recursive\PYGZus{}regrid}                \PYG{o}{=} \PYG{n}{false}         \PYG{c+c1}{\PYGZsh{} Recursive regrids}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{plot\PYGZus{}interval}                   \PYG{o}{=} \PYG{l+m+mi}{10}            \PYG{c+c1}{\PYGZsh{} Plot interval}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{regrid\PYGZus{}interval}                 \PYG{o}{=} \PYG{l+m+mi}{10}            \PYG{c+c1}{\PYGZsh{} Regrid interval}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{checkpoint\PYGZus{}interval}             \PYG{o}{=} \PYG{l+m+mi}{10}            \PYG{c+c1}{\PYGZsh{} Checkpoint interval}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{initial\PYGZus{}regrids}                 \PYG{o}{=} \PYG{l+m+mi}{0}             \PYG{c+c1}{\PYGZsh{} Number of initial regrids}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{start\PYGZus{}time}                      \PYG{o}{=} \PYG{l+m+mi}{0}             \PYG{c+c1}{\PYGZsh{} Start time (fresh simulations only)}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{stop\PYGZus{}time}                       \PYG{o}{=} \PYG{l+m+mf}{1.0}           \PYG{c+c1}{\PYGZsh{} Stop time}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{max\PYGZus{}steps}                       \PYG{o}{=} \PYG{l+m+mi}{100}           \PYG{c+c1}{\PYGZsh{} Maximum number of steps}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{geometry\PYGZus{}only}                   \PYG{o}{=} \PYG{n}{false}         \PYG{c+c1}{\PYGZsh{} Special option that ONLY plots the geometry}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{ebis\PYGZus{}memory\PYGZus{}load\PYGZus{}balance}        \PYG{o}{=} \PYG{n}{false}         \PYG{c+c1}{\PYGZsh{} Use memory as loads for EBIS generation}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{write\PYGZus{}memory}                    \PYG{o}{=} \PYG{n}{false}         \PYG{c+c1}{\PYGZsh{} Write MPI memory report }
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{write\PYGZus{}ebis}                      \PYG{o}{=} \PYG{n}{false}         \PYG{c+c1}{\PYGZsh{} Write geometry to an HDF5 file}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{read\PYGZus{}ebis}                       \PYG{o}{=} \PYG{n}{false}         \PYG{c+c1}{\PYGZsh{} Read EBIS when restarting a simulation}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{output\PYGZus{}directory}                \PYG{o}{=} \PYG{o}{.}\PYG{o}{/}            \PYG{c+c1}{\PYGZsh{} Output directory}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{grow\PYGZus{}tags}                       \PYG{o}{=} \PYG{l+m+mi}{0}             \PYG{c+c1}{\PYGZsh{} Grow tagged by this in every direction}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{output\PYGZus{}names}                    \PYG{o}{=} \PYG{n}{simulation}    \PYG{c+c1}{\PYGZsh{} Simulation output names}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{max\PYGZus{}plot\PYGZus{}depth}                  \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}            \PYG{c+c1}{\PYGZsh{} Restrict maximum plot depth (\PYGZhy{}1 =\PYGZgt{} finest simulation level)}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{max\PYGZus{}chk\PYGZus{}depth}                   \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}            \PYG{c+c1}{\PYGZsh{} Restrict chechkpoint depth (\PYGZhy{}1 =\PYGZgt{} finest simulation level)	}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{num\PYGZus{}plot\PYGZus{}ghost}                  \PYG{o}{=} \PYG{l+m+mi}{1}             \PYG{c+c1}{\PYGZsh{} Number of ghost cells to include in plots}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{plt\PYGZus{}vars}                        \PYG{o}{=} \PYG{l+m+mi}{0}             \PYG{c+c1}{\PYGZsh{} \PYGZsq{}tags\PYGZsq{}, \PYGZsq{}mpi\PYGZus{}rank\PYGZsq{}}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{restart}                         \PYG{o}{=} \PYG{l+m+mi}{0}             \PYG{c+c1}{\PYGZsh{} Restart step (less or equal to 0 implies fresh simulation)}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{allow\PYGZus{}coarsening}                \PYG{o}{=} \PYG{n}{true}          \PYG{c+c1}{\PYGZsh{} Allows removal of grid levels according to cell\PYGZus{}tagger}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{refine\PYGZus{}geometry}                 \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}            \PYG{c+c1}{\PYGZsh{} Refine geometry, \PYGZhy{}1 =\PYGZgt{} Refine all the way down}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{refine\PYGZus{}electrodes}               \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}            \PYG{c+c1}{\PYGZsh{} Refine electrode surfaces. \PYGZhy{}1 =\PYGZgt{} equal to refine\PYGZus{}geometry}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{refine\PYGZus{}dielectrics}              \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}            \PYG{c+c1}{\PYGZsh{} Refine dielectric surfaces. \PYGZhy{}1 =\PYGZgt{} equal to refine\PYGZus{}geometry}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{refine\PYGZus{}electrode\PYGZus{}gas\PYGZus{}interface}  \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}            \PYG{c+c1}{\PYGZsh{} Refine electrode\PYGZhy{}gas interfaces. \PYGZhy{}1 =\PYGZgt{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZdq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{refine\PYGZus{}dielectric\PYGZus{}gas\PYGZus{}interface} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}            \PYG{c+c1}{\PYGZsh{} Refine dielectric\PYGZhy{}gas interfaces. \PYGZhy{}1 =\PYGZgt{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZdq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{refine\PYGZus{}solid\PYGZus{}gas\PYGZus{}interface}      \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}            \PYG{c+c1}{\PYGZsh{} Refine solid\PYGZhy{}gas interfaces. \PYGZhy{}1 =\PYGZgt{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZdq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{driver}\PYG{o}{.}\PYG{n}{refine\PYGZus{}solid\PYGZus{}solid\PYGZus{}interface}    \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}            \PYG{c+c1}{\PYGZsh{} Refine solid\PYGZhy{}solid interfaces. \PYGZhy{}1 =\PYGZgt{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZdq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\end{sphinxVerbatim}


\section{amr\_mesh}
\label{\detokenize{AmrMesh:amr-mesh}}\label{\detokenize{AmrMesh:chap-amr-mesh}}\label{\detokenize{AmrMesh::doc}}
{\hyperref[\detokenize{AmrMesh:chap-amr-mesh}]{\sphinxcrossref{\DUrole{std,std-ref}{amr\_mesh}}}} handles (almost) all spatial operations in \sphinxtitleref{PlasmaC}.
Internally, {\hyperref[\detokenize{AmrMesh:chap-amr-mesh}]{\sphinxcrossref{\DUrole{std,std-ref}{amr\_mesh}}}} contains a bunch of operators that are useful across classes, such as ghost cell interpolation operators, coarsening operators, and stencils for interpolation and extrapolation near the embedded boundaries. {\hyperref[\detokenize{AmrMesh:chap-amr-mesh}]{\sphinxcrossref{\DUrole{std,std-ref}{amr\_mesh}}}} also contains routines for generation and load\sphinxhyphen{}balancing of grids based and also contains simple routines for allocation and deallocation of memory.

{\hyperref[\detokenize{AmrMesh:chap-amr-mesh}]{\sphinxcrossref{\DUrole{std,std-ref}{amr\_mesh}}}} is an integral part of \sphinxtitleref{PlasmaC}, and users will never have the need to modify it unless they are implementing something entirely new. The behavior of {\hyperref[\detokenize{AmrMesh:chap-amr-mesh}]{\sphinxcrossref{\DUrole{std,std-ref}{amr\_mesh}}}} is modified through it’s available input parameters, listed below:


\subsection{Main functionality}
\label{\detokenize{AmrMesh:main-functionality}}
There are two main functionalities in \sphinxcode{\sphinxupquote{amr\_mesh}}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Building grid hierarchies, and providing geometric information

\item {} 
Providing AMR operators.

\end{enumerate}

In practice, users will not interact directly with this functionality, it is called by \sphinxcode{\sphinxupquote{driver}} at the appropriate stages of regrids.

The AMR operators are, for example, coarsening operators, interpolation operators, ghost cell interpolators etc.
To save some regrid time, we don’t always build every AMR operator that we might ever need, but have solvers \sphinxstyleemphasis{register} the ones that they specifically need.


\subsection{Registering operators}
\label{\detokenize{AmrMesh:registering-operators}}
To register an operator, one must call a public member function of \sphinxcode{\sphinxupquote{amr\_mesh}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{register\PYGZus{}operator}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}operator}\PYG{p}{,} \PYG{k}{const} \PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}phase} \PYG{n}{a\PYGZus{}phase}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the string identifier is the name of the operator and \sphinxcode{\sphinxupquote{a\_phase}} is the phase on which the operator will live.
Currently, the following operators are supported:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxstyleemphasis{eb\_gradient} for allocating stencils for computing the cell\sphinxhyphen{}centered gradient.

\item {} 
\sphinxstyleemphasis{eb\_irreg\_interp} for allocating interpolation stencils in irregular cells, e.g. interpolation to centroids or boundary centroids.

\item {} 
\sphinxstyleemphasis{eb\_coar\_ave} for conservative coarsening of data.

\item {} 
\sphinxstyleemphasis{eb\_quad\_cfi} for quadratic filling of ghost cells.

\item {} 
\sphinxstyleemphasis{eb\_fill\_patch} for linear interpolation of ghost cells.

\item {} 
\sphinxstyleemphasis{eb\_pwl\_interp} for piecewise linear interpolation during e.g. regrids.

\item {} 
\sphinxstyleemphasis{eb\_flux\_reg} for holding fluxes on refinement boundaries.

\item {} 
\sphinxstyleemphasis{eb\_redist} for holding redistribution objects (for e.g. particle deposition or divergence computatoins).

\item {} 
\sphinxstyleemphasis{eb\_copier} for adding the contents in ghost cells to the valid region on the same AMR level.

\item {} 
\sphinxstyleemphasis{eb\_ghostcloud} for adding the contents in ghost cells on the refinement boundary to the coarser AMR level.

\item {} 
\sphinxstyleemphasis{eb\_non\_cons\_div} for computing stencils for doing the non\sphinxhyphen{}conservative divergence.

\end{enumerate}


\subsection{Class options}
\label{\detokenize{AmrMesh:class-options}}
\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{\PYGZsh{} ====================================================================================================}
\PYG{c+c1}{\PYGZsh{} AMR\PYGZus{}MESH OPTIONS}
\PYG{c+c1}{\PYGZsh{} ====================================================================================================}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{lo\PYGZus{}corner}       \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}    \PYG{c+c1}{\PYGZsh{} Low corner of problem domain}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{hi\PYGZus{}corner}       \PYG{o}{=}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}  \PYG{l+m+mi}{1}    \PYG{c+c1}{\PYGZsh{} High corner of problem domain}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{verbosity}       \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}          \PYG{c+c1}{\PYGZsh{} Controls verbosity. }
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{coarsest\PYGZus{}domain} \PYG{o}{=} \PYG{l+m+mi}{128} \PYG{l+m+mi}{128} \PYG{l+m+mi}{128} \PYG{c+c1}{\PYGZsh{} Number of cells on coarsest domain}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{max\PYGZus{}amr\PYGZus{}depth}   \PYG{o}{=} \PYG{l+m+mi}{0}           \PYG{c+c1}{\PYGZsh{} Maximum amr depth}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{max\PYGZus{}sim\PYGZus{}depth}   \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}          \PYG{c+c1}{\PYGZsh{} Maximum simulation depth}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{refine\PYGZus{}all\PYGZus{}lvl}  \PYG{o}{=} \PYG{l+m+mi}{0}           \PYG{c+c1}{\PYGZsh{} Refine everything down to this level.}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{fill\PYGZus{}ratio}      \PYG{o}{=} \PYG{l+m+mf}{1.0}         \PYG{c+c1}{\PYGZsh{} Fill ratio for grid generation}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{irreg\PYGZus{}growth}    \PYG{o}{=} \PYG{l+m+mi}{2}           \PYG{c+c1}{\PYGZsh{} How much to grow irregular tagged cells}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{buffer\PYGZus{}size}     \PYG{o}{=} \PYG{l+m+mi}{2}           \PYG{c+c1}{\PYGZsh{} Number of cells between grid levels}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{grid\PYGZus{}algorithm}  \PYG{o}{=} \PYG{n}{br}          \PYG{c+c1}{\PYGZsh{} Berger\PYGZhy{}Rigoustous \PYGZsq{}br\PYGZsq{} or \PYGZsq{}tiled\PYGZsq{} for the tiled algorithm}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{blocking\PYGZus{}factor} \PYG{o}{=} \PYG{l+m+mi}{16}          \PYG{c+c1}{\PYGZsh{} Default blocking factor (16 in 3D)}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{max\PYGZus{}box\PYGZus{}size}    \PYG{o}{=} \PYG{l+m+mi}{16}          \PYG{c+c1}{\PYGZsh{} Maximum allowed box size}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{max\PYGZus{}ebis\PYGZus{}box}    \PYG{o}{=} \PYG{l+m+mi}{16}          \PYG{c+c1}{\PYGZsh{} Maximum allowed box size}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{ref\PYGZus{}rat}         \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{c+c1}{\PYGZsh{} Refinement ratios}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{num\PYGZus{}ghost}       \PYG{o}{=} \PYG{l+m+mi}{3}           \PYG{c+c1}{\PYGZsh{} Number of ghost cells. Default is 3}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{eb\PYGZus{}ghost}        \PYG{o}{=} \PYG{l+m+mi}{4}           \PYG{c+c1}{\PYGZsh{} Set number of of ghost cells for EB stuff}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{centroid\PYGZus{}sten}   \PYG{o}{=} \PYG{n}{linear}      \PYG{c+c1}{\PYGZsh{} Centroid interp stencils. \PYGZsq{}pwl\PYGZsq{}, \PYGZsq{}linear\PYGZsq{}, \PYGZsq{}taylor, \PYGZsq{}lsq\PYGZsq{}}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{eb\PYGZus{}sten}         \PYG{o}{=} \PYG{n}{pwl}         \PYG{c+c1}{\PYGZsh{} EB interp stencils. \PYGZsq{}pwl\PYGZsq{}, \PYGZsq{}linear\PYGZsq{}, \PYGZsq{}taylor, \PYGZsq{}lsq\PYGZsq{}}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{redist\PYGZus{}radius}   \PYG{o}{=} \PYG{l+m+mi}{1}           \PYG{c+c1}{\PYGZsh{} Redistribution radius for hyperbolic conservation laws}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{ghost\PYGZus{}interp}    \PYG{o}{=} \PYG{n}{pwl}         \PYG{c+c1}{\PYGZsh{} Ghost cell interpolation type. Valid options are \PYGZsq{}pwl\PYGZsq{} or \PYGZsq{}quad\PYGZsq{}}
\PYG{n}{amr\PYGZus{}mesh}\PYG{o}{.}\PYG{n}{ebcf}            \PYG{o}{=} \PYG{n}{true}        \PYG{c+c1}{\PYGZsh{} If you have EBCF crossing, this must be true. }
\end{sphinxVerbatim}

We now discuss the various \sphinxcode{\sphinxupquote{amr\_mesh}} class options.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.verbosity}} controls the verbosity of this class. \sphinxcode{\sphinxupquote{amr\_mesh}} can potentially do a lot of output, so it is best to leave this to the default value (\sphinxhyphen{}1) unless you are debugging.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.coarsest\_domain}} is the partitioning of the \sphinxstyleemphasis{coarsest} grid level that discretizes your problem domain. The entries in this option must all be integers of \sphinxcode{\sphinxupquote{amr\_mesh.max\_box\_size}}.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.blocking\_factor}} sets the minimum box size that can be generated by the mesh generation algorithm. We remark that if you are doing particle deposition, \sphinxcode{\sphinxupquote{amr\_mesh.blocking\_factor}} and \sphinxcode{\sphinxupquote{amr\_mesh.max\_box\_size}} MUST be equal.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.max\_box\_size}} sets the maximum box size that can be generated by the mesh generation algorithm.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.max\_ebis\_box}} sets the maximum box size that will be used in the geometry generation step. A smaller box will consume less memory, but geometry generation runtime will be longer.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.max\_amr\_depth}} defines the largest possible number of grids that can be used.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.max\_sim\_depth}} defines the maximum simulation depth for the simulation. This options exists because you may want to run one part of a simulation using a coarser resolution than \sphinxcode{\sphinxupquote{amr\_mesh.max\_amr\_depth}}.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.refine\_all\_lvl}} is deprecated class option.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.mg\_coarsen}} is a “pre\sphinxhyphen{}coarsening” method for multigrid solvers. The deeper multigrids levels are there to facilitate convergence, and it often helps to use fairly large box sizes on some of these levels before aggregating boxes.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.fill\_ratio}} is the fill ratio for the mesh refinement algorithm. This value must be between 0 and 1; a smaller value will result in larger grids. A higher value results in more compact grids, but possibly with more boxes.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.irreg\_growth}} controls how much irregular tags (e.g. boundary tags) are grown before being passed into the mesh refinement algorithm.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.buffer\_size}} is the minimum number of cells between grid levels.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.ref\_rat}} is the refinement factor between levels. Values 2 and 4 are supported, and you may use mixed refinement ratios. The length of this vector must be at least equal to the number of refinement levels.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.num\_ghost}} indicates how many ghost cells to use for all data holders. The typical value is 3 for EB\sphinxhyphen{}applications, but non\sphinxhyphen{}EB applications might get away with fewer ghost cells.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.eb\_ghost}} controls how ghost cells are used for the EB generation.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.centroid\_sten}} controls which stencil is used for interpolating data to irregular cell centroids. Currently available options are ‘pwl’ (piecewise linear), ‘linear’ (bi/trilinear), ‘taylor’ (higher order Taylor expansion), and ‘lsq’ which is a least squares fit. Only ‘pwl’ is guaranteed to have positive weights in the stencil.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.eb\_sten}} controls which stencil is used for interpolation/extrapolation to embedded boundary centroids. We cannot guarantee that the stencils have only positive weights.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.redist\_radius}} is the redistribution radius for hyperbolic redistribution.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.ghost\_interp}} defines the ghost cell interpolation type. Algorithms that require very specific ghost cell interpolation schemes (advection, for example) use their own interpolation method that is outside user control. The available options are ‘pwl’ (piecewise linear) and ‘quad’ (quadratic).

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.load\_balance}} tells \sphinxcode{\sphinxupquote{amr\_mesh}} how to load balance the grids.

\item {} 
\sphinxcode{\sphinxupquote{amr\_mesh.ebcf}} allows \sphinxcode{\sphinxupquote{amr\_mesh}} to turn on certain optimizations when there are \sphinxstylestrong{not} crossing between embedded boundaries and grid refinement boundaries. If such crossings exist, and you set this flag to false, \sphinxtitleref{PlasmaC} \sphinxstyleemphasis{will} compute incorrect answers.

\end{itemize}


\section{computational\_geometry}
\label{\detokenize{ComputationalGeometry:computational-geometry}}\label{\detokenize{ComputationalGeometry:chap-computational-geometry}}\label{\detokenize{ComputationalGeometry::doc}}
{\hyperref[\detokenize{ComputationalGeometry:chap-computational-geometry}]{\sphinxcrossref{\DUrole{std,std-ref}{computational\_geometry}}}} is the class that implements that geometry.
In \sphinxtitleref{PlasmaC}, we use level\sphinxhyphen{}set functions for description of surfaces. {\hyperref[\detokenize{ComputationalGeometry:chap-computational-geometry}]{\sphinxcrossref{\DUrole{std,std-ref}{computational\_geometry}}}} is not an abstract class;
if you pass in an instance of {\hyperref[\detokenize{ComputationalGeometry:chap-computational-geometry}]{\sphinxcrossref{\DUrole{std,std-ref}{computational\_geometry}}}} (rather than a casted instance), you will get a regular geometry without any boundaries.
A new {\hyperref[\detokenize{ComputationalGeometry:chap-computational-geometry}]{\sphinxcrossref{\DUrole{std,std-ref}{computational\_geometry}}}} class requires that you set the following class members:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n}{m\PYGZus{}eps0}\PYG{p}{;}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{electrode}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}electrodes}\PYG{p}{;}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{dielectric}\PYG{o}{\PYGZgt{}} \PYG{n}{m\PYGZus{}dielectrics}\PYG{p}{;}
\end{sphinxVerbatim}

Here, \sphinxcode{\sphinxupquote{m\_eps0}} is the gas permittivity, \sphinxcode{\sphinxupquote{m\_electrodes}} are the electrodes for the geometry and \sphinxcode{\sphinxupquote{m\_dielectrics}} are the dielectrics for the geometry.


\subsection{electrode}
\label{\detokenize{ComputationalGeometry:electrode}}\label{\detokenize{ComputationalGeometry:chap-electrode}}
The {\hyperref[\detokenize{ComputationalGeometry:chap-electrode}]{\sphinxcrossref{\DUrole{std,std-ref}{electrode}}}} class is responsible for describing an electrode and its boundary conditions. Internally, this class is lightweight and consists only of a tuple that holds a level\sphinxhyphen{}set function and an associated boolean value that tells whether or not the level\sphinxhyphen{}set function has a live potential or not. The constructor for the electrode class is:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{electrode}\PYG{p}{(}\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIF}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}baseif}\PYG{p}{,} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}live}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{a\PYGZus{}fraction} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the first argument is the level\sphinxhyphen{}set function and the second argument is responsible for setting the potential. The third argument is an optional argument that allows the user to set the potential to a specified fraction of the applied potential.


\subsection{dielectric}
\label{\detokenize{ComputationalGeometry:dielectric}}\label{\detokenize{ComputationalGeometry:chap-dielectric}}
The {\hyperref[\detokenize{ComputationalGeometry:chap-dielectric}]{\sphinxcrossref{\DUrole{std,std-ref}{dielectric}}}} class describes a electrode, this class is lightweight and consists only of a tuple that holds a level\sphinxhyphen{}set function and the permittivity.
The constructors are

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{dielectric}\PYG{p}{(}\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIF}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}baseif}\PYG{p}{,} \PYG{n}{Real} \PYG{n}{a\PYGZus{}permittivity}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{dielectric}\PYG{p}{(}\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIF}\PYG{o}{\PYGZgt{}} \PYG{n}{a\PYGZus{}baseif}\PYG{p}{,} \PYG{n}{Real} \PYG{p}{(}\PYG{o}{*}\PYG{n}{a\PYGZus{}permittivity}\PYG{p}{)}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where the first argument is the level\sphinxhyphen{}set function and the second argument sets a constant permittivity (first constructor) or a variable permittivity (second constructor).


\subsection{How \sphinxstyleliteralintitle{\sphinxupquote{computational\_geometry}} works}
\label{\detokenize{ComputationalGeometry:how-computational-geometry-works}}
When geometries are created, the \sphinxcode{\sphinxupquote{computational\_geometry}} class will first create the level\sphinxhyphen{}set functions that describe two possible material phases (gas and solid) and then compute the cut cell moments.

It is possible to retrieve the level\sphinxhyphen{}set functions for each phase, as well as the the electrodes and dielectrics.
This functionality is provided by:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{dielectric}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{get\PYGZus{}dielectrics}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{electrode}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{get\PYGZus{}electrodes}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIF}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{get\PYGZus{}gas\PYGZus{}if}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{k}{const} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{BaseIF}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{get\PYGZus{}sol\PYGZus{}if}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}


\section{time\_stepper}
\label{\detokenize{TimeStepper:time-stepper}}\label{\detokenize{TimeStepper:chap-time-stepper}}\label{\detokenize{TimeStepper::doc}}
The \sphinxcode{\sphinxupquote{time\_stepper}} class is the physics class in \sphinxcode{\sphinxupquote{PlasmaC}} \sphinxhyphen{} it has direct responsibility of setting up the solvers and performing time steps.

Since it is necessary to implement different solvers for different types of physics, \sphinxcode{\sphinxupquote{time\_stepper}} is an abstract class with the following pure functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Setup routines}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{setup\PYGZus{}solvers}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{initial\PYGZus{}data}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{post\PYGZus{}checkpoint\PYGZus{}setup}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// IO routines}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{write\PYGZus{}checkpoint\PYGZus{}data}\PYG{p}{(}\PYG{n}{HDF5Handle}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}handle}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lvl}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{read\PYGZus{}checkpoint\PYGZus{}data}\PYG{p}{(}\PYG{n}{HDF5Handle}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}handle}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lvl}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{int} \PYG{n+nf}{get\PYGZus{}num\PYGZus{}plot\PYGZus{}vars}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{write\PYGZus{}plot\PYGZus{}data}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}output}\PYG{p}{,} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}plotvar\PYGZus{}names}\PYG{p}{,} \PYG{k+kt}{int}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}icomp}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// Advance routines}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{compute\PYGZus{}dt}\PYG{p}{(}\PYG{n}{Real}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}dt}\PYG{p}{,} \PYG{n}{time\PYGZus{}code}\PYG{o}{:}\PYG{o}{:}\PYG{n}{which\PYGZus{}code}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}timecode}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{n}{Real} \PYG{n+nf}{advance}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{synchronize\PYGZus{}solver\PYGZus{}times}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}step}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}dt}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{print\PYGZus{}step\PYGZus{}report}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+c1}{// New regrid routines}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{register\PYGZus{}operators}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{pre\PYGZus{}regrid}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lmin}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}old\PYGZus{}finest\PYGZus{}level}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{deallocate}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{regrid}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lmin}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}old\PYGZus{}finest\PYGZus{}level}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}new\PYGZus{}finest\PYGZus{}level}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

These functions are used in the \sphinxcode{\sphinxupquote{driver}} class at various stages.
The three functions in the category \sphinxstyleemphasis{setup routines} are, for example using during simulation setup or after reading a checkpoint file for simulation restarts.
The IO routines are there so that users can choose which solvers perform any output, and the advance routines are there such that the user can implement new algorithms for time integration.
Finally, the \sphinxstyleemphasis{regrid routines} are there so that the solvers can back up their data before the old grids are destroyed (\sphinxcode{\sphinxupquote{cache()}}), deallocate unnecessary memory (\sphinxcode{\sphinxupquote{deallocate}}), and regrid data onto the new AMR grids \sphinxcode{\sphinxupquote{regrid(...)}}.

Depending on the physics that is resolved, writing \sphinxcode{\sphinxupquote{time\_stepper}} can be a small or a big task.
For example, the code used for advection\sphinxhyphen{}diffusion in \sphinxcode{\sphinxupquote{/physics/advection\_diffusion/}} is only a few hundred lines where most of the code is simply calling member functions from {\hyperref[\detokenize{CDR:chap-cdr}]{\sphinxcrossref{\DUrole{std,std-ref}{Convection\sphinxhyphen{}Diffusion\sphinxhyphen{}Reaction}}}}.


\section{cell\_tagger}
\label{\detokenize{CellTagger:cell-tagger}}\label{\detokenize{CellTagger:chap-cell-tagger}}\label{\detokenize{CellTagger::doc}}
The \sphinxcode{\sphinxupquote{cell\_tagger}} class is responsible for flagging grid cells for refinement or coarsening.
In \sphinxcode{\sphinxupquote{PlasmaC}}, refinement flags live in a data holder called \sphinxcode{\sphinxupquote{EBAMRTags}} inside of \sphinxcode{\sphinxupquote{driver}}.
This data is typedef’ed as

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{typedef} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{LayoutData}\PYG{o}{\PYGZlt{}}\PYG{n}{DenseIntVectSet}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZgt{}} \PYG{n}{EBAMRTags}\PYG{p}{;}
\end{sphinxVerbatim}

The \sphinxcode{\sphinxupquote{LayoutData\textless{}T\textgreater{}}} structure can be thought of as a \sphinxcode{\sphinxupquote{LevelData\textless{}T\textgreater{}}} without possibilities for communication.
\sphinxcode{\sphinxupquote{cell\_tagger}} is an abstract class that the user \sphinxstyleemphasis{must} overwrite \sphinxhyphen{} it is not possible to

When the regrid routine enters, the \sphinxcode{\sphinxupquote{cell\_tagger}} will be asked to generate the refinement flags through a function

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{bool} \PYG{n+nf}{tag\PYGZus{}cells}\PYG{p}{(}\PYG{n}{EBAMRTags}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}tags}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

If the user wants to implement a new refinement routine, he will do so by writing a new derived class from \sphinxcode{\sphinxupquote{cell\_tagger}}.
The \sphinxcode{\sphinxupquote{cell\_tagger}} parent class is a stand\sphinxhyphen{}alone class \sphinxhyphen{} it does not have a view of \sphinxcode{\sphinxupquote{amr\_mesh}}, \sphinxcode{\sphinxupquote{driver}}, or \sphinxcode{\sphinxupquote{time\_stepper}}.
Since refinement is intended to be quite general, the user is responsible for providing \sphinxcode{\sphinxupquote{cell\_tagger}} with the appropriate depedencies.
For example, for streamer simulations we often use the electric field when tagging grid cells, in which case the user should supply either a reference to the electric field, the potential, the Poisson solver, or the plasma physics object.


\subsection{Restrict tagging}
\label{\detokenize{CellTagger:restrict-tagging}}
It is possible to prevent cell tags in certain regions.
The default is simply to add a number of boxes where refinement and coarsening is allowed by specifying a number of boxes in the options file for the cell tagger:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
my\PYGZus{}cell\PYGZus{}tagger.num\PYGZus{}boxes   \PYG{o}{=} \PYG{l+m}{0}            \PYG{c+c1}{\PYGZsh{} Number of allowed tag boxes (0 = tags allowe everywhere)}
my\PYGZus{}cell\PYGZus{}tagger.box1\PYGZus{}lo     \PYG{o}{=} \PYG{l+m}{0}.0 \PYG{l+m}{0}.0 \PYG{l+m}{0}.0  \PYG{c+c1}{\PYGZsh{} Only allow tags that fall between}
my\PYGZus{}cell\PYGZus{}tagger.box1\PYGZus{}hi     \PYG{o}{=} \PYG{l+m}{0}.0 \PYG{l+m}{0}.0 \PYG{l+m}{0}.0  \PYG{c+c1}{\PYGZsh{} these two corners}
\end{sphinxVerbatim}

Here, \sphinxstyleemphasis{my\_cell\_tagger} is a placeholder for the name of the class that is used.
By adding restrictive boxes, tagging will only be allowed inside the specified box corners \sphinxcode{\sphinxupquote{box1\_lo}} and \sphinxcode{\sphinxupquote{box1\_hi}}.
More boxes can be specified by following the same convention, e.g. \sphinxcode{\sphinxupquote{box2\_lo}} and \sphinxcode{\sphinxupquote{box2\_hi}} etc.


\subsection{Adding a buffer}
\label{\detokenize{CellTagger:adding-a-buffer}}
By default, each MPI rank can only tag grid cells where he owns data.
This has been done for performance and communication reasons.
Under the hood, the \sphinxcode{\sphinxupquote{DenseIntVectSet}} is an array of boolean values on a patch which is very fast and simple to communicate with MPI.
Adding a grid cell for refinement which lies outside the patch will lead to memory corruptions.
It is nonetheless still possible to do this by growing the final generated tags like so:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
my\PYGZus{}cell\PYGZus{}tagger.buffer \PYG{o}{=} \PYG{l+m}{4} \PYG{c+c1}{\PYGZsh{} Add a buffer region around the tagged cells}
\end{sphinxVerbatim}

Just before passing the flags into \sphinxcode{\sphinxupquote{amr\_mesh}} grid generation routines, the tagged cells are put in a different data holder (\sphinxcode{\sphinxupquote{IntVectSet}}) and this data holder \sphinxstyleemphasis{can} contain cells that are outside the patch boundaries.


\chapter{Supported Solvers}
\label{\detokenize{index:supported-solvers}}\label{\detokenize{index:chap-supportedsolvers}}

\section{Solver}
\label{\detokenize{Solver:solver}}\label{\detokenize{Solver:chap-solver}}\label{\detokenize{Solver::doc}}

\section{Convection\sphinxhyphen{}Diffusion\sphinxhyphen{}Reaction}
\label{\detokenize{CDR:convection-diffusion-reaction}}\label{\detokenize{CDR:chap-cdr}}\label{\detokenize{CDR::doc}}
Here, we discuss the discretization of the equation
\begin{equation*}
\begin{split}\frac{\partial \phi}{\partial t} + \nabla\cdot\left(\mathbf{v} \phi - D\nabla \phi + \sqrt{2D\phi}\mathbf{Z}\right) = S.\end{split}
\end{equation*}
We assume that \(\phi\) is discretized by cell\sphinxhyphen{}centered averages (note that cell centers may lie inside solid boundaries), and use finite volume methods to construct fluxes in a cut\sphinxhyphen{}cells and regular cells.

Here, \(\mathbf{v}\) indicates a drift velocity, \(D\) is the diffusion coefficient, and the term \(\sqrt{2D\phi}\mathbf{Z}\) is a stochastic diffusion flux. \(S\) is the source term.


\subsection{cdr\_solver}
\label{\detokenize{CDR:cdr-solver}}\label{\detokenize{CDR:chap-cdr-solver}}
The \sphinxcode{\sphinxupquote{cdr\_solver}} class contains the interface for solving advection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction problems.
The class is abstract and resides in \sphinxcode{\sphinxupquote{/src/cdr\_solver/cdr\_solver.H(cpp)}} together with specific implementations.
By design \sphinxcode{\sphinxupquote{cdr\_solver}} does not contain any specific advective and diffusive discretization, and these are supposed to be added through inheritance.
For example, \sphinxcode{\sphinxupquote{cdr\_tga}} inherits from \sphinxcode{\sphinxupquote{cdr\_solver}} and adds a second order diffusive discretization together with multigrid code for performing implicit diffusion.
Below that, the classes \sphinxcode{\sphinxupquote{cdr\_gdnv}} and \sphinxcode{\sphinxupquote{cdr\_muscl}} inherit everything from \sphinxcode{\sphinxupquote{cdr\_tga}} and also adds in the advective discretization.
Thus, adding new advection code is done by inheriting from \sphinxcode{\sphinxupquote{cdr\_tga}} and implementing new advection schemes.
This is much more lightweight than rewriting all of \sphinxcode{\sphinxupquote{cdr\_solver}} (which is several thousand lines of code).

{\hfill\sphinxincludegraphics[]{graphviz-b6224a760d1dbe37493fcb7c9a5f4aface8a0927.pdf}\hspace*{\fill}}

Currently, we mostly use the implementation given in \sphinxcode{\sphinxupquote{/src/cdr\_solver/cdr\_gdnv.H(cpp)}} which contains a second order accurate discretization with slope limiters which was distributed by the Chombo team.
The alternative implementation in \sphinxcode{\sphinxupquote{/src/cdr\_muscl.H(cpp)}} contains a MUSCL implementation with van Leer slope limiting (i.e. much the same as the Chombo code).


\subsection{Using cdr\_solver}
\label{\detokenize{CDR:using-cdr-solver}}
The \sphinxcode{\sphinxupquote{cdr\_solver}} is intended to be used in a method\sphinxhyphen{}of\sphinxhyphen{}lines context where the user will
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Fill the solver with relevant data (e.g. velocities, diffusion coefficients, source terms etc.).

\item {} 
Call public member functions for computing advective or diffusive derivates, or perform implicit diffusion advances.

\end{enumerate}

There are on time integration algorithms built into the \sphinxcode{\sphinxupquote{cdr\_solver}}, and the user will have to supply these through \sphinxcode{\sphinxupquote{time\_stepper}}.
It is up to the developer to ensure that the solver is filled with appropriate data before calling the public member functions.
This would typically look something like this:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{vel} \PYG{o}{=} \PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{get\PYGZus{}velo\PYGZus{}cell}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{lvl} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{lvl} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{get\PYGZus{}finest\PYGZus{}level}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{lvl}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{k}{const} \PYG{n}{DisjointBoxLayout}\PYG{o}{\PYGZam{}} \PYG{n}{dbl} \PYG{o}{=} \PYG{n}{m\PYGZus{}amr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{get\PYGZus{}grids}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{;}

   \PYG{k}{for} \PYG{p}{(}\PYG{n}{DataIterator} \PYG{n}{dit} \PYG{o}{=} \PYG{n}{dbl}\PYG{p}{.}\PYG{n}{dataIterator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{dit}\PYG{p}{.}\PYG{n}{ok}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{o}{+}\PYG{o}{+}\PYG{n}{dit}\PYG{p}{)}\PYG{p}{\PYGZob{}}
      \PYG{n}{EBCellFAB}\PYG{o}{\PYGZam{}} \PYG{n}{patchVel} \PYG{o}{=} \PYG{p}{(}\PYG{o}{*}\PYG{n}{vel}\PYG{p}{[}\PYG{n}{lvl}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{n}{dit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;}

      \PYG{c+c1}{// Set velocity of some patch}
      \PYG{n}{callSomeFunction}\PYG{p}{(}\PYG{n}{patchVel}\PYG{p}{)}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Compute div(v*phi)}
\PYG{n}{compute\PYGZus{}divF}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\end{sphinxVerbatim}

More complete code is given in the physics module for advection\sphinxhyphen{}diffusion problems in \sphinxcode{\sphinxupquote{/physics/advection\_diffusion/advection\_diffusion\_stepper}}.
This code is also part of a regression test found in \sphinxcode{\sphinxupquote{/regression/advection\_diffusion}}.


\subsection{Setting up the solver}
\label{\detokenize{CDR:setting-up-the-solver}}
To set up the \sphinxcode{\sphinxupquote{cdr\_solver}}, the following commands are usually included in \sphinxcode{\sphinxupquote{time\_stepper::setup\_solvers()}}:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Assume m\PYGZus{}solver and m\PYGZus{}species are pointers to a cdr\PYGZus{}solver and cdr\PYGZus{}species}
\PYG{n}{m\PYGZus{}solver}  \PYG{o}{=} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{cdr\PYGZus{}solver}\PYG{o}{\PYGZgt{}}  \PYG{p}{(}\PYG{k}{new} \PYG{n}{my\PYGZus{}cdr\PYGZus{}solver}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}species} \PYG{o}{=} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{cdr\PYGZus{}species}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{new} \PYG{n}{my\PYGZus{}cdr\PYGZus{}species}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Solver setup}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{set\PYGZus{}verbosity}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{set\PYGZus{}species}\PYG{p}{(}\PYG{n}{m\PYGZus{}species}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{parse\PYGZus{}options}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{set\PYGZus{}phase}\PYG{p}{(}\PYG{n}{phase}\PYG{o}{:}\PYG{o}{:}\PYG{n}{gas}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{set\PYGZus{}amr}\PYG{p}{(}\PYG{n}{m\PYGZus{}amr}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{set\PYGZus{}computational\PYGZus{}geometry}\PYG{p}{(}\PYG{n}{m\PYGZus{}compgeom}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sanity\PYGZus{}check}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{allocate\PYGZus{}internals}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

To see an example, the advection\sphinxhyphen{}diffusion code in \sphinxcode{\sphinxupquote{/physics/advection\_diffusion/advection\_diffusion\_stepper}} shows how to set up the solver.


\subsection{Filling the solver}
\label{\detokenize{CDR:filling-the-solver}}
In order to obtain mesh data from the \sphinxcode{\sphinxupquote{cdr\_solver}}, the user should use the following public member functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{get\PYGZus{}state}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// Return  phi}
\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{get\PYGZus{}velo\PYGZus{}cell}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// Get cell\PYGZhy{}centered velocity}
\PYG{n}{EBAMRFluxData}\PYG{o}{\PYGZam{}} \PYG{n}{get\PYGZus{}diffco\PYGZus{}face}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{// Returns D}
\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{get\PYGZus{}source}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}       \PYG{c+c1}{// Returns S}
\PYG{n}{EBAMRIVData}\PYG{o}{\PYGZam{}} \PYG{n}{get\PYGZus{}ebflux}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}         \PYG{c+c1}{// Returns flux at EB}
\PYG{n}{EBAMRIFData}\PYG{o}{\PYGZam{}} \PYG{n}{get\PYGZus{}domainflux}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{// Returns flux at domain boundaries}
\end{sphinxVerbatim}

To set the drift velocities, the user will fill the \sphinxstyleemphasis{cell\sphinxhyphen{}centered} velocities.
Interpolation to face\sphinxhyphen{}centered transport fluxes are done by \sphinxcode{\sphinxupquote{cdr\_solver}} when needed.

The general way of setting the velocity is to get a direct handle to the velocity data:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{cdr\PYGZus{}solver} \PYG{n+nf}{solver}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{velo\PYGZus{}cell} \PYG{o}{=} \PYG{n}{solver}\PYG{p}{.}\PYG{n}{get\PYGZus{}velo\PYGZus{}cell}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Then, \sphinxcode{\sphinxupquote{velo\_cell}} can be filled with the cell\sphinxhyphen{}centered velocity.
The same procedure goes for the source terms, diffusion coefficients, boundary conditions and so on.


\subsection{Adjusting output}
\label{\detokenize{CDR:adjusting-output}}
It is possible to adjust solver output when plotting data.
This is done through the input file for the class that you’re using (e.g. \sphinxcode{\sphinxupquote{/src/cdr\_solver/cdr\_gdnv.options}}):

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
cdr\PYGZus{}gdnv.plt\PYGZus{}vars \PYG{o}{=} phi vel src dco ebflux  \PYG{c+c1}{\PYGZsh{} Plot variables. Options are \PYGZsq{}phi\PYGZsq{}, \PYGZsq{}vel\PYGZsq{}, \PYGZsq{}dco\PYGZsq{}, \PYGZsq{}src\PYGZsq{}, \PYGZsq{}ebflux\PYGZsq{}}
\end{sphinxVerbatim}

Here, you adjust the plotted variables by adding or omitting them from your input script.
E.g. if you only want to plot the cell\sphinxhyphen{}centered states you would do:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
cdr\PYGZus{}gdnv.plt\PYGZus{}vars \PYG{o}{=} phi  \PYG{c+c1}{\PYGZsh{} Plot variables. Options are \PYGZsq{}phi\PYGZsq{}, \PYGZsq{}vel\PYGZsq{}, \PYGZsq{}dco\PYGZsq{}, \PYGZsq{}src\PYGZsq{}, \PYGZsq{}ebflux\PYGZsq{}}
\end{sphinxVerbatim}


\subsection{cdr\_species}
\label{\detokenize{CDR:cdr-species}}\label{\detokenize{CDR:chap-cdr-species}}
The \sphinxcode{\sphinxupquote{cdr\_species}} class is a supporting class that passes information and initial conditions into \sphinxcode{\sphinxupquote{cdr\_solver}} instances.


\subsection{Discretization details}
\label{\detokenize{CDR:discretization-details}}

\subsubsection{Computing explicit divergences}
\label{\detokenize{CDR:computing-explicit-divergences}}\label{\detokenize{CDR:chap-explicitdivergence}}
Computing explicit divergences for equations like
\begin{equation*}
\begin{split}\frac{\partial \phi}{\partial t} + \nabla\cdot\mathbf{G} = 0\end{split}
\end{equation*}
is problematic because of the arbitarily small volume fractions of cut cells.
In general, we seek to update \(\phi^{k+1} = \phi^k - \Delta t \left[\nabla\cdot \mathbf{G}^k\right]\) where \(\left[\nabla\cdot\mathbf{G}\right]\) is a numerical approximation based on some finite volume approximation.
Recall that in finite volume methods we usually seek the update
\begin{equation}\label{equation:CDR:conservativeUpdate}
\begin{split}\phi^{k+1} = \phi^k - \frac{\Delta t}{\kappa \Delta x^{\textrm{DIM}}}\int_V\nabla\cdot\mathbf{G}dV,\end{split}
\end{equation}
where \(\kappa\) is the volume fraction of a grid cell, \(\textrm{DIM}\) is the spatial dimension and the volume integral is written as discretized surface integral
\begin{equation*}
\begin{split}\int_V\nabla\cdot\mathbf{G}dV =\sum_{f\in f(V)}\left(\mathbf{G}_f\cdot \mathbf{n}_f\right)\alpha_f\Delta x^{\textrm{DIM} -1}.\end{split}
\end{equation*}
The sum runs over all cell edges (faces in 3D) of the cell where \(G_f\) is the flux on the edge centroid and \(\alpha_f\) is the edge (face) aperture.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=480\sphinxpxdimen]{{cutCell}.png}
\caption{Location of centroid fluxes for cut cells.}\label{\detokenize{CDR:id1}}\end{figure}

However, taking \([\nabla\cdot\mathbf{G}^k]\) to be this sum leads to a time step constraint proportional to \(\kappa\), which can be arbitrarily small.
This leads to an unacceptable time step constraint for Eq.\ref{equation:CDR:conservativeUpdate}.
We use the Chombo approach and expand the range of influence of the cut cells in order to stabilize the discretization and allow the use of a normal time step constraint.
First, we compute the conservative divergence
\begin{equation*}
\begin{split}\kappa_{\mathbf{i}} D_\mathbf{i}^c =  \sum_f G_f\alpha_f\Delta x^{\textrm{DIM} -1},\end{split}
\end{equation*}
where \(G_f = \mathbf{G}_f\cdot \mathbf{n}_f\). Next, we compute a non\sphinxhyphen{}conservative divergence \(D_{\mathbf{i}}^{nc}\)
\begin{equation*}
\begin{split}D_\mathbf{i}^{nc} =  \frac{\sum_{\mathbf{j}\in{N}\left(\mathbf{i}\right)}\kappa_{\mathbf{j}}D_\mathbf{i}^c}{\sum_{\mathbf{j}\in{N}\left(\mathbf{i}\right)}\kappa_{\mathbf{j}}}\end{split}
\end{equation*}
where \(N(\mathbf{i})\) indicates some neighborhood of cells around cell \(\mathbf{i}\). Next, we compute a hybridization of the divergences,
\begin{equation*}
\begin{split}D_{\mathbf{i}}^H = \kappa_{\mathbf{i}} D_{\mathbf{i}}^c + (1-\kappa_{\mathbf{i}})D_{\mathbf{i}}^{nc},\end{split}
\end{equation*}
and perform an intermediate update
\begin{equation*}
\begin{split}\phi_{\mathbf{i}}^{k+1} = \phi_{\mathbf{i}}^k - \Delta tD_{\mathbf{i}}^H.\end{split}
\end{equation*}
The hybrid divergence update fails to conserve mass by an amount \(\delta M_{\mathbf{i}} = \kappa_{\mathbf{i}}\left(1-\kappa_{\mathbf{i}}\right)\left(D_{\mathbf{i}}^c - D_{\mathbf{i}}^{nc}\right)\).
In order to main overall conservation, the excess mass is redistributed into neighboring grid cells.
Let \(\delta M_{\mathbf{i}, \mathbf{j}}\) be the redistributed mass from \(\mathbf{j}\) to \(\mathbf{i}\) where
\begin{equation*}
\begin{split}\delta M_{\mathbf{i}} = \sum_{\mathbf{j} \in N(\mathbf{i})}\delta M_{\mathbf{i}, \mathbf{i}}.\end{split}
\end{equation*}
This mass is used as a local correction in the vicinity of the cut cells, i.e.
\begin{equation*}
\begin{split}\phi_{\mathbf{i}}^{k+1} \rightarrow \phi_{\mathbf{i}}^{k+1} + \delta M_{\mathbf{j}\in N(\mathbf{i}), \mathbf{i}},\end{split}
\end{equation*}
where \(\delta M_{\mathbf{j}\in N(\mathbf{i}), \mathbf{i}}\) is the total mass redistributed to cell \(\mathbf{i}\) from the other cells.
After these steps, we define
\begin{equation*}
\begin{split}\left[\nabla\cdot\mathbf{G}^k\right]_{\mathbf{i}} \equiv \frac{1}{\Delta t}\left(\phi_{\mathbf{i}}^{k+1} - \phi_{\mathbf{i}}^k\right)\end{split}
\end{equation*}
Numerically, the above steps for computing a conservative divergence of a one\sphinxhyphen{}component flux \(\mathbf{G}\) are implemented in the convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solvers, which also respects boundary conditions (e.g. charge injection).
The user will need to call the function

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n}{cdr\PYGZus{}solver}\PYG{o}{:}\PYG{o}{:}\PYG{n}{compute\PYGZus{}divG}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}divG}\PYG{p}{,} \PYG{n}{EBAMRFluxData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}G}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRIVData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}ebG}\PYG{p}{)}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{a\_G}} is the numerical representation of \(\mathbf{G}\) over the cut\sphinxhyphen{}cell AMR hierarchy and must be stored on cell\sphinxhyphen{}centered faces, and \sphinxcode{\sphinxupquote{a\_ebG}} is the flux on the embedded boundary.
The above steps are performed by interpolating \sphinxcode{\sphinxupquote{a\_G}} to face centroids in the cut cells for computing the conservative divergence, and the remaining steps are then performed successively.
The result is put in \sphinxcode{\sphinxupquote{a\_divG}}.

Note that when refinement boundaries intersect with embedded boundaries, the redistribution process is far more complicated since it needs to account for mass that moves over refinement boundaries.
These additional complicated are taken care of inside \sphinxcode{\sphinxupquote{a\_divG}}, but are not discussed in detail here.


\subsubsection{Maintaining non\sphinxhyphen{}negative densities}
\label{\detokenize{CDR:maintaining-non-negative-densities}}\label{\detokenize{CDR:chap-nonnegative}}
Although the redistribution functionality is conservative, the cut\sphinxhyphen{}cells represent boundaries that make the evolution non\sphinxhyphen{}monotone.
In particular, the redistribution process does not guarantee monotonicity.
In some cases, negative values of \(\phi\) are non\sphinxhyphen{}physical and the lack of non\sphinxhyphen{}negativeness can lead to numerical issues.

The \sphinxcode{\sphinxupquote{cdr\_solver}} has an option to use mass\sphinxhyphen{}weighted redistribution in order to redistribute mass in the neighborhood of the cut cells.
To turn this one, one must use e.g. \sphinxcode{\sphinxupquote{cdr\_gdnv.redist\_mass\_weighted = true}} in the input script.
The default is false, in which case the redistribution uses volume\sphinxhyphen{}weighted redistribution.

As a last effort, we support another redistribution step in the cut cells that redistributes mass from regular cells and into the cut cells in order to maintain non\sphinxhyphen{}negative densities.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{redistribute\PYGZus{}negative}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}phi}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Note that this \sphinxstyleemphasis{will} give give an \(\mathcal{O}(1)\) error in the solution and so it is not a very attractive solution.
The alternative of maintaining non\sphinxhyphen{}negative densities through mass injection introduces the same error, but in addition to adding a \(\mathcal{O}(1)\) error into the solution, this also has the side\sphinxhyphen{}effect of being non\sphinxhyphen{}conservative.


\subsubsection{Explicit advection}
\label{\detokenize{CDR:explicit-advection}}\label{\detokenize{CDR:chap-explicitadvection}}
Scalar advective updates follows the computation of the explicit divergence discussed in {\hyperref[\detokenize{CDR:chap-explicitdivergence}]{\sphinxcrossref{\DUrole{std,std-ref}{Computing explicit divergences}}}}.
The face\sphinxhyphen{}centered fluxes \(\mathbf{G} = \phi\mathbf{v}\) are computed by instantiation classes for the convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solvers.
These solvers may compute \(\mathbf{G}\) in different ways.
There is, for example, support for low\sphinxhyphen{}order upwind methods as well as Godunov methods.
The function signature for explicit advection is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n}{compute\PYGZus{}divF}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}divF}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}state}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}extrap\PYGZus{}dt}\PYG{p}{)}
\end{sphinxVerbatim}

where the face\sphinxhyphen{}centered fluxes are computed by using the velocities and boundary conditions that reside in the solver, and result is put in \sphinxcode{\sphinxupquote{a\_divF}} using the procedure outlined above.
For example, in order to perform an advective advance over a time step \(\Delta t\), one would perform the following:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Assume that data holders divF and phi are defined, and that \PYGZsq{}solver\PYGZsq{} is}
\PYG{c+c1}{// a valid convection\PYGZhy{}diffusion reaction solver with defined velocities.}
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{compute\PYGZus{}divF}\PYG{p}{(}\PYG{n}{divF}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Computes divF}
\PYG{n+nl}{data\PYGZus{}ops}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divF}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi \PYGZhy{} dt*divF}
\end{sphinxVerbatim}


\subsubsection{Explicit diffusion}
\label{\detokenize{CDR:explicit-diffusion}}\label{\detokenize{CDR:chap-explicitdiffusion}}
Explicit diffusion is performed in much the same way as implicit advection, with the exception that the general flux \(\mathbf{G} = D\nabla\phi\) is computed by using centered differences on face centers.
The function signature for explicit diffusion is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n}{compute\PYGZus{}divD}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}divF}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}state}\PYG{p}{)}
\end{sphinxVerbatim}

and we increment in the same way as for explicit advection:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Assume that data holders divD and phi are defined, and that \PYGZsq{}solver\PYGZsq{} is}
\PYG{c+c1}{// a valid convection\PYGZhy{}diffusion reaction solver with defined diffusion coefficients}
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{compute\PYGZus{}divD}\PYG{p}{(}\PYG{n}{divD}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Computes divD}
\PYG{n+nl}{data\PYGZus{}ops}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divD}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}    \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi + dt*divD}
\end{sphinxVerbatim}


\subsubsection{Explicit advection\sphinxhyphen{}diffusion}
\label{\detokenize{CDR:explicit-advection-diffusion}}\label{\detokenize{CDR:chap-explicitadvectiondiffusion}}
There is also functionality for aggregating explicit advection and diffusion advances.
The reason for this is that the cut\sphinxhyphen{}cell overhead is only applied once on the combined flux \(\phi\mathbf{v} - D\nabla\phi\) rather than on the individual fluxes.
For non\sphinxhyphen{}split methods this leads to some performance improvement since the interpolation of fluxes on cut\sphinxhyphen{}cell faces only needs to be performed once.
The signature for this is precisely the same as for explicit advection only:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n}{compute\PYGZus{}divJ}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}divJ}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}state}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}extrap\PYGZus{}dt}\PYG{p}{)}
\end{sphinxVerbatim}

where the face\sphinxhyphen{}centered fluxes are computed by using the velocities and boundary conditions that reside in the solver, and result is put in \sphinxcode{\sphinxupquote{a\_divF}}.
For example, in order to perform an advective advance over a time step \(\Delta t\), one would perform the following:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// Assume that data holders divJ and phi are defined, and that \PYGZsq{}solver\PYGZsq{} is}
\PYG{c+c1}{// a valid convection\PYGZhy{}diffusion reaction solver with defined velocities and}
\PYG{c+c1}{// diffusion coefficients}
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{compute\PYGZus{}divJ}\PYG{p}{(}\PYG{n}{divJ}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Computes divF}
\PYG{n+nl}{data\PYGZus{}ops}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divJ}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi \PYGZhy{} dt*divJ}
\end{sphinxVerbatim}

Often, time integrators have the option of using implicit or explicit diffusion.
If the time\sphinxhyphen{}evolution is non\sphinxhyphen{}split (i.e. not using a Strang or Godunov splitting), the integrators will often call \sphinxcode{\sphinxupquote{compute\_divJ}} rather separately calling \sphinxcode{\sphinxupquote{compute\_divF}} and \sphinxcode{\sphinxupquote{compute\_divD}}.
If you had a split\sphinxhyphen{}step Godunov method, the above procedure for a forward Euler method for both parts would be:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{compute\PYGZus{}divF}\PYG{p}{(}\PYG{n}{divF}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Computes divF = div(n*phi)}
\PYG{n+nl}{data\PYGZus{}ops}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divF}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi \PYGZhy{} dt*divF}

\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{compute\PYGZus{}divD}\PYG{p}{(}\PYG{n}{divD}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{;}      \PYG{c+c1}{// Computes divD = div(D*nabla(phi))}
\PYG{n+nl}{data\PYGZus{}ops}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divD}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}         \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi + dt*divD}
\end{sphinxVerbatim}

However, the cut\sphinxhyphen{}cell redistribution dance (flux interpolation, hybrid divergence, and redistribution) would be performed twice.


\subsubsection{Implicit diffusion}
\label{\detokenize{CDR:implicit-diffusion}}\label{\detokenize{CDR:chap-implicitdiffusion}}
Occasionally, the use of implicit diffusion is necessary.
The convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solvers support two basic diffusion solves:
Backward Euler and the Twizel\sphinxhyphen{}Gumel\sphinxhyphen{}Arigu (TGA) methods (it should be straightforward for the user to change the backward Euler method into a Crank\sphinxhyphen{}Nicholson scheme).
The function signatures for these are

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n}{advance\PYGZus{}euler}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phiNew}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phiOld}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{src}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{dt}\PYG{p}{)}
\PYG{k+kt}{void} \PYG{n}{advance\PYGZus{}tga}\PYG{p}{(}  \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phiNew}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phiOld}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{src}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{dt}\PYG{p}{)}

\PYG{k+kt}{void} \PYG{n}{advance\PYGZus{}euler}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phiNew}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phiOld}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{dt}\PYG{p}{)}
\PYG{k+kt}{void} \PYG{n}{advance\PYGZus{}tga}\PYG{p}{(}  \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phiNew}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phiOld}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{dt}\PYG{p}{)}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{phiNew}} is the state at the new time \(t + \Delta t\), \sphinxcode{\sphinxupquote{phiOld}} is the state at time \(t\) and \sphinxcode{\sphinxupquote{src}} is the source term which strictly speaking should be centered at time \(t + \Delta t\) for the Euler update and at time \(t + \Delta t/2\) for the TGA update.
This may or may not be possible for your particular problem.

For example, performing a split step Godunov method for advection\sphinxhyphen{}diffusion is as simple as:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{compute\PYGZus{}divF}\PYG{p}{(}\PYG{n}{divF}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Computes divF = div(n*phi)}
\PYG{n+nl}{data\PYGZus{}ops}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divF}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi \PYGZhy{} dt*divF}
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{redistribute\PYGZus{}negative}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{)}\PYG{p}{;}   \PYG{c+c1}{// Redist negative mass in cut cells}

\PYG{n}{data\PYGZus{}ops}\PYG{o}{:}\PYG{o}{:}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{phiOld}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{;}            \PYG{c+c1}{// Copy state}
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{advance\PYGZus{}euler}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{phiOld}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Backward Euler diffusion solve}
\end{sphinxVerbatim}


\subsubsection{Adding a stochastic flux}
\label{\detokenize{CDR:adding-a-stochastic-flux}}
It is possible to add a stochastic flux through the public member functions of \sphinxcode{\sphinxupquote{cdr\_solver}} in the odd case that one wants to use fluctuating hydrodynamics (FHD).
This is done by calling a function that computes the term \(\sqrt{2D\phi}\mathbf{Z}\):

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{void} \PYG{n+nf}{GWN\PYGZus{}diffusion\PYGZus{}source}\PYG{p}{(}\PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}ransource}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cell\PYGZus{}states}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

When FHD is used, there is no guarantee that the evolution leads to non\sphinxhyphen{}negative values.
We do our best to ensure that the stochastic flux is turned off when \(\phi \Delta V\) approaches 0 by computing the face\sphinxhyphen{}centered states for the stochastic term using an arithmetic mean that goes to zero as \(\phi\) approaches 0.

In the above function, \sphinxcode{\sphinxupquote{a\_ransource}} can be used directly in a MOL context, e.g.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{compute\PYGZus{}divF}\PYG{p}{(}\PYG{n}{divF}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Computes divF = div(n*phi)}
\PYG{n+nl}{data\PYGZus{}ops}\PYG{p}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{divF}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}        \PYG{c+c1}{// makes phi \PYGZhy{}\PYGZgt{} phi \PYGZhy{} dt*divF}

\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{GWN\PYGZus{}diffusion\PYGZus{}source}\PYG{p}{(}\PYG{n}{ransource}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Compute stochastic flux}
\PYG{n}{data\PYGZus{}ops}\PYG{o}{:}\PYG{o}{:}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{phiOld}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{)}\PYG{p}{;}                  \PYG{c+c1}{// phiOld = phi \PYGZhy{} dt*divF}
\PYG{n}{data\PYGZus{}ops}\PYG{o}{:}\PYG{o}{:}\PYG{n}{incr}\PYG{p}{(}\PYG{n}{phiOld}\PYG{p}{,} \PYG{n}{ransource}\PYG{p}{,} \PYG{n}{a\PYGZus{}dt}\PYG{p}{)}\PYG{p}{;}      \PYG{c+c1}{// phiOld = phi \PYGZhy{} dt*divF + dt*sqrt(2D*phi)Z}
\PYG{n}{solver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{advance\PYGZus{}euler}\PYG{p}{(}\PYG{n}{phi}\PYG{p}{,} \PYG{n}{phiOld}\PYG{p}{,} \PYG{n}{dt}\PYG{p}{)}\PYG{p}{;}       \PYG{c+c1}{// Backward Euler diffusion solve}
\end{sphinxVerbatim}


\section{Poisson}
\label{\detokenize{Poisson:poisson}}\label{\detokenize{Poisson:chap-poissonsolver}}\label{\detokenize{Poisson::doc}}
The code for the Poisson solver is given in \sphinxcode{\sphinxupquote{/src/poisson}} \sphinxstyleemphasis{and} \sphinxcode{\sphinxupquote{/src/elliptic}}.
The first folder contains the interface and code for only the Poisson solver, whereas the \sphinxcode{\sphinxupquote{/src/elliptic}} folder also contains generic code for elliptic problems.

The Poisson solver is named \sphinxcode{\sphinxupquote{poisson\_solver}} and currently only has one specific implementation: \sphinxcode{\sphinxupquote{poisson\_multifluid\_gmg}} which uses a multifluid embedded boundary formulation together with geometric multigrid.


\subsection{Setting up the solver}
\label{\detokenize{Poisson:setting-up-the-solver}}
In order to set up the solver, one must provide the

Creating a solver is often done with smart pointer casts like so:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{poisson\PYGZus{}solver}\PYG{o}{\PYGZgt{}} \PYG{n}{poisson} \PYG{o}{=} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{poisson\PYGZus{}solver}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{new} \PYG{n}{poisson\PYGZus{}multifluid\PYGZus{}gmg}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

In addition, one must parse run\sphinxhyphen{}time options to the class, provide the \sphinxcode{\sphinxupquote{amr\_mesh}} and \sphinxcode{\sphinxupquote{computational\_geometry}} instances, and set the initial conditions.
This is done as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{poisson}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{parse\PYGZus{}options}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}              \PYG{c+c1}{// Parse class options}
\PYG{n}{poisson}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{set\PYGZus{}amr}\PYG{p}{(}\PYG{n}{amr}\PYG{p}{)}\PYG{p}{;}                 \PYG{c+c1}{// Set amr \PYGZhy{} we assume that `amr` is an object}
\PYG{n}{poisson}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{set\PYGZus{}computational\PYGZus{}geometry}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Set the computational geometry}
\PYG{n}{poisson}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{allocate\PYGZus{}internals}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}         \PYG{c+c1}{// Allocate storage for potential etc.}
\PYG{n}{poisson}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{set\PYGZus{}potential}\PYG{p}{(}\PYG{n}{potential}\PYG{p}{)}\PYG{p}{;}     \PYG{c+c1}{// Set the potential}
\end{sphinxVerbatim}

The argument in the function \sphinxcode{\sphinxupquote{set\_potential(...)}} is a function pointer of the type

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n}{potential}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)}
\end{sphinxVerbatim}

and allows setting a time\sphinxhyphen{}dependent potential for the solver.

The \sphinxtitleref{PlasmaC} field solver has a lot of supporting functionality, but essentially relies on only one critical function:
Solving for the potential.
This is done by calling a class\sphinxhyphen{}specific function

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k+kt}{bool} \PYG{n+nf}{solve}\PYG{p}{(}\PYG{n}{MFAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{phi}\PYG{p}{,} \PYG{k}{const} \PYG{n}{MFAMRCellData}\PYG{o}{\PYGZam{}} \PYG{n}{rho}\PYG{p}{,} \PYG{k}{const} \PYG{n}{EBAMRIVData}\PYG{o}{\PYGZam{}} \PYG{n}{sigma}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{phi}} is the resulting potential that was computing with the space charge density \sphinxcode{\sphinxupquote{rho}} and surface charge density \sphinxcode{\sphinxupquote{sigma}}.

Currently, only one field solver is implemented and this solver uses a geometric multigrid method for solving for the potential.
The solver supports three phases: electrodes, gas, and dielectric.


\subsection{Boundary conditions}
\label{\detokenize{Poisson:boundary-conditions}}
Domain boundary conditions for the solver must be set by the user through an input script, whereas the boundary conditions on internal surfaces are Dirichlet by default.
Note that on multifluid\sphinxhyphen{}boundaries the Dirichlet boundary condition is enforced by the conventional matching boundary condition that follows from Gauss\textasciigrave{} law.


\subsection{Tuning multigrid performance}
\label{\detokenize{Poisson:tuning-multigrid-performance}}
The Poisson equation is currently solved with a geometric multigrid method (GMG).
Various switches are enabled that adjust the performance of GMG, and these are listed below

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{\PYGZsh{} ====================================================================================================}
\PYG{c+c1}{\PYGZsh{} POISSON\PYGZus{}MULTIFLUID\PYGZus{}GMG\PYGZus{}GMG CLASS OPTIONS (MULTIFLUID GMG SOLVER SETTINGS)}
\PYG{c+c1}{\PYGZsh{} ====================================================================================================}
poisson\PYGZus{}multifluid\PYGZus{}gmg.bc\PYGZus{}x\PYGZus{}low  \PYG{o}{=} neumann           \PYG{c+c1}{\PYGZsh{} BC type. \PYGZdq{}neumann\PYGZdq{}, \PYGZdq{}dirichlet\PYGZus{}ground\PYGZdq{}, \PYGZdq{}dirichlet\PYGZus{}live\PYGZdq{}}
poisson\PYGZus{}multifluid\PYGZus{}gmg.bc\PYGZus{}x\PYGZus{}high \PYG{o}{=} neumann           \PYG{c+c1}{\PYGZsh{} BC type. \PYGZdq{}neumann\PYGZdq{}, \PYGZdq{}dirichlet\PYGZus{}ground\PYGZdq{}, \PYGZdq{}dirichlet\PYGZus{}live\PYGZdq{}}
poisson\PYGZus{}multifluid\PYGZus{}gmg.bc\PYGZus{}y\PYGZus{}low  \PYG{o}{=} dirichlet\PYGZus{}ground  \PYG{c+c1}{\PYGZsh{} BC type. \PYGZdq{}neumann\PYGZdq{}, \PYGZdq{}dirichlet\PYGZus{}ground\PYGZdq{}, \PYGZdq{}dirichlet\PYGZus{}live\PYGZdq{}}
poisson\PYGZus{}multifluid\PYGZus{}gmg.bc\PYGZus{}y\PYGZus{}high \PYG{o}{=} dirichlet\PYGZus{}live    \PYG{c+c1}{\PYGZsh{} BC type. \PYGZdq{}neumann\PYGZdq{}, \PYGZdq{}dirichlet\PYGZus{}ground\PYGZdq{}, \PYGZdq{}dirichlet\PYGZus{}live\PYGZdq{}}
poisson\PYGZus{}multifluid\PYGZus{}gmg.bc\PYGZus{}z\PYGZus{}low  \PYG{o}{=} neumann           \PYG{c+c1}{\PYGZsh{} BC type. \PYGZdq{}neumann\PYGZdq{}, \PYGZdq{}dirichlet\PYGZus{}ground\PYGZdq{}, \PYGZdq{}dirichlet\PYGZus{}live\PYGZdq{}}
poisson\PYGZus{}multifluid\PYGZus{}gmg.bc\PYGZus{}z\PYGZus{}high \PYG{o}{=} neumann           \PYG{c+c1}{\PYGZsh{} BC type. \PYGZdq{}neumann\PYGZdq{}, \PYGZdq{}dirichlet\PYGZus{}ground\PYGZdq{}, \PYGZdq{}dirichlet\PYGZus{}live\PYGZdq{}}
poisson\PYGZus{}multifluid\PYGZus{}gmg.plt\PYGZus{}vars  \PYG{o}{=} phi rho E res     \PYG{c+c1}{\PYGZsh{} Plot variables. Possible vars are \PYGZsq{}phi\PYGZsq{}, \PYGZsq{}rho\PYGZsq{}, \PYGZsq{}E\PYGZsq{}, \PYGZsq{}res\PYGZsq{}}

poisson\PYGZus{}multifluid\PYGZus{}gmg.auto\PYGZus{}tune         \PYG{o}{=} \PYG{n+nb}{false}     \PYG{c+c1}{\PYGZsh{} Do some auto\PYGZhy{}tuning}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}verbosity     \PYG{o}{=} \PYGZhy{}1        \PYG{c+c1}{\PYGZsh{} GMG verbosity}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}pre\PYGZus{}smooth    \PYG{o}{=} \PYG{l+m}{12}        \PYG{c+c1}{\PYGZsh{} Number of relaxations in downsweep}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}post\PYGZus{}smooth   \PYG{o}{=} \PYG{l+m}{12}        \PYG{c+c1}{\PYGZsh{} Number of relaxations in upsweep}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}bott\PYGZus{}smooth   \PYG{o}{=} \PYG{l+m}{12}        \PYG{c+c1}{\PYGZsh{} NUmber of relaxations before dropping to bottom solver}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}min\PYGZus{}iter      \PYG{o}{=} \PYG{l+m}{5}         \PYG{c+c1}{\PYGZsh{} Minimum number of iterations}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}max\PYGZus{}iter      \PYG{o}{=} \PYG{l+m}{32}        \PYG{c+c1}{\PYGZsh{} Maximum number of iterations}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}tolerance     \PYG{o}{=} \PYG{l+m}{1}.E\PYGZhy{}10    \PYG{c+c1}{\PYGZsh{} Residue tolerance}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}hang          \PYG{o}{=} \PYG{l+m}{0}.2       \PYG{c+c1}{\PYGZsh{} Solver hang}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}bottom\PYGZus{}drop   \PYG{o}{=} \PYG{l+m}{4}         \PYG{c+c1}{\PYGZsh{} Bottom drop}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}bc\PYGZus{}order      \PYG{o}{=} \PYG{l+m}{2}         \PYG{c+c1}{\PYGZsh{} Boundary condition order for multigrid}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}bottom\PYGZus{}solver \PYG{o}{=} bicgstab  \PYG{c+c1}{\PYGZsh{} Bottom solver type. \PYGZsq{}simple\PYGZsq{}, \PYGZsq{}bicgstab\PYGZsq{}, or \PYGZsq{}gmres\PYGZsq{}}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}bottom\PYGZus{}relax  \PYG{o}{=} \PYG{l+m}{32}        \PYG{c+c1}{\PYGZsh{} Number of relaxations in bottom solve (\PYGZsq{}simple\PYGZsq{} solver only)}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}cycle         \PYG{o}{=} vcycle    \PYG{c+c1}{\PYGZsh{} Cycle type. Only \PYGZsq{}vcycle\PYGZsq{} supported for now}
poisson\PYGZus{}multifluid\PYGZus{}gmg.gmg\PYGZus{}relax\PYGZus{}type    \PYG{o}{=} gsrb      \PYG{c+c1}{\PYGZsh{} Relaxation type. \PYGZsq{}jacobi\PYGZsq{}, \PYGZsq{}gauss\PYGZus{}seidel\PYGZsq{}, or \PYGZsq{}gsrb\PYGZsq{}}
\end{sphinxVerbatim}


\subsection{Adjusting output}
\label{\detokenize{Poisson:adjusting-output}}
The user may plot the potential, the space charge, the electric, and the GMG residue as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
poisson\PYGZus{}multifluid\PYGZus{}gmg.plt\PYGZus{}vars  \PYG{o}{=} phi rho E res     \PYG{c+c1}{\PYGZsh{} Plot variables. Possible vars are \PYGZsq{}phi\PYGZsq{}, \PYGZsq{}rho\PYGZsq{}, \PYGZsq{}E\PYGZsq{}, \PYGZsq{}res\PYGZsq{}}
\end{sphinxVerbatim}


\section{Radiative transfer}
\label{\detokenize{RTE:radiative-transfer}}\label{\detokenize{RTE:chap-radiativetransfer}}\label{\detokenize{RTE::doc}}
Radiative transfer is supported in the diffusion (i.e. Eddington or Helmholtz) approximation and with Monte Carlo sampling of discrete photons.
The solvers share a common interface but since diffusion RTE is deterministic and discrete Monte Carlo photons are stochastic, not all temporal integration methods will support both.
The diffusion approximation relies on solving an elliptic equation in the stationary case and a parabolic equation in the time\sphinxhyphen{}dependent case, while the Monte\sphinxhyphen{}Carlo approach solves solves for fully transient or ‘’stationary’’ transport.


\subsection{Diffusion approximation}
\label{\detokenize{RTE:diffusion-approximation}}
In the diffusion approximation, the radiative transport equation is
\begin{equation*}
\begin{split}\partial_t\Psi + \kappa\Psi - \nabla\cdot\left(\frac{1}{3\kappa}\nabla\Psi\right) = \frac{\eta}{c},\end{split}
\end{equation*}
which is called the Eddington approximation. The radiative flux is \(F = -\frac{c}{3\kappa}\nabla \Psi\).
We do not currently support flux\sphinxhyphen{}limited diffusion radiative transfer.
In the stationary case this yields a Helmholtz equation
\begin{equation*}
\begin{split}\kappa\Psi - \nabla\cdot\left(\frac{1}{3\kappa}\nabla\Psi\right) = \frac{\eta}{c},\end{split}
\end{equation*}
which is solved by a geometric multigrid method. The default boundary conditions are of the Robin type.
For fully transient radiative transport, we offer discretizations based on the backward Euler and TGA schemes.


\subsection{Monte Carlo methods}
\label{\detokenize{RTE:monte-carlo-methods}}
All types of moment\sphinxhyphen{}closed radiative transfer equations contain nonphysical artifacts (which may or may not be acceptable).
For example, in the diffusion approximation the radiative flux is \(F = -\frac{c}{3\kappa}\nabla \Psi\), implying that photons can leak around boundaries.
I.e. the diffusion approximation does not correctly describe shadows.
It is possible to go beyond the diffusion approximation by also solving for higher\sphinxhyphen{}order moments like the radiative flux.
While such methods can describe shadows, they contain other nonphysical features.

\begin{figure}[htb]
\centering
\capstart

\noindent\sphinxincludegraphics[width=720\sphinxpxdimen]{{rte_comp}.png}
\caption{Qualitative comparison between predictions made with a diffusion RTE solver and a Monte Carlo RTE solver.
Left: Source term.
Middle: Solution computed in the diffusion approximation with homogeneous Robin boundary conditions.
Right: Solution computed with a Monte Carlo method.}\label{\detokenize{RTE:id1}}\end{figure}

Both ‘’stationary’’ and transient Monte Carlo methods are offered as an alternative to the diffusion approximation.


\subsubsection{photon particle}
\label{\detokenize{RTE:photon-particle}}
The Îto particle is a computational particle class in \sphinxtitleref{PlasmaC} which can be used together with the particle tools in \sphinxtitleref{Chombo}.
The following data fields are implemented in the particle:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RealVect} \PYG{n}{m\PYGZus{}position}\PYG{p}{;}
\PYG{n}{RealVect} \PYG{n}{m\PYGZus{}velocity}\PYG{p}{;}
\PYG{n}{Real} \PYG{n}{m\PYGZus{}mass}\PYG{p}{;}
\PYG{n}{Real} \PYG{n}{m\PYGZus{}kappa}\PYG{p}{;}
\end{sphinxVerbatim}

To obtain the fields, the user will call

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{position}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{velocity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Real}\PYG{o}{\PYGZam{}} \PYG{n}{mass}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Real}\PYG{o}{\PYGZam{}} \PYG{n}{diffusion}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

All functions also have \sphinxcode{\sphinxupquote{const}} versions.
Note that the field \sphinxcode{\sphinxupquote{m\_mass}} is the same as the \sphinxstyleemphasis{weight} of the computational particle.
The following functions are used to set the various properties:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{setPosition}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{setVelocity}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}vel}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{setMass}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}mass}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{setDiffusion}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}diffusion}\PYG{p}{;}
\end{sphinxVerbatim}


\subsubsection{Interaction with boundaries}
\label{\detokenize{RTE:interaction-with-boundaries}}

\subsubsection{Stationary Monte Carlo}
\label{\detokenize{RTE:stationary-monte-carlo}}
The stationary Monte Carlo method proceeds as follows.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
For each cell in the mesh, draw a discrete number of photons \(\mathcal{P}\left(\eta \Delta V\Delta t\right)\) where \(\mathcal{P}\) is a Poisson distribution. The user may also choose to use pseudophotons rather than physical photons by modifying photon weights. Each photon is generated in the cell centroid \(\mathbf{x}_0\) and given a random propagation direction \(\mathbf{n}\).

\item {} 
Draw a propagation distance \(r\) by drawing random numbers from an exponential distribution \(p(r) = \kappa \exp\left(-\kappa r\right)\). The absorbed position of the photon is \(\mathbf{x} = \mathbf{x}_0 + r\mathbf{n}\).

\item {} 
Check if the path from \(\mathbf{x}_0\) to \(\mathbf{x}\) intersects an internal or domain boundary. If it does, absorb the photon on the boundary. If not, move the photon to \(\mathbf{x}\) or reflect it off symmetry boundaries.

\item {} 
Rebin the absorbed photons onto the AMR grid. This involves parallel communication.

\item {} 
Compute the resulting photoionization profile. The user may choose between several different deposition schemes (like e.g. cloud\sphinxhyphen{}in\sphinxhyphen{}cell).

\end{enumerate}

The Monte Carlo methods use computational particles for advancing the photons in exactly the same way a Particle\sphinxhyphen{}In\sphinxhyphen{}Cell method would use them for advancing electrons. Although a computational photon would normally live on the finest grid level that overlaps its position, this is not practical for all particle deposition kernels. For example, for cloud\sphinxhyphen{}in\sphinxhyphen{}cell deposition schemes it is useful to have the restrict the interpolation kernels to the grid level where the particle lives. In Chombo\sphinxhyphen{}speak, we therefore use a buffer region that extends some cells from a refinement boundary where the photons are not allowed to live. Instead, photons in that buffer region are transferred to a coarser level, and their deposition clouds are first interpolated to the fine level before deposition on the fine level happens. Selecting a deposition scheme and adjusting the buffer region is done through an input script associated with the solver.


\subsubsection{Transient Monte Carlo}
\label{\detokenize{RTE:transient-monte-carlo}}
The transient Monte Carlo method is almost identical to the stationary method, except that it does not deposit all generated photons on the mesh but tracks them through time. The transient method is implemented as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
For each cell in the mesh, draw a discrete number of photons \(\mathcal{P}\left(\eta \Delta V\Delta t\right)\) as above, and append these to the already existing photons. Each photon is given a uniformly distributed random creation time within \(\Delta t\).

\item {} 
Each photon is advanced over the time step \(\Delta t\) by a sequence of \(N\) substeps (\(N\) may be different for each photon).
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumii}{enumiii}{}{.}%
\item {} 
We compute \(N\) such that we sample \(N\Delta \tau = \Delta t\) with \(c\kappa\Delta\tau < 1\).

\item {} 
A photon at position \(\mathbf{x}_0\) is moved a distance \(\Delta \mathbf{x} = c\mathbf{n}\Delta\tau\). For each step we compute the absorption probability \(p = \kappa\left|\Delta\mathbf{x}\right|\) where \(p\in[0,1]\) is a uniform random number. If the photon is absorbed on this interval, draw a new uniform random number \(r \in [0,1]\) and absorb the photon at the position \(\mathbf{x}_0 + r\Delta\mathbf{x}\). If the photon is not absorbed, it is moved to position \(\mathbf{x}_0 + r\Delta\mathbf{x}\).

\end{enumerate}

\item {} 
Check if the path from \(\mathbf{x}_0\) to \(\mathbf{x}\) intersects an internal or domain boundary. If it does, absorb the photon on the boundary. If not, move the photon to \(\mathbf{x}\).

\item {} 
Rebin the absorbed photons onto the AMR grid. This involves parallel communication.

\item {} 
Compute the resulting photoionization profile. The user may choose between several different deposition schemes (like e.g. cloud\sphinxhyphen{}in\sphinxhyphen{}cell).

\end{enumerate}


\subsection{Limitations}
\label{\detokenize{RTE:limitations}}

\section{Surface charge solver}
\label{\detokenize{Sigma:surface-charge-solver}}\label{\detokenize{Sigma:chap-sigmasolver}}\label{\detokenize{Sigma::doc}}
In order to conserve charge on solid insulators, \sphinxtitleref{PlasmaC} has a solver that is defined on the gas\sphinxhyphen{}dielectric interface where the surface charge is updated with the incoming flux
\begin{equation*}
\begin{split}F_\sigma(\phi) = \sum_{\phi}q_\phi F_{\textrm{EB}}(\phi),\end{split}
\end{equation*}
where \(q_\phi\) is the charge of a species \(\phi\). This ensures strong conservation on insulating surfaces.


\section{Îto diffusion}
\label{\detokenize{Ito:ito-diffusion}}\label{\detokenize{Ito:chap-itodiffusion}}\label{\detokenize{Ito::doc}}
The Îto diffusion model advances computational particles as Brownian walkers with drift:
\begin{equation*}
\begin{split}d\mathbf{X}_i = \mathbf{v}_idt + \sqrt{2D_i}\mathbf{W}_i dt,\end{split}
\end{equation*}
where \(\mathbf{X}_i\) is the spatial position of a particle \(i\), \(\mathbf{v}_i\) is the drift coefficient and \(D_i\) is the diffusion coefficient \sphinxstyleemphasis{in the continuum limit}.
That is, both \(\mathbf{v}_i\) and \(D_i\) are the quantities that appear in {\hyperref[\detokenize{CDR:chap-cdr}]{\sphinxcrossref{\DUrole{std,std-ref}{Convection\sphinxhyphen{}Diffusion\sphinxhyphen{}Reaction}}}}.
The vector term \(\mathbf{W}_i\) is a Gaussian random field with a mean value of 0 and standard deviation of 1.

The code for Îto diffusion is given in \sphinxcode{\sphinxupquote{/src/ito\_solver}} and only a brief explanation is given here.
The source code is used by a physics module in \sphinxcode{\sphinxupquote{/physics/brownian\_walker}} and in the regression test \sphinxcode{\sphinxupquote{/regression/brownian\_walker}}.


\subsection{The Îto particle}
\label{\detokenize{Ito:the-ito-particle}}\label{\detokenize{Ito:chap-ito-particle}}
The Îto particle is a computational particle class in \sphinxtitleref{PlasmaC} which can be used together with the particle tools in \sphinxtitleref{Chombo}.
The following data fields are implemented in the particle:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RealVect} \PYG{n}{m\PYGZus{}position}\PYG{p}{;}
\PYG{n}{RealVect} \PYG{n}{m\PYGZus{}velocity}\PYG{p}{;}
\PYG{n}{Real} \PYG{n}{m\PYGZus{}mass}\PYG{p}{;}
\PYG{n}{Real} \PYG{n}{m\PYGZus{}diffusion}\PYG{p}{;}
\end{sphinxVerbatim}

To obtain the fields, the user will call

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{position}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{velocity}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Real}\PYG{o}{\PYGZam{}} \PYG{n}{mass}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Real}\PYG{o}{\PYGZam{}} \PYG{n}{diffusion}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

All functions also have \sphinxcode{\sphinxupquote{const}} versions.
Note that the field \sphinxcode{\sphinxupquote{m\_mass}} is the same as the \sphinxstyleemphasis{weight} of the computational particle.
The following functions are used to set the various properties:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{setPosition}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{setVelocity}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}vel}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{setMass}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}mass}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{setDiffusion}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}diffusion}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{ito\_species}
\label{\detokenize{Ito:ito-species}}\label{\detokenize{Ito:chap-ito-species}}
\sphinxcode{\sphinxupquote{ito\_species}} is a class for parsing information into the solver class.
The constructor for the \sphinxcode{\sphinxupquote{ito\_species}} class is

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{ito\PYGZus{}species}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{a\PYGZus{}name}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}charge}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}mobile}\PYG{p}{,} \PYG{k}{const} \PYG{k+kt}{bool} \PYG{n}{a\PYGZus{}diffusive}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

and this will set the name of the class, the charge, and whether or not the transport kernels account for drift and diffusion.


\subsubsection{Setting initial conditions}
\label{\detokenize{Ito:setting-initial-conditions}}
In order to set the initial conditions the user must fill the list \sphinxcode{\sphinxupquote{List\textless{}ito\_particle\textgreater{} m\_initial\_particles}} in \sphinxcode{\sphinxupquote{ito\_species}}.
When \sphinxcode{\sphinxupquote{initial\_data()}} is called from \sphinxcode{\sphinxupquote{ito\_solver}}, the initial particles are transferred from the instance of \sphinxcode{\sphinxupquote{ito\_species}} and into the instance of \sphinxcode{\sphinxupquote{ito\_solver}}.

We remark that it is a bad idea to replicate the initial particle list over all MPI ranks in a simulation.
If one has a list of initial particles, or wants to draw a specified number of particles from a distribution, the initial particles \sphinxstyleemphasis{must} be distributed over the available MPI ranks.
For example, the code in \sphinxcode{\sphinxupquote{/physics/brownian\_walker/brownian\_walker\_species.cpp}} draws a specified number of particles distributed over all MPI ranks as (the code is called in \sphinxcode{\sphinxupquote{brownian\_walker\_species::draw\_initial\_particles}})

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{// To avoid that MPI ranks draw the same particle positions, increment the seed for each rank}
\PYG{n}{m\PYGZus{}seed} \PYG{o}{+}\PYG{o}{=} \PYG{n}{procID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Set up the RNG}
\PYG{n}{m\PYGZus{}rng} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{mt19937\PYGZus{}64}\PYG{p}{(}\PYG{n}{m\PYGZus{}seed}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}gauss} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{normal\PYGZus{}distribution}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,} \PYG{n}{m\PYGZus{}blob\PYGZus{}radius}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m\PYGZus{}udist11} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{uniform\PYGZus{}real\PYGZus{}distribution}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{p}{,} \PYG{l+m+mf}{1.}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{// Each MPI process draws the desired number of particles from a distribution}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{quotient}  \PYG{o}{=} \PYG{n}{m\PYGZus{}num\PYGZus{}particles}\PYG{o}{/}\PYG{n}{numProc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{remainder} \PYG{o}{=} \PYG{n}{m\PYGZus{}num\PYGZus{}particles} \PYG{o}{\PYGZpc{}} \PYG{n}{numProc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{particlesPerRank}\PYG{p}{(}\PYG{n}{numProc}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{quotient}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{remainder}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
  \PYG{n}{particlesPerRank}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// Now make the particles}
\PYG{n}{m\PYGZus{}initial\PYGZus{}particles}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{particlesPerRank}\PYG{p}{[}\PYG{n}{procID}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{\PYGZob{}}
  \PYG{k}{const} \PYG{n}{Real} \PYG{n}{weight}  \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
  \PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{pos} \PYG{o}{=} \PYG{n}{m\PYGZus{}blob\PYGZus{}center} \PYG{o}{+} \PYG{n}{random\PYGZus{}gaussian}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{m\PYGZus{}initial\PYGZus{}particles}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{n}{ito\PYGZus{}particle}\PYG{p}{(}\PYG{n}{weight}\PYG{p}{,} \PYG{n}{pos}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Computing time steps}
\label{\detokenize{Ito:computing-time-steps}}
The signatures for computing a time step for the \sphinxcode{\sphinxupquote{ito\_solver}} are given separately for the drift part and the diffusion part.


\subsubsection{Drift}
\label{\detokenize{Ito:drift}}
The drift time step routines are implemented such that one restricts the time step such that the fastest particle does not move more than a specified number of grid cells.

For the drift, the signatures are

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n+nf}{compute\PYGZus{}min\PYGZus{}drift\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}maxCellsToMove}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}drift\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}maxCellsToMove}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}drift\PYGZus{}dt}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;} \PYG{c+c1}{// Compute dt on all AMR levels, return vector of time step}
\PYG{n}{Real} \PYG{n+nf}{compute\PYGZus{}drift\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lvl}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{n}{Real} \PYG{n+nf}{compute\PYGZus{}drift\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lvl}\PYG{p}{,} \PYG{k}{const} \PYG{n}{DataIndex}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}dit}\PYG{p}{,} \PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}dx}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

These last three functions all compute \(\Delta t = \Delta x/Max(v_x, v_y, v_z)\) on the the various AMR levels and patches.
The routine

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}drift\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}maxCellsToMove}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

simply scales \(\Delta t\) by \sphinxcode{\sphinxupquote{a\_maxCellsToMove}} on every level.
Finally, the function \sphinxcode{\sphinxupquote{compute\_min\_drift\_dt(...)}} computes the smallest time step across every AMR level.


\subsubsection{Diffusion}
\label{\detokenize{Ito:diffusion}}
The signatures for the diffusion time step are similar to the ones for drift:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n+nf}{compute\PYGZus{}min\PYGZus{}diffusion\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}maxCellsToMove}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}diffusion\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}maxCellsToMove}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}

\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}diffusion\PYGZus{}dt}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{n}{Real} \PYG{n+nf}{compute\PYGZus{}diffusion\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lvl}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{n}{Real} \PYG{n+nf}{compute\PYGZus{}diffusion\PYGZus{}dt}\PYG{p}{(}\PYG{k}{const} \PYG{k+kt}{int} \PYG{n}{a\PYGZus{}lvl}\PYG{p}{,} \PYG{k}{const} \PYG{n}{DataIndex}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}dit}\PYG{p}{,} \PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}dx}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\end{sphinxVerbatim}

In these routines, the time step is computed as \(\Delta t = \frac{\Delta x}{\sqrt{2D}}\).
Note that there is still a chance that a particle jumps further than specified by \sphinxcode{\sphinxupquote{a\_maxCellsToMove}} since the diffusion hop is
\begin{equation*}
\begin{split}\mathbf{d} = \sqrt{2D}\mathbf{Z}\Delta t,\end{split}
\end{equation*}
where \(\mathbf{Z}\) is a random Gaussian.
The probability that a diffusion hop leads to a jump larger than \(N\) cells can be evaluated and is \(P = \textrm{erf}\left(\sqrt{2}N\right)\). It is useful to keep this probability in mind when deciding on the PVR.


\subsection{Remapping particles}
\label{\detokenize{Ito:remapping-particles}}
Particle remapping has been implemented for the whole AMR hierarchy as a two step process.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Perform two\sphinxhyphen{}level remapping where particles are transferred up or down one grid level if they move out the level PVR.

\item {} 
Gather all particles that are remnant in the outcast list on the coarsest level, and then distribute them back to their appropriate levels. For example, particles that hopped over more than one refinement boundary cannot be transferred with a (clean) two\sphinxhyphen{}level transfer.

\end{enumerate}


\subsection{Limitations}
\label{\detokenize{Ito:limitations}}

\chapter{Implemented models}
\label{\detokenize{index:implemented-models}}\label{\detokenize{index:chap-implementedmodels}}

\section{Poisson model}
\label{\detokenize{PoissonModel:poisson-model}}\label{\detokenize{PoissonModel:chap-poissonmodel}}\label{\detokenize{PoissonModel::doc}}

\section{Advection diffusion model}
\label{\detokenize{AdvectionDiffusionModel:advection-diffusion-model}}\label{\detokenize{AdvectionDiffusionModel:chap-advectiondiffusionmodel}}\label{\detokenize{AdvectionDiffusionModel::doc}}

\section{Brownian walker model}
\label{\detokenize{BrownianWalkerModel:brownian-walker-model}}\label{\detokenize{BrownianWalkerModel:chap-brownianwalkermodel}}\label{\detokenize{BrownianWalkerModel::doc}}

\section{Minimal plasma model}
\label{\detokenize{MinimalPlasmaModel:minimal-plasma-model}}\label{\detokenize{MinimalPlasmaModel:chap-minimalplasmamodel}}\label{\detokenize{MinimalPlasmaModel::doc}}
The minimal plasma model resides in \sphinxcode{\sphinxupquote{/physics/cdr\_plasma}} and describes plasmas in the drift\sphinxhyphen{}diffusion approximation.
This physics model also includes the following subfolders:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{/physics/cdr\_plasma/plasma\_models}} which contains various implementation of some plasma models that we have used.

\item {} 
\sphinxcode{\sphinxupquote{/physics/cdr\_plasma/time\_steppers}} contains various algorithms for advancing the equations in an EBAMR context.

\item {} 
\sphinxcode{\sphinxupquote{/physics/cdr\_plasma/cell\_taggers}} contains various algorithms for advancing the equations in an EBAMR context.

\item {} 
\sphinxcode{\sphinxupquote{/physics/cdr\_plasma/python}} contains Python source files for quick setup of “mini\sphinxhyphen{}applications”.

\end{itemize}

If users decide to develop new code for the minimal plasma model, e.g. new grid refinement routines, plasma models, integrators, or other types of improvements, they should be put in the folders above.


\subsection{Equations of motion}
\label{\detokenize{MinimalPlasmaModel:equations-of-motion}}
In the minimal plasma model, we are solving
\begin{align}
&\nabla\cdot\left(\epsilon_r\nabla\Phi\right) = -\frac{\rho}{\epsilon_0}, \\[1ex]
&\frac{\partial\sigma}{\partial t} = F_\sigma,\\[1ex]
&\frac{\partial n}{\partial t} + \nabla\cdot\left(\mathbf{v} n - D\nabla n + \sqrt{2D\phi}\mathbf{Z}\right) = S,
\end{align}
where \(\sqrt{2D\phi}\mathbf{Z}\) is a stochastic diffusion flux suitable for fluctuating hydrodynamics models.
By default, this flux is turned off.

The above equations must be supported by additional boundary conditions on electrodes and insulating surfaces.

Radiative transport is also supported, which is done either in the diffusive approximation or by means of Monte Carlo methods. Diffusive RTE methods involve solving
\begin{align}
   \partial_t\Psi + \kappa\Psi - \nabla\cdot\left(\frac{1}{3\kappa}\nabla\Psi\right) &= \frac{\eta}{c},
\end{align}
where \(\Psi\) is the isotropic photon density, \(\kappa\) is an absorption length and \(\eta\) is an isotropic source term.
The time dependent term can be turned off and the equations can be solved stationary.
As an alternative, we also provide discrete photon methods that solve for the photoionization profile on a mesh by sampling discrete photons.
Our discrete photon methods are capable of including far more physics; they can easily be adapted to e.g. scattering media and also provide much better qualitative features (like shadows, for example).
They are, on the other hand, inherently stochastic which implies that some extra care must be taken when integrating the equations of motion.

The coupling that is (currently) available in \sphinxtitleref{PlasmaC} is
\begin{align}
   \epsilon_r &= \epsilon_r(\mathbf{x}), (\textrm{can additionally be discontinuous}), \\[1ex]
   \mathbf{v} &= \mathbf{v}\left(t, \mathbf{x}, \mathbf{E}, n\right), \\[1ex]
   D &= \mathbf{v}\left(t, \mathbf{x}, \mathbf{E}, n\right), \\[1ex]
   S &= S(t, \mathbf{x}, \mathbf{E}, \nabla\mathbf{E}, n, \nabla n, \Psi), \\[1ex]
   \eta &= \eta\left(t, \mathbf{x}, \mathbf{E}, n\right), \\[1ex]
   F &= F(t, \mathbf{x}, \mathbf{E}, n),
\end{align}
where \(F\) is the boundary flux on insulators or electrodes (which must be separately implemented).

\sphinxtitleref{PlasmaC} works by embedding the equations above into an abstract C++ framework that the user must implement or reuse existing pieces of, and then compile into a \sphinxstyleemphasis{mini\sphinxhyphen{}application}.


\subsection{cdr\_plasma\_physics}
\label{\detokenize{MinimalPlasmaModel:cdr-plasma-physics}}\label{\detokenize{MinimalPlasmaModel:chap-cdr-plasma-physics}}
{\hyperref[\detokenize{MinimalPlasmaModel:chap-cdr-plasma-physics}]{\sphinxcrossref{\DUrole{std,std-ref}{cdr\_plasma\_physics}}}} represents the microphysics in \sphinxcode{\sphinxupquote{/physics/cdr\_plasma}}.
The entire class is an interface, whose implementations are used in the time integrators that advance the equations.
As mentioned above, the time integrators are located in \sphinxcode{\sphinxupquote{/physics/cdr\_plasma/time\_steppers}}.

There are no default input parameters for {\hyperref[\detokenize{MinimalPlasmaModel:chap-cdr-plasma-physics}]{\sphinxcrossref{\DUrole{std,std-ref}{cdr\_plasma\_physics}}}}, as users must generally implement their own kinetics.
A successful implementation of {\hyperref[\detokenize{MinimalPlasmaModel:chap-cdr-plasma-physics}]{\sphinxcrossref{\DUrole{std,std-ref}{cdr\_plasma\_physics}}}} has the following:
\begin{itemize}
\item {} 
Instantiated {\hyperref[\detokenize{MinimalPlasmaModel:chap-species}]{\sphinxcrossref{\DUrole{std,std-ref}{species}}}}. These contain metadata for the transport solvers.

\item {} 
Instantiated {\hyperref[\detokenize{MinimalPlasmaModel:chap-photon}]{\sphinxcrossref{\DUrole{std,std-ref}{photons}}}}. These contain metadata for the radiative transport solvers.

\item {} 
Implemented the core functionality that couple all solvers.

\end{itemize}

\sphinxtitleref{PlasmaC} automatically allocates the specified number of convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction and radiative transport solvers. For information on how to interface into the CDR solvers, see {\hyperref[\detokenize{MinimalPlasmaModel:chap-species}]{\sphinxcrossref{\DUrole{std,std-ref}{species}}}}. Likewise, see {\hyperref[\detokenize{MinimalPlasmaModel:chap-photon}]{\sphinxcrossref{\DUrole{std,std-ref}{photons}}}} for how to interface into the RTE solvers.

There are currently no support for existing file formats for describing reactions and so on. If you have a huge list of reactions that need to be implemented, it would probably pay off to write a code\sphinxhyphen{}generating interface between {\hyperref[\detokenize{MinimalPlasmaModel:chap-cdr-plasma-physics}]{\sphinxcrossref{\DUrole{std,std-ref}{cdr\_plasma\_physics}}}} and your list of reactions.

Implementation of the core functionality is comparatively straightforward. In the constructor, the user should fetch his input parameters (if he has any) and \sphinxstylestrong{must} instantiate all species and photons in the internal containers. When the class is used by \sphinxtitleref{PlasmaC} later on, all arguments in the core functions follow that ordering. The core functionality is given by the following functions:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RealVect}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}cdr\PYGZus{}velocities}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}cdr\PYGZus{}diffusion\PYGZus{}coefficients}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                                        \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                                        \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                                        \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}cdr\PYGZus{}source\PYGZus{}terms}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}              \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                              \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                              \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                              \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}gradE}\PYG{p}{,}
                                              \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{,}
                                              \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}rte\PYGZus{}densities}\PYG{p}{,}
                                              \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RealVect}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}grad\PYGZus{}cdr}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}cdr\PYGZus{}electrode\PYGZus{}fluxes}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                                  \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                                  \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}normal}\PYG{p}{,}
                                                  \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                                  \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{,}
                                                  \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}velocities}\PYG{p}{,}
                                                  \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}gradients}\PYG{p}{,}
                                                  \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}rte\PYGZus{}fluxes}\PYG{p}{,}
                                                  \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}extrap\PYGZus{}cdr\PYGZus{}fluxes}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}cdr\PYGZus{}dielectric\PYGZus{}fluxes}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                                   \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                                   \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}normal}\PYG{p}{,}
                                                   \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                                   \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{,}
                                                   \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}velocities}\PYG{p}{,}
                                                   \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}gradients}\PYG{p}{,}
                                                   \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}rte\PYGZus{}fluxes}\PYG{p}{,}
                                                   \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}extrap\PYGZus{}cdr\PYGZus{}fluxes}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}cdr\PYGZus{}domain\PYGZus{}fluxes}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}\PYG{o}{\PYGZam{}}           \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}       \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{k+kt}{int}\PYG{o}{\PYGZam{}}            \PYG{n}{a\PYGZus{}dir}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{Side}\PYG{o}{:}\PYG{o}{:}\PYG{n}{LoHiSide}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}side}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}       \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}   \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}   \PYG{n}{a\PYGZus{}cdr\PYGZus{}velocities}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}   \PYG{n}{a\PYGZus{}cdr\PYGZus{}gradients}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}   \PYG{n}{a\PYGZus{}rte\PYGZus{}fluxes}\PYG{p}{,}
                                               \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}   \PYG{n}{a\PYGZus{}extrap\PYGZus{}cdr\PYGZus{}fluxes}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}rte\PYGZus{}source\PYGZus{}terms}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                              \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                              \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                              \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{k}{virtual} \PYG{n}{Real} \PYG{n+nf}{initial\PYGZus{}sigma}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}      \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                           \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

The above code blocks do exactly what their signatures indicate. It is up to the user to implement these. The length of the Vector holding the return values from these functions are expected to be equal to the number of CDR solvers, with the exception of \sphinxstyleemphasis{compute\_rte\_source\_terms} which has the length given by the number of RTE solvers. Note that in all of the above, the ordering of the input vectors are expected to be the same as the ordering of the species vector of {\hyperref[\detokenize{MinimalPlasmaModel:chap-cdr-plasma-physics}]{\sphinxcrossref{\DUrole{std,std-ref}{cdr\_plasma\_physics}}}}.

For example, if the user has defined only a single advected species, he may implement the constructor as

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{my\PYGZus{}kinetics}\PYG{o}{:}\PYG{o}{:}\PYG{n}{my\PYGZus{}kinetics}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}
   \PYG{n}{m\PYGZus{}num\PYGZus{}species} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
   \PYG{n}{m\PYGZus{}num\PYGZus{}photons} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}

   \PYG{n}{m\PYGZus{}species}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{m\PYGZus{}num\PYGZus{}species}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{m\PYGZus{}photons}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{m\PYGZus{}num\PYGZus{}photons}\PYG{p}{)}\PYG{p}{;}

   \PYG{n}{m\PYGZus{}species}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{species}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{new} \PYG{n}{my\PYGZus{}species}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{m\PYGZus{}photons}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{RefCountedPtr}\PYG{o}{\PYGZlt{}}\PYG{n}{photon}\PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{new} \PYG{n}{my\PYGZus{}photon}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This constructor assumes that \sphinxstyleemphasis{my\_species} has already been defined somewhere (for example, as a private class within \sphinxstyleemphasis{my\_kinetics}).


\subsubsection{Defining drift velocities}
\label{\detokenize{MinimalPlasmaModel:defining-drift-velocities}}
Next the user may implement the velocity computation function, which sets \(\mathbf{v}\) in the CDR equations:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RealVect}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}cdr\PYGZus{}velocities}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                        \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                        \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                        \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
   \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RealVect}\PYG{o}{\PYGZgt{}} \PYG{n}{velo}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{velo}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a\PYGZus{}E}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{velo}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This implementation is a full implementation of the velocity coupling of the CDR equations. In this case, the velocity of the advected component is equal to \(\mathbf{E}\). For a full plasma simulation, there will also be mobilities involved, which the user is reponsible for obtaining.


\subsubsection{Defining diffusion coefficients}
\label{\detokenize{MinimalPlasmaModel:defining-diffusion-coefficients}}
In order to define diffusion coefficients, the user implements \sphinxstyleemphasis{compute\_cdr\_diffusion\_coefficients}, which returns the diffusion coefficients for the diffused species. If a species (e.g. positive ions) is not diffusive, it does not matter what diffusion coefficient you set.

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}cdr\PYGZus{}diffusion\PYGZus{}coefficients}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                                \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
   \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{diffco}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{diffco}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{diffco}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Defining chemistry terms}
\label{\detokenize{MinimalPlasmaModel:defining-chemistry-terms}}
The function \sphinxstyleemphasis{compute\_cdr\_source\_terms} is reponsible for computing \(S\) in the CDR equations. If we want, for example, \(S_1 = k n_1n_2\), where \(k\) is some rate and \(n_1\) and \(n_2\) are densities of some species (e.g. electrons and positive ions),

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}cdr\PYGZus{}source\PYGZus{}terms}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}              \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                      \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                      \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                      \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}gradE}\PYG{p}{,}
                                      \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{,}
                                      \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}rte\PYGZus{}densities}\PYG{p}{,}
                                      \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{RealVect}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}grad\PYGZus{}cdr}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
   \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{source}\PYG{p}{(}\PYG{n}{m\PYGZus{}num\PYGZus{}species}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{source}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{k}\PYG{o}{*}\PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{source}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

In the above function, the user may also implement photoionization: The argument \sphinxstyleemphasis{Vector\textless{}Real\textgreater{} a\_rte\_densities} is the isotropic photon densities, i.e. the number of photons per unit volume.


\subsubsection{Defining photon production terms}
\label{\detokenize{MinimalPlasmaModel:defining-photon-production-terms}}
Reverse coupling between the CDR equations and the RTE equations occur through the \sphinxstyleemphasis{compute\_rte\_source\_terms} function. The return value of this function is the mean number of photons produced per steradian. Often, such functions may be complicated. If we assume, for example, that the RTE source term is \(\eta = n/\tau\), where \(\tau\) is a spontaneous emission lifetime, then we can implement the coupling as

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}rte\PYGZus{}source\PYGZus{}terms}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                      \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                      \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                      \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
   \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{source}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{source}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{/}\PYG{n}{tau}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{source}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{Generally}\PYG{p}{,} \PYG{n}{one} \PYG{n}{wants} \PYG{n}{to} \PYG{n}{ensure} \PYG{n}{consistency} \PYG{n}{in} \PYG{n}{how} \PYG{n}{one} \PYG{n}{handles} \PYG{n}{photon} \PYG{n}{production} \PYG{n}{and} \PYG{n}{excited} \PYG{n}{state} \PYG{n}{relaxation}\PYG{p}{.} \PYG{n}{For} \PYG{n}{the} \PYG{n}{above} \PYG{n}{radiative} \PYG{n}{transfer} \PYG{n}{example}\PYG{p}{,} \PYG{n}{the} \PYG{n}{user} \PYG{n}{should} \PYG{n}{also} \PYG{n}{include} \PYG{n}{a} \PYG{n}{corresponding} \PYG{n}{term} \PYG{n}{in} \PYG{n}{the} \PYG{n}{function} \PYG{n}{that} \PYG{n}{computes} \PYG{n}{the} \PYG{n}{chemistry} \PYG{n}{source} \PYG{n}{terms}\PYG{p}{.}
\end{sphinxVerbatim}


\subsubsection{Setting transport boundary conditions}
\label{\detokenize{MinimalPlasmaModel:setting-transport-boundary-conditions}}
Boundary conditions are support through three functions that handle transport through three types of boundaries: domain boundaries, dielectric surfaces, and electrode surfaces. The three functions have (almost) the same signature:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{compute\PYGZus{}cdr\PYGZus{}electrode\PYGZus{}fluxes}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}\PYG{o}{\PYGZam{}}         \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                                          \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}pos}\PYG{p}{,}
                                          \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}normal}\PYG{p}{,}
                                          \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}}     \PYG{n}{a\PYGZus{}E}\PYG{p}{,}
                                          \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}densities}\PYG{p}{,}
                                          \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}velocities}\PYG{p}{,}
                                          \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}cdr\PYGZus{}gradients}\PYG{p}{,}
                                          \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}rte\PYGZus{}fluxes}\PYG{p}{,}
                                          \PYG{k}{const} \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}extrap\PYGZus{}cdr\PYGZus{}fluxes}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
   \PYG{n}{Vector}\PYG{o}{\PYGZlt{}}\PYG{n}{Real}\PYG{o}{\PYGZgt{}} \PYG{n}{fluxes}\PYG{p}{(}\PYG{n}{m\PYGZus{}num\PYGZus{}species}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{)}\PYG{p}{;}
   \PYG{k}{return} \PYG{n}{fluxes}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

This function expects you to return the transport fluxes at the boundaries \sphinxhyphen{} like those occuring in a finite volume context. For domain boundaries, this signature is slightly changed: The argument \sphinxcode{\sphinxupquote{a\_normal}} (which is the normal vector \sphinxstyleemphasis{into} the gas volume) is replaced by two arguments that describe the side and direction of the domain wall. The \sphinxcode{\sphinxupquote{a\_normal}} is the normal into the gas volume, which is opposite to the convention used in finite volume formulations. The arguments \sphinxcode{\sphinxupquote{a\_cdr\_velocities}} are the drift velocities projected on the outward normal, and the same convention is used for \sphinxcode{\sphinxupquote{a\_cdr\_gradients}} (which hold the spatial gradients) and \sphinxcode{\sphinxupquote{a\_extrap\_cdr\_fluxes}} which hold the extrapolated drift fluxes. If you want simple extrapolated boundary conditions you would set one of the fluxes equal to \sphinxcode{\sphinxupquote{a\_extrap\_cdr\_fluxes}}. A small caveat: \sphinxcode{\sphinxupquote{a\_extrap\_cdr\_fluxes}} are the extrapolated \sphinxstyleemphasis{drift} fluxes; if you also want the diffusive flux you can use the gradient argument and recompute the diffusion coefficient.


\subsubsection{Setting initial surface charge}
\label{\detokenize{MinimalPlasmaModel:setting-initial-surface-charge}}
Finally, the final function specifies the initial surface charge in the domain. If there is no initial surface charge, then

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n+nf}{initial\PYGZus{}sigma}\PYG{p}{(}\PYG{k}{const} \PYG{n}{Real}      \PYG{n}{a\PYGZus{}time}\PYG{p}{,}
                   \PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{l+m+mf}{0.0}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{species}
\label{\detokenize{MinimalPlasmaModel:species}}\label{\detokenize{MinimalPlasmaModel:chap-species}}
The {\hyperref[\detokenize{MinimalPlasmaModel:chap-species}]{\sphinxcrossref{\DUrole{std,std-ref}{species}}}} is a lightweight class used to provide information into convection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction solvers. This class is mostly used within {\hyperref[\detokenize{MinimalPlasmaModel:chap-cdr-plasma-physics}]{\sphinxcrossref{\DUrole{std,std-ref}{cdr\_plasma\_physics}}}} in order to provide information on how to instantiate CDR solvers. {\hyperref[\detokenize{MinimalPlasmaModel:chap-species}]{\sphinxcrossref{\DUrole{std,std-ref}{species}}}} is abstract so that the user must implement

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{virtual} \PYG{n}{Real} \PYG{n+nf}{initial\PYGZus{}data}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

This function specifies the initial data of the species that is advected. For example, the following implementation sets the initial CDR density value to one:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{Real} \PYG{n+nf}{initial\PYGZus{}data}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{l+m+mf}{1.0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

In addition to this, the user \sphinxstyleemphasis{must} provide information on the charge of the species, and whether or not it is mobile or diffusive. In addition, he should set the name of the species so that it can be identified in output files. In \sphinxtitleref{PlasmaC}, this is done by setting the following four values in the constructor

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{m\PYGZus{}name}\PYG{p}{;} \PYG{c+c1}{// Solver name}
\PYG{k+kt}{int} \PYG{n}{m\PYGZus{}charge}\PYG{p}{;}       \PYG{c+c1}{// Charge (in units of the elementary charge)}
\PYG{k+kt}{bool} \PYG{n}{m\PYGZus{}diffusive}\PYG{p}{;}   \PYG{c+c1}{// Diffusive species or not}
\PYG{k+kt}{bool} \PYG{n}{m\PYGZus{}mobile}\PYG{p}{;}      \PYG{c+c1}{// Mobile species or not}
\end{sphinxVerbatim}

Usually, these are set through the constructor. The \sphinxcode{\sphinxupquote{m\_charge}} unit is in units of the elementary charge. For example, the following is a full implementation of an electron species:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{class} \PYG{n+nc}{electron} \PYG{o}{:} \PYG{k}{public} \PYG{n}{species} \PYG{p}{\PYGZob{}}
  \PYG{n}{electron}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
     \PYG{n}{m\PYGZus{}name}   \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{electrons}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
     \PYG{n}{m\PYGZus{}charge} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
     \PYG{n}{m\PYGZus{}diffusive} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
     \PYG{n}{m\PYGZus{}mobile} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{o}{\PYGZti{}}\PYG{n}{electron}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

  \PYG{n}{Real} \PYG{n}{initial\PYGZus{}data}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect} \PYG{n}{a\PYGZus{}pos}\PYG{p}{,} \PYG{k}{const} \PYG{n}{Real} \PYG{n}{a\PYGZus{}time}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
     \PYG{k}{return} \PYG{l+m+mf}{1.0}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

The members \sphinxcode{\sphinxupquote{m\_mobile}} and \sphinxcode{\sphinxupquote{m\_diffusive}} are used for optimization in \sphinxtitleref{PlasmaC}: If the user specifies that a species is immobile, \sphinxtitleref{PlasmaC} will skip the advection computation. Note that \sphinxcode{\sphinxupquote{m\_diffusive}} and \sphinxcode{\sphinxupquote{m\_mobile}} override the specifications in {\hyperref[\detokenize{MinimalPlasmaModel:chap-cdr-plasma-physics}]{\sphinxcrossref{\DUrole{std,std-ref}{cdr\_plasma\_physics}}}}. If the user provides a non\sphinxhyphen{}zero velocity through {\hyperref[\detokenize{MinimalPlasmaModel:chap-cdr-plasma-physics}]{\sphinxcrossref{\DUrole{std,std-ref}{cdr\_plasma\_physics}}}} function \sphinxstyleemphasis{compute\_cdr\_velocities}, and sets \sphinxcode{\sphinxupquote{m\_mobile}} to \sphinxcode{\sphinxupquote{false}}, the species velocity will be zero. Of course, the user will often want to provide additional input information to his species, for example by specifying a seed for the initial conditions.


\subsubsection{photons}
\label{\detokenize{MinimalPlasmaModel:photons}}\label{\detokenize{MinimalPlasmaModel:chap-photon}}
{\hyperref[\detokenize{MinimalPlasmaModel:chap-photon}]{\sphinxcrossref{\DUrole{std,std-ref}{photons}}}} is the class that supplies extra information to the RTE solvers. In those solvers, the source term computation is handled by {\hyperref[\detokenize{MinimalPlasmaModel:chap-cdr-plasma-physics}]{\sphinxcrossref{\DUrole{std,std-ref}{cdr\_plasma\_physics}}}}, so the {\hyperref[\detokenize{MinimalPlasmaModel:chap-photon}]{\sphinxcrossref{\DUrole{std,std-ref}{photons}}}} class is very lightweight. The user must implement a single function which specifies the absorption coefficient at a point in space:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{virtual} \PYG{k}{const} \PYG{n}{Real} \PYG{n+nf}{get\PYGZus{}absorption\PYGZus{}coeff}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)} \PYG{k}{const} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}

In addition, the user should provide a name for the RTE solver so that it can be identified in the output files. This is done by setting a \sphinxcode{\sphinxupquote{m\_name}} attribute in the {\hyperref[\detokenize{MinimalPlasmaModel:chap-photon}]{\sphinxcrossref{\DUrole{std,std-ref}{photons}}}} class.

The following is a full implementation of the {\hyperref[\detokenize{MinimalPlasmaModel:chap-photon}]{\sphinxcrossref{\DUrole{std,std-ref}{photons}}}} class:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{k}{class} \PYG{n+nc}{my\PYGZus{}photon} \PYG{o}{:} \PYG{k}{public} \PYG{n}{photon} \PYG{p}{\PYGZob{}}
  \PYG{n}{my\PYGZus{}photon}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
     \PYG{n}{m\PYGZus{}name} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{my\PYGZus{}photon}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}

  \PYG{o}{\PYGZti{}}\PYG{n}{my\PYGZus{}photon}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

  \PYG{k}{const} \PYG{n}{Real} \PYG{n}{get\PYGZus{}absorption\PYGZus{}coeff}\PYG{p}{(}\PYG{k}{const} \PYG{n}{RealVect}\PYG{o}{\PYGZam{}} \PYG{n}{a\PYGZus{}pos}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
     \PYG{k}{return} \PYG{l+m+mf}{1.0}\PYG{p}{;}
  \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

By default, there are no input parameters available for the {\hyperref[\detokenize{MinimalPlasmaModel:chap-photon}]{\sphinxcrossref{\DUrole{std,std-ref}{photons}}}} class, but the user will often want to include these, for example by modifying the absorption coefficient. Note that you are allowed to use a spatially varying absorption coefficient.

For most users, this will mostly include implementing a new geometry or a new plasma\sphinxhyphen{}kinetic scheme.
It is possible to generate entirely new physics interfaces, too.
Our goal is that the user does not need to worry about temporal or spatial discretization of these equations, but rather focus on the actual setup of the geometry and physics.


\subsection{Temporal discretization}
\label{\detokenize{MinimalPlasmaModel:temporal-discretization}}
In this chapter we discuss the supported temporal integrators for \sphinxtitleref{PlasmaC}, and discuss their input parameters. These integrators differ in their level of efficiency and accuracy. Currently, none of the integrators can subcycle in time.


\subsection{Time step limitations}
\label{\detokenize{MinimalPlasmaModel:time-step-limitations}}
Our time integrators have different time step limitations. Fully explicit codes are limited by the advective and diffusive CFL constraints and usually also the dielectric relaxation time. However, some of the \sphinxtitleref{PlasmaC} integrators eliminate the dielectric relaxation time, and all integrators can handle diffusion either implicitly or explicitly. In some cases only the advective CFL constraint is the only time step restriction.


\subsection{Deterministic integrators}
\label{\detokenize{MinimalPlasmaModel:deterministic-integrators}}

\subsubsection{godunov}
\label{\detokenize{MinimalPlasmaModel:godunov}}\label{\detokenize{MinimalPlasmaModel:chap-godunov}}
The \sphinxcode{\sphinxupquote{godunov}} temporal integrator is a rather unsophisticated, but very stable, temporal integrator. \sphinxcode{\sphinxupquote{godunov}} uses an operator splitting between charge transport and plasma chemistry in the following way:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
Advance \(\partial_t\phi = -\nabla\cdot\left(\mathbf{v}\phi - D\nabla\phi + \sqrt{2D\phi}\mathbf{Z}\right)\) (and the surface charge solver) over a time step \(\Delta t\).

\item {} 
Compute the electric field

\item {} 
Advance the plasma chemistry over the same time step using the field computed in 2). I.e. advance \(\partial_t\phi = S\) over a time step \(\Delta t\).

\item {} 
Move photons and deposit them on the mesh.

\end{enumerate}

Various integration options for the transport and chemistry steps are available but are discussed elsewhere. Note that the \sphinxcode{\sphinxupquote{godunov}} integrator uses a semi\sphinxhyphen{}implicit coupling between the plasma chemistry terms and the electric field, and therefore eliminates the so\sphinxhyphen{}called dielectric relaxation time. The formal order of convergence of the \sphinxcode{\sphinxupquote{godunov}} integrator is 1, but the accuracy can be quite good depending on the transport and chemistry schemes that are chosen.


\subsubsection{imex sdc}
\label{\detokenize{MinimalPlasmaModel:imex-sdc}}\label{\detokenize{MinimalPlasmaModel:chap-sisdc}}
\sphinxcode{\sphinxupquote{imex\_sdc}} is a semi\sphinxhyphen{}implicit spectral deferred correction method for the \sphinxtitleref{PlasmaC} equation set and is an adaptive high\sphinxhyphen{}order discretization with implicit diffusion. This method integrates the advection\sphinxhyphen{}diffusion\sphinxhyphen{}reaction equations in the following way.


\paragraph{Spectral deferred corrections}
\label{\detokenize{MinimalPlasmaModel:spectral-deferred-corrections}}
Given an ordinary differential equation (ODE) as
\begin{equation*}
\begin{split}\frac{\partial u}{\partial t} = F(u,t), \quad u(t_0) = u_0,\end{split}
\end{equation*}
the exact solution is
\begin{equation*}
\begin{split}u(t) = u_0 + \int_{t_0}^tF\left(u,\tau\right)d\tau.\end{split}
\end{equation*}
Denote an approximation to this solution by \(\widetilde{u}(t)\) and the correction by \(\delta(t) = u(t) - \widetilde{u}(t)\). The measure of error in \(\widetilde{u}(t)\) is then
\begin{equation*}
\begin{split}R(\widetilde{u}, t) = u_0 + \int_{t_0}^tF(\widetilde{u}, \tau)d\tau - \widetilde{u}(t).\end{split}
\end{equation*}
Equivalently, since \(u = \widetilde{u} + \delta\), we can write
\begin{equation*}
\begin{split}\widetilde{u} + \delta = u_0 + \int_{t_0}^t F\left(\widetilde{u}+\delta, \tau\right)d\tau.\end{split}
\end{equation*}
This yields
\begin{equation*}
\begin{split}\delta = \int_{t_0}^t\left[F\left(\widetilde{u}+\delta, \tau\right) - F\left(\widetilde{u}, \tau\right)\right]d\tau + R\left(\widetilde{u},t\right).\end{split}
\end{equation*}
This is called the correction equation. The goal of SDC is to iteratively solve this equation in order to provide a high\sphinxhyphen{}order discretization.

We now discuss the semi\sphinxhyphen{}implicit SDC (SISDC) method. First, we apply the method of lines (MOL) such that
\begin{align}
\frac{d\phi_{\mathbf{i}}}{dt} &= \mathcal{F}_{\textrm{AR}}\left(t, \phi_{\mathbf{i}}\right) + \mathcal{F}_{\textrm{D}}\left(t, \phi_{\mathbf{i}}; \mathbf{E}_{\mathbf{i}}\right), \\
\frac{d\sigma_{\mathbf{i}}}{dt} &= \mathcal{F}_{\sigma}\left(t, \phi_{\mathbf{i}}\right),
\end{align}
where \(\phi_{\mathbf{i}}\) denotes a cell\sphinxhyphen{}averaged variable, \(\mathcal{F}_{\sigma}\) is as described in {\hyperref[\detokenize{Model:chap-spatialdiscretization}]{\sphinxcrossref{\DUrole{std,std-ref}{Spatial discretization}}}}, \(\mathcal{F}_{\textrm{AR}}\left(t, \phi_{\mathbf{i}}\right) = -D^c_{\mathbf{i}} + S_{\mathbf{i}}\) is the advection\sphinxhyphen{}reaction operator , and \(\mathcal{F}_{\textrm{D}}(t, \phi_{\mathbf{i}}; \mathbf{E}_{\mathbf{i}}) = \frac{1}{\kappa_{\mathbf{i}}}\int_{V_{\mathbf{i}}}\left[\nabla\cdot\left(D\nabla\phi\right)\right]dV_{\mathbf{i}}\) is the diffusion operator. Note that the advective operator contains the hybrid divergence discussed in {\hyperref[\detokenize{CDR:chap-cdr}]{\sphinxcrossref{\DUrole{std,std-ref}{Convection\sphinxhyphen{}Diffusion\sphinxhyphen{}Reaction}}}} and \(\mathcal{F}_{\textrm{D}}\) is parametrically coupled to \(\mathbf{E}\) through \(D = D\left(\mathbf{E}\right)\) (we use a semi\sphinxhyphen{}colon to indicate this dependence). Strictly speaking, \(\mathcal{F}_{\textrm{AR}}\) is parametrically coupled in the same way through the  mobilities and boundary conditions, and additionally coupled to \(\Psi\) through source terms so that the notation \(\mathcal{F}_{\textrm{AR}}\left(t, \phi_{\mathbf{i}}; \mathbf{E}_{\mathbf{i}}, \Psi_{\mathbf{i}}\right)\) would be appropriate. However, charge injection, advection, and chemistry will be integrated explicitly so this dependence is notationally suppressed. On the other hand, the diffusion part will be solved with the backward Euler method \sphinxhyphen{} which yields a Helmholtz equation \sphinxhyphen{} and so we need to maintain this dependence for now. Later, we will clarify how this dependence is resolved. The rationale for solving diffusion implicitly is due to the numerical time step constraint of explicit diffusion methods which scales as \(\mathcal{O}\left(\Delta x^2\right)\), whereas advection scales more favorably at \(\mathcal{O}\left(\Delta x\right)\). We have chosen to integrate the reactive terms explicitly. The reason is that the reactive terms can be non\sphinxhyphen{}local, i.e. they can depend on the electron gradient. This is for example the case for fluid models in the local energy approximation where the electron energy source term contains terms that are proportional to the electron diffusion term \(D_e\nabla\phi_e\). Implicit discretization of the reactive terms then yield a fully coupled system rather than systems coupled only within individual cells. Charge injection is also handled explicitly. This design choice is mandated by the fact that implicit charge injection through the diffusion terms couples every diffusive species, leading to a system of diffusion equations that are fully coupled through their boundary conditions. Although charge injection could reasonably be performed as a separate step, this leads to numerical instabilities for cut\sphinxhyphen{}cell methods since the injected charge must be normalized by the volume fraction of the cell (which can be arbitrarily small).


\paragraph{SISDC predictor}
\label{\detokenize{MinimalPlasmaModel:sisdc-predictor}}
Next, we present the SISDC method. In what follows, we suppress the index \({\mathbf{i}}\) as it is not explicitly needed. Given an interval \([t_n, t_{n+1}]\) on which a solution is sought, SDC methods divide this interval into \(p\) subintervals \(t_n = t_{n,0} < t_{n,1} < \ldots < t_{n,p} = t_{n+1}\). Our discussion, however, pertains only to the interval \([t_n, t_{n+1}]\) so we compress the notation to \(t_m\equiv t_{n,m}\). We obtain an initial solution \(\phi_{m}^0, m=0,1,\ldots,p\) as the semi\sphinxhyphen{}implicit advance
\begin{align}
\phi_{m+1}^0 &= \phi_m^0 + \Delta t_m\left[\mathcal{F}_{\textrm{AR}}\left(t_m,\phi_m^0\right) + \mathcal{F}_{\textrm{D}}\left(t_{m+1},\phi_{m+1}^0; \mathbf{E}_{m+1}^0\right)\right],\\
\sigma_{m+1}^0 &= \sigma_m^0 + \Delta t_mF_\sigma\left(t_m,\phi_m^0\right).
\end{align}
This defines a Helmholtz problem for \(\phi_{m+1}^0\) through \(\mathcal{F}_{\textrm{D}}\). Generally, the upper subscript denotes an SDC iteration where subscript 0 is the SISDC predictor, and we also have \(\phi_0^0 = \phi(t_n)\) and \(\sigma_0^0 = \sigma(t_n)\). This predictor treats advection and chemistry terms explicitly, and diffusion implicitly. Other types of semi\sphinxhyphen{}implicit or multi\sphinxhyphen{}implicit couplings are possible \sphinxcite{References:bourlioux2003}\sphinxcite{References:layton2004}\sphinxcite{References:nonaka2012}. SDC improves this solution by using deferred corrections: Given a numerical solution \(\phi_{m+1}^k\), we compute an error \(\delta_{m+1}^k\) and obtain the next iterate \(\phi_{m+1}^{k+1} = \phi_{m+1}^k + \delta_{m+1}^k\). Each iteration raises the discretization order by one \sphinxcite{References:dutt2000}\sphinxcite{References:minion2003}, to maximum order \(p+1\). Critical to the success of this approach is the precise evaluation of the numerical quadrature.

The parametric coupling of the electric field complicates things since the predictor contains \(\mathbf{E}_{m+1}^0 = \mathbf{E}\left(\phi_{m+1}^0\right)\), implying that the Poisson equation and the diffusion advance require concurrent solves for the diffusion update. We simplify this system by using a weak coupling by first computing
\begin{align}
\phi_{m+1}^{0,\ast} &= \phi_m^0 + \Delta t_m\mathcal{F}_{\textrm{AR}}\left(t_m, \phi_m^0\right), \\
\sigma_{m+1}^0 &= \sigma_m^0 + \Delta t_mF_\sigma\left(t_m, \phi_m^0\right),
\end{align}
Next, we will approximate \(\mathbf{E}_{m+1}^{0}\) for use in the predictor. There are two choices for this coupling; one may either use \(\mathbf{E}_m^0\) for computation of the diffusion coefficients, which we will refer to as the semi\sphinxhyphen{}implicit coupling, or one may use fixed\sphinxhyphen{}point iteration and compute \(\mathbf{E}_{m+1}^{0,\ast} = \mathbf{E}\left(\phi_{m+1}^{0, \ast}, \sigma_{m+1}^0\right)\), followed by the diffusion advance
\begin{equation*}
\begin{split}\phi_{m+1}^{0,\dagger} = \phi_{m+1}^{0,\ast} + \Delta t_m\mathcal{F}_{\textrm{D}}\left(t_{m+1}, \phi_{m+1}^0; \mathbf{E}_{m+1}^\ast\right),\end{split}
\end{equation*}
which we will refer to as the implicit coupling. This is e.g. the electric field coupling used in \sphinxcite{References:marskar2019}. This approximation can be improved by using more fixed\sphinxhyphen{}point iterations that computes \(\mathbf{E}_{m+1}^{0,\dagger} = \mathbf{E}\left(\phi_{m+1}^{0,\dagger}, \sigma_{m+1}^0\right)\) and then re\sphinxhyphen{}solves the predictor equation with \(\mathbf{E}_{m+1}^{0,\dagger}\) in place of \(\mathbf{E}_{m+1}^{0,\ast}\). The process can then be repeated for increased accuracy. Regardless of which coupling is used, we have now calculated \(\phi_{m+1}^0\), \(\sigma_{m+1}^0\), through which we obtain \(\mathbf{E}_{m+1}^0 = \mathbf{E}\left(\phi_{m+1}^0, \sigma_{m+1}^0\right)\), and \(\Psi_{m+1}^0 = \Psi\left(\mathbf{E}_{m+1}^0, \phi_{m+1}^0\right)\). Finally, we remark that the SISDC predictor is a sequentially advanced semi\sphinxhyphen{}implicit Euler method, which is locally second order accurate and globally first order accurate. Each step of the predictor can be thought of as a Godunov splitting between the advective\sphinxhyphen{}reactive and diffusive terms.


\paragraph{SISDC corrector}
\label{\detokenize{MinimalPlasmaModel:sisdc-corrector}}
Next, the semi\sphinxhyphen{}implicit discretization of the correction equation is
\begin{equation*}
\begin{split}\begin{split}
\delta_{m+1}^k &= \delta_m^k  + \Delta t_m\left[\mathcal{F}_{\textrm{AR}}\left(t_m, \phi_m^k + \delta_m^k\right) - \mathcal{F}_{\textrm{AR}}\left(t_m, \phi_m^k\right)\right.\\
&+ \left.\mathcal{F}_{\textrm{D}}\left(t_{m+1}, \phi_{m+1}^k + \delta_{m+1}^k; \mathbf{E}_{m+1}^k\right) - \mathcal{F}_{\textrm{D}}\left(t_{m+1}, \phi_{m+1}^k; \mathbf{E}_{m+1}^k\right)\right] - \left(R_{m+1}^k - R_{m}^k\right).
\end{split}\end{split}
\end{equation*}
We furthermore define
\begin{equation*}
\begin{split}\begin{split}
R_{m+1}^k - R_m^k &= \int_{t_m}^{t_{m+1}}\left[\mathcal{F}_{\textrm{AR}}\left(\phi^k\right) + \mathcal{F}_{\textrm{D}}\left(\phi^k; \mathbf{E}^k\right)\right]d\tau - \phi_{m+1}^k + \phi_m^k \\
&\equiv I_m^{m+1}\left(\phi^k\right) - \phi_{m+1}^k + \phi_m^k.
\end{split}\end{split}
\end{equation*}
Evaluation of \(I_m^{m+1}\) yields \(p\) quadrature rules and we may write
\begin{equation*}
\begin{split}I_m^{m+1}\left(\phi^k\right) = \sum_{l=0}^p q_m^l\left[\mathcal{F}_{\textrm{AR}}\left(t_l, \phi^k_l\right) + \mathcal{F}_{\textrm{D}}\left(t_l, \phi^k_l; \mathbf{E}_l^k\right)\right],\end{split}
\end{equation*}
where the weights \(q_m^l\) are quadrature weights. The final update for \(\phi^{k+1}_{m+1}\) is then
\begin{equation*}
\begin{split}\begin{split}
\phi_{m+1}^{k+1} &= \phi_{m}^{k+1} + \Delta t_m\left[\mathcal{F}_{\textrm{AR}}\left(t_m, \phi_m^{k+1}\right) -\mathcal{F}_{\textrm{AR}}\left(t_m, \phi_m^{k}\right)\right.\\
& + \left.\mathcal{F}_{\textrm{D}}\left(t_{m+1}, \phi_{m+1}^{k+1}; \phi_{m+1}^{k+1}\right) - \mathcal{F}_{\textrm{D}}\left(t_{m+1}, \phi_{m+1}^{k}; \mathbf{E}_{m+1}^k\right)\right] + I_{m}^{m+1}\left(\phi^k\right).
\end{split}\end{split}
\end{equation*}
With the exception of \(\mathcal{F}_{\textrm{D}}\left(t_{m+1}, \phi_{m+1}^{k+1}; \mathbf{E}_{m+1}^{k+1}\right)\), all quantities on the right\sphinxhyphen{}hand are known and the correction equation is reduced to a Helmholtz equation for \(\phi_{m+1}^{k+1}\) with error \(\delta_{m+1}^k = \phi_{m+1}^{k+1} - \phi_{m+1}^k\). An analogous equation is found for \(\sigma_{m+1}^{k+1}\).

The correction step has the same coupling to the electric field as the prediction step in that \(\mathbf{E}_{m+1}^{k+1}\) appears in the update equation for \(\phi_{m+1}^{k+1}\). As for the prediction, we use a weak coupling through which we first compute
\begin{align}
\phi_{m+1}^{k+1,\ast} &= \phi_m^{k+1} + \Delta t_m\left[\mathcal{F}_{\textrm{AR}}\left(t_m, \phi_m^{k+1}\right) - \mathcal{F}_{\textrm{AR}}\left(t_m, \phi_m^{k}\right)\right] + I_m^{m+1}\left(\phi^k\right),\\
\sigma_{m+1}^{k+1} &= \sigma_m^{k+1} + \Delta t_m\left[F_\sigma\left(t_m, \phi_m^{k+1}\right) - F_\sigma\left(t_m, \phi_m^{k}\right)\right] + \Sigma_m^{m+1}\left(\phi^k\right).
\end{align}
The solution for \(\sigma_{m+1}^{k+1}\) is final since all charge is injected through the advection operator for \(\phi\). The term \(\Sigma_m^{m+1}\) contains the injected charge through \(I_m^{m+1}\left(\phi^k\right)\), as was discussed in {\hyperref[\detokenize{Model:chap-spatialdiscretization}]{\sphinxcrossref{\DUrole{std,std-ref}{Spatial discretization}}}}. We then solve
\begin{equation*}
\begin{split}\phi_{m+1}^{k+1} = \phi_{m+1}^{k+1, \ast} + \Delta t_m\left[\mathcal{F}_{\textrm{D}}\left(t_{m+1}, \phi_{m+1}^{k+1}; \mathbf{E}_{m+1}^{k+1}\right) - \mathcal{F}_{\textrm{D}}\left(t_{m+1}, \phi_{m+1}^{k}; \mathbf{E}_{m+1}^k\right)\right],\end{split}
\end{equation*}
with some approximation for \(\mathbf{E}_{m+1}^{k+1}\). As before, this coupling can be made either semi\sphinxhyphen{}implicitly or implicitly. The corrector equation defines a Helmholtz equation for \(\phi_{m+1}^{k+1}\) using \(\phi_{m+1}^{k+1,\ast}\) as the previous solution and \(-\mathcal{F}_{\textrm{D}}\left(\phi_{m+1}^{k}; \mathbf{E}_{m+1}^k\right)\) as a source term.


\paragraph{Order, stability, and computational cost}
\label{\detokenize{MinimalPlasmaModel:order-stability-and-computational-cost}}
For consistency with the literature, denote the SISDC method which uses \(P\) nodes (i.e. \(P-1\) subintervals) and \(K\) total iterations (i.e. \(K-1\) iterations of the correction equation) by \(\verb|SISDC|_P^K\). This method will have a global order of accuracy \(\min\left(K,P\right)\) if the quadrature can be evaluated with appropriate accuracy. Order reductions may occur if the interpolating polynomial in the quadrature suffers from Runge’s phenomenon. As we discuss below, uniformly spaced nodes have some computational advantage but is therefore also associated with some risk. Safer choices include Lobatto nodes or Chebyshev nodes (with inclusion of endpoints) to minimize the risk of order reductions. Implications on the choice of quadrature nodes can be found in \sphinxcite{References:layton2005}.

For explicit advection, the deferred correction procedure integrates the correction equation sequentially and therefore does not allow each substep \(\Delta t_m\) to exceed the CFL\sphinxhyphen{}limited time step \(\Delta t_{\textrm{cfl}}\), i.e. \(\Delta t_m < \Delta t_{\textrm{cfl}} \forall m\). Since we have \(\Delta t = \sum_m\Delta t_m\), uniform nodes maximize \(\Delta t\) subject to the CFL constraint. For example, an \(\verb|SISDC|_P^K\) method with uniformly spaced nodes has a maximum possible time step \(\Delta t < (P-1)\Delta t_{\textrm{cfl}}\). For the same number of function evaluations, the allowed time step with for Lobatto or Chebyshev nodes is smaller. For \(P\leq 3\), the uniform nodes, Lobatto nodes, and Chebyshev nodes coincide. Larger time steps are possible with uniform nodes for \(P>3\), which has some computational consequence. The table below summarizes the largest possible time steps for the \(\verb|SISDC|_P^K\) method with the various quadratures. Finally, note that \(\Delta t_m < \Delta t_{\textrm{cfl}}\) does not guarantee stability since further restrictions may required for stability of the reaction terms.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\(P\)
&\sphinxstyletheadfamily 
Lobatto
&\sphinxstyletheadfamily 
Chebyshev
&\sphinxstyletheadfamily 
Uniform
\\
\hline
2
&
\(\Delta t_{\textrm{cfl}}\)
&
\(\Delta t_{\textrm{cfl}}\)
&
\(\Delta t_{\textrm{cfl}}\)
\\
\hline
3
&
\(2\Delta t_{\textrm{cfl}}\)
&
\(2\Delta t_{\textrm{cfl}}\)
&
\(2\Delta t_{\textrm{cfl}}\)
\\
\hline
4
&
\(2.26\Delta t_{\textrm{cfl}}\)
&
\(1.73\Delta t_{\textrm{cfl}}\)
&
\(3\Delta t_{\textrm{cfl}}\)
\\
\hline
5
&
\(3.05\Delta t_{\textrm{cfl}}\)
&
\(2.82\Delta t_{\textrm{cfl}}\)
&
\(4\Delta t_{\textrm{cfl}}\)
\\
\hline
6
&
\(3.50\Delta t_{\textrm{cfl}}\)
&
\(3.29\Delta t_{\textrm{cfl}}\)
&
\(5\Delta t_{\textrm{cfl}}\)
\\
\hline
7
&
\(4.26\Delta t_{\textrm{cfl}}\)
&
\(4.36\Delta t_{\textrm{cfl}}\)
&
\(6\Delta t_{\textrm{cfl}}\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

For the predictor step, it is necessary to evaluate \(\mathcal{F}_{\textrm{AR}}\left(\phi_m^{k+1}\right)\) and thus update the Poisson and radiative transfer equations at each node. In addition, it is necessary to solve the diffusion equation at every node except \(m=0\) for every diffusive species, which may also require auxiliary updates of the electric field. The corrector step contains extra floating point operator due to the extra terms \(\mathcal{F}_{\textrm{AR}}\left(t_m, \phi_m^k\right)\) and \(\mathcal{F}_{\textrm{D}}\left(t_{m+1}, \phi_{m+1}^k\right)\) and the quadrature \(I_m^{m+1}\). The computational cost of adding in these terms is small compared to the cost of an Euler update of the advection\sphinxhyphen{}reaction equation since one must also computate source terms, drift velocities, and boundary conditions in addition to construction of the hybrid divergence. In short, the computational cost of the predictor and corrector steps are about the same.

Next, we provide some remarks on the extra computational work involved for higher order methods. Broadly speaking, the total amount of floating point operations increases quadratically with the order. Each node requires evaluation of one advection\sphinxhyphen{}reaction operator, at least one electric field update, and one radiative transfer update. Likewise, each substep requires one diffusion solve. Thus, \(\verb|SISDC|_K^K\) requires \(K^2\) advection\sphinxhyphen{}reaction evaluations, \((K-1)^2\) diffusion solves, \((K-1)^2\) radiative transfer updates, and at least \(K^2\) electric field updates. In these estimates we have assumed that the diffusion solve couples semi\sphinxhyphen{}implicitly to the electric field, thus each corrector iteration requires one electric field update per node, giving a total cost \(K^2\). Strictly speaking, the number of advection\sphinxhyphen{}reaction evaluations is slightly less since \(\mathcal{F}_{\textrm{AR}}\left(t_0, \phi_0^k\right)\) does not require re\sphinxhyphen{}evaluation in the corrector, and \(\mathcal{F}_{\textrm{AR}}\left(t_p,\phi_p^{K-1}\right)\) does not need to be computed for the final iteration since the lagged quadrature is not further needed. Nonetheless, the computational work is quadratically increasing, but this is partially compensated by allowance of larger time steps since the \(\verb|SISDC|_K^K\) has a stability limit of \((K-1)\Delta t_{\textrm{cfl}}\) rather than \(\Delta t_{\textrm{cfl}}\) for uniformly spaced nodes. For comparison with the predictor \(\verb|SISDC|_K^1\) which is a first order method, the work done for integration over \((K-1)\Delta t_{\textrm{cfl}}\) amounts to \(K-1\) advection\sphinxhyphen{}reaction updates, \(K-1\) diffusion updates, \(K-1\) radiative transfer updates, and \(K\) electric field updates. If we take the electric field updates as a reasonable metric for the computational work, the efficiency of the \(K\) th order method over the first order method is about \(K\) for integration over the same time interval, i.e. it increases linearly rather than quadratically. However, this estimate is only valid if we do not take accuracy into account. In practice, the predictor does not provide the same accuracy as the corrector over the same integration interval. A fair comparison of the extra computational work involved would require that the accuracy of the two methods be the same after integration over a time \((K-1)\Delta t_{\textrm{cfl}}\), which will generally require more substeps for the first order method. While we do not further pursue this quantification in this paper, the pertinent point is that the extra computational work involved for tolerance\sphinxhyphen{}bound higher order discretizations increases sub\sphinxhyphen{}linearly rather than quadratically when compared to lower\sphinxhyphen{}order equivalents.

We have implemented the SISDC algorithm in the \sphinxcode{\sphinxupquote{sisdc}} class in \sphinxcode{\sphinxupquote{/time\_steppers/sisdc}}. The following class options are available:

\begin{sphinxVerbatim}[commandchars=\\\{\},formatcom=\scriptsize]
\PYG{c+c1}{\PYGZsh{} ====================================================================================================}
\PYG{c+c1}{\PYGZsh{} IMEX\PYGZus{}SDC CLASS OPTIONS}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} This class uses semi\PYGZhy{}implicit spectral deferred corrections. Diffusion is handled implicitly,}
\PYG{c+c1}{\PYGZsh{} and advection\PYGZhy{}reaction is handled explicitly.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} The maximum possible global order of accuracy is (p+1) where p is the number of subintervals. Each}
\PYG{c+c1}{\PYGZsh{} correction raises the order by 1 (corr\PYGZus{}iter=0 is the first order solution). To reach the maximum}
\PYG{c+c1}{\PYGZsh{} possible order, you should perform p correction iterations. }
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} }
\PYG{c+c1}{\PYGZsh{} ====================================================================================================}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{verbosity}        \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}      \PYG{c+c1}{\PYGZsh{} Class verbosity}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{solver\PYGZus{}verbosity} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}      \PYG{c+c1}{\PYGZsh{} Individual solver verbosities}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{fast\PYGZus{}rte}         \PYG{o}{=} \PYG{l+m+mi}{1}       \PYG{c+c1}{\PYGZsh{} Solve RTE every this time steps}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{fast\PYGZus{}poisson}     \PYG{o}{=} \PYG{l+m+mi}{1}       \PYG{c+c1}{\PYGZsh{} Solve Poisson every this time steps	}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{min\PYGZus{}dt}           \PYG{o}{=} \PYG{l+m+mf}{0.}      \PYG{c+c1}{\PYGZsh{} Minimum permitted time step}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{max\PYGZus{}dt}           \PYG{o}{=} \PYG{l+m+mf}{1.E99}   \PYG{c+c1}{\PYGZsh{} Maximum permitted time step}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{cfl}              \PYG{o}{=} \PYG{l+m+mf}{0.5}     \PYG{c+c1}{\PYGZsh{} CFL number}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{relax\PYGZus{}time}       \PYG{o}{=} \PYG{l+m+mf}{1.0}     \PYG{c+c1}{\PYGZsh{} Relaxation time constant}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{source\PYGZus{}comp}      \PYG{o}{=} \PYG{n}{interp}  \PYG{c+c1}{\PYGZsh{} Interpolated \PYGZsq{}interp\PYGZsq{} or cell\PYGZhy{}average \PYGZsq{}cell\PYGZus{}ave\PYGZsq{} for source computations}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Nodes, subintervals, and corrections}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{quad\PYGZus{}nodes}   \PYG{o}{=} \PYG{n}{lobatto}     \PYG{c+c1}{\PYGZsh{} Nodes to be used for quadrature. \PYGZsq{}lobatto\PYGZsq{}, \PYGZsq{}uniform\PYGZsq{}, or \PYGZsq{}chebyshev\PYGZsq{}}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{subintervals} \PYG{o}{=} \PYG{l+m+mi}{1}           \PYG{c+c1}{\PYGZsh{} Number of subintervals. This will be the maximum possible order.}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{corr\PYGZus{}iter}    \PYG{o}{=} \PYG{l+m+mi}{1}           \PYG{c+c1}{\PYGZsh{} Number of iterations of the correction equation. Should be (subintervals\PYGZhy{}1)}
                                 \PYG{c+c1}{\PYGZsh{} for maximum order}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}	}
\PYG{c+c1}{\PYGZsh{} Diffusive coupling}
\PYG{c+c1}{\PYGZsh{}}
\PYG{c+c1}{\PYGZsh{} This defines the weak coupling used for the implicit diffusion advance. }
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{diffusive\PYGZus{}coupling} \PYG{o}{=} \PYG{n}{weak}  \PYG{c+c1}{\PYGZsh{} Diffusion coupling, either \PYGZsq{}weak\PYGZsq{} or \PYGZsq{}strong\PYGZsq{}}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{use\PYGZus{}tga}            \PYG{o}{=} \PYG{n}{false} \PYG{c+c1}{\PYGZsh{} Use second order diffusion per substep (\PYGZsq{}true\PYGZsq{})}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{num\PYGZus{}diff\PYGZus{}corr}      \PYG{o}{=} \PYG{l+m+mi}{0}     \PYG{c+c1}{\PYGZsh{} Number of corrections for \PYGZsq{}strong\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} Adaptive time stepping}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{print\PYGZus{}report}    \PYG{o}{=} \PYG{n}{false}    \PYG{c+c1}{\PYGZsh{} Print report with error and stuff	}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{adaptive\PYGZus{}dt}     \PYG{o}{=} \PYG{n}{false}    \PYG{c+c1}{\PYGZsh{} Use adaptive time stepping}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{error\PYGZus{}norm}      \PYG{o}{=} \PYG{l+m+mi}{2}        \PYG{c+c1}{\PYGZsh{} Error norm (0 = Linf)}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{min\PYGZus{}corr}        \PYG{o}{=} \PYG{l+m+mi}{0}        \PYG{c+c1}{\PYGZsh{} Minimum number of corrections}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{max\PYGZus{}retries}     \PYG{o}{=} \PYG{l+m+mi}{100}      \PYG{c+c1}{\PYGZsh{} Maximum number of tries (for step rejection)}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{max\PYGZus{}growth}      \PYG{o}{=} \PYG{l+m+mf}{1.2}      \PYG{c+c1}{\PYGZsh{} Maximum permissible time step growth}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{decrease\PYGZus{}safety} \PYG{o}{=} \PYG{l+m+mf}{0.9}      \PYG{c+c1}{\PYGZsh{} Fudge factor when we decrease the time step. }
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{min\PYGZus{}cfl}         \PYG{o}{=} \PYG{l+m+mf}{0.1}      \PYG{c+c1}{\PYGZsh{} Minimum CFL}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{max\PYGZus{}cfl}         \PYG{o}{=} \PYG{l+m+mf}{0.75}     \PYG{c+c1}{\PYGZsh{} Maximum CFL}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{max\PYGZus{}error}       \PYG{o}{=} \PYG{l+m+mf}{1.E\PYGZhy{}3}    \PYG{c+c1}{\PYGZsh{} Error threshold}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{error\PYGZus{}index}     \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}       \PYG{c+c1}{\PYGZsh{} Error index. If \PYGZhy{}1, evaluate all CDR solvers	}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{safety}          \PYG{o}{=} \PYG{l+m+mf}{0.75}     \PYG{c+c1}{\PYGZsh{} Safety factor for time stepping}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}	}
\PYG{c+c1}{\PYGZsh{} \PYGZdq{}Asymptotic preserving\PYGZdq{}. Development feature. }
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}	}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{use\PYGZus{}AP}        \PYG{o}{=} \PYG{n}{false}      \PYG{c+c1}{\PYGZsh{} Turn on the \PYGZdq{}asymptotic preserving\PYGZdq{} feature. }

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}	}
\PYG{c+c1}{\PYGZsh{} Debugging options}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{consistent\PYGZus{}E}      \PYG{o}{=} \PYG{n}{true}   \PYG{c+c1}{\PYGZsh{} Use consistent E\PYGZhy{}field computations (update in between RK stages)}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{consistent\PYGZus{}rte}    \PYG{o}{=} \PYG{n}{true}   \PYG{c+c1}{\PYGZsh{} Use consistent RTE updates}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{compute\PYGZus{}v}         \PYG{o}{=} \PYG{n}{true}   \PYG{c+c1}{\PYGZsh{} Compute v in between substeps. }
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{compute\PYGZus{}S}         \PYG{o}{=} \PYG{n}{true}   \PYG{c+c1}{\PYGZsh{} Compute S in between substeps.}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{compute\PYGZus{}D}         \PYG{o}{=} \PYG{n}{true}   \PYG{c+c1}{\PYGZsh{} Compute S in between substeps.}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{do\PYGZus{}advec\PYGZus{}src}      \PYG{o}{=} \PYG{n}{true}   \PYG{c+c1}{\PYGZsh{} Turn off code functionality. Only for debugging }
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{do\PYGZus{}diffusion}      \PYG{o}{=} \PYG{n}{true}   \PYG{c+c1}{\PYGZsh{} Turn off code functionality. Only for debugging}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{do\PYGZus{}poisson}        \PYG{o}{=} \PYG{n}{true}   \PYG{c+c1}{\PYGZsh{} Turn off code functionality. Only for debugging}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{do\PYGZus{}rte}            \PYG{o}{=} \PYG{n}{true}   \PYG{c+c1}{\PYGZsh{} Turn off code functionality. Only for debugging}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{profile\PYGZus{}steps}     \PYG{o}{=} \PYG{n}{false}  \PYG{c+c1}{\PYGZsh{} Profile time steps with order, accuracy, cfl, etc.}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{c+c1}{\PYGZsh{} Advection extrapolation. Currently does NOT work with subcycling (but I\PYGZsq{}m working on it...)}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{imex\PYGZus{}sdc}\PYG{o}{.}\PYG{n}{extrap\PYGZus{}advect} \PYG{o}{=} \PYG{n}{true}      \PYG{c+c1}{\PYGZsh{} Time extrapolate with source and diffusion in advection step}
\end{sphinxVerbatim}


\subsection{Stochastic integrators}
\label{\detokenize{MinimalPlasmaModel:stochastic-integrators}}\label{\detokenize{MinimalPlasmaModel:chap-misdc}}
Deterministic CFD integrators are generally not suitable for stochastic ODEs. For example, the recursive nature of Heun’s method or spectral deferred corrections hardly make sense for stochastic ODEs.

For fluctuating hydrodynamics we are preparing several temporal integrators. \sphinxcode{\sphinxupquote{godunov}} is generally useful for FHD but we also provide an Euler\sphinxhyphen{}Maruyama integrator (\sphinxcode{\sphinxupquote{euler\_maruyama}}) which is first order accurate in time (although with an accurate advective integrator). Although \sphinxcode{\sphinxupquote{euler\_maruyama}} is functionally similar to \sphinxcode{\sphinxupquote{godunov}}, it does not eliminate the dielectric relaxation time and is therefore less stable for some simulation cases.


\subsubsection{euler\_maruyama}
\label{\detokenize{MinimalPlasmaModel:euler-maruyama}}\label{\detokenize{MinimalPlasmaModel:chap-euler-maruyama}}
{\hyperref[\detokenize{MinimalPlasmaModel:chap-euler-maruyama}]{\sphinxcrossref{\DUrole{std,std-ref}{euler\_maruyama}}}} implements the Euler\sphinxhyphen{}Maruyama method. This method is based on an Euler method with explicit or implicit diffusion.


\chapter{Tutorial}
\label{\detokenize{index:tutorial}}\label{\detokenize{index:chap-tutorial}}

\section{Introduction}
\label{\detokenize{Tutorial:introduction}}\label{\detokenize{Tutorial:chap-adrtutorial}}\label{\detokenize{Tutorial::doc}}
In this tutorial we will set up and examine the code for simulating advection\sphinxhyphen{}diffusion problems with AMR and regridding functionality.
If you want to examine the final code, it is given in \sphinxcode{\sphinxupquote{/physics/advection\_diffusion}}.


\section{Setting up \sphinxstyleliteralintitle{\sphinxupquote{time\_stepper}}}
\label{\detokenize{Tutorial:setting-up-time-stepper}}

\chapter{References}
\label{\detokenize{index:references}}\label{\detokenize{index:chap-references}}

\section{References}
\label{\detokenize{References:references}}\label{\detokenize{References::doc}}


\begin{sphinxthebibliography}{ACG+04}
\bibitem[ACG+04]{References:ebchombo}
M Adams, P. Colella, D.T. Graves, J. N. Johnson, N. D. Keen, T. J. Ligocki, D. F. Martin, P. W McCorquodale, D. Modiano, P. O. Schwartz, T. D. Sternberg, and B Van Straalen. Chombo Software Package for AMR Applications \sphinxhyphen{} Design Document. Technical Report, Lawrence Berkeley National Laboratory, 2004.
\bibitem[BLM03]{References:bourlioux2003}
Anne Bourlioux, Anita T. Layton, and Michael L. Minion. High\sphinxhyphen{}order multi\sphinxhyphen{}implicit spectral deferred correction methods for problems of reactive flow. \sphinxstyleemphasis{Journal of Computational Physics}, 2003. \sphinxhref{https://doi.org/10.1016/S0021-9991(03)00251-1}{doi:10.1016/S0021\sphinxhyphen{}9991(03)00251\sphinxhyphen{}1}.
\bibitem[DGR00]{References:dutt2000}
Alok Dutt, Leslie Greengard, and Vladimir Rokhlin. Spectral deferred correction methods for ordinary differential equations. \sphinxstyleemphasis{BIT Numerical Mathematics}, 2000. \sphinxhref{https://doi.org/10.1023/A:1022338906936}{doi:10.1023/A:1022338906936}.
\bibitem[LM04]{References:layton2004}
Anita T. Layton and Michael L. Minion. Conservative multi\sphinxhyphen{}implicit spectral deferred correction methods for reacting gas dynamics. \sphinxstyleemphasis{Journal of Computational Physics}, 2004. \sphinxhref{https://doi.org/10.1016/j.jcp.2003.09.010}{doi:10.1016/j.jcp.2003.09.010}.
\bibitem[LM05]{References:layton2005}
Anita T. Layton and Michael L. Minion. Implications of the choice of quadrature nodes for Picard integral deferred corrections methods for ordinary differential equations. \sphinxstyleemphasis{BIT Numerical Mathematics}, 2005. \sphinxhref{https://doi.org/10.1007/s10543-005-0016-1}{doi:10.1007/s10543\sphinxhyphen{}005\sphinxhyphen{}0016\sphinxhyphen{}1}.
\bibitem[Mar19]{References:marskar2019}
Robert Marskar. An adaptive cartesian embedded boundary approach for fluid simulations of two\sphinxhyphen{} and three\sphinxhyphen{}dimensional low temperature plasma filaments in complex geometries. \sphinxstyleemphasis{Submitted to Journal of Computational Physics}, 2019.
\bibitem[Min03]{References:minion2003}
Michael L. Minion. Semi\sphinxhyphen{}implicit spectral deferred correction methods for ordinary differential equations. \sphinxstyleemphasis{Communications in Mathematical Sciences}, 2003. \sphinxhref{https://doi.org/10.4310/CMS.2003.v1.n3.a6}{doi:10.4310/CMS.2003.v1.n3.a6}.
\bibitem[NBD+12]{References:nonaka2012}
A. Nonaka, J. B. Bell, M. S. Day, C. Gilet, A. S. Almgren, and M. L. Minion. A deferred correction coupling strategy for low Mach number flow with complex chemistry. \sphinxstyleemphasis{Combustion Theory and Modelling}, 2012. \sphinxhref{https://arxiv.org/abs/1512.06459}{arXiv:1512.06459}, \sphinxhref{https://doi.org/10.1080/13647830.2012.701019}{doi:10.1080/13647830.2012.701019}.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}