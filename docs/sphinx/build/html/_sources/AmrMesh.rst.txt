.. _Chap:amr_mesh:

amr_mesh
========

:ref:`Chap:amr_mesh` handles (almost) all spatial operations in `PlasmaC`.
Internally, :ref:`Chap:amr_mesh` contains a bunch of operators that are useful across classes, such as ghost cell interpolation operators, coarsening operators, and stencils for interpolation and extrapolation near the embedded boundaries. :ref:`Chap:amr_mesh` also contains routines for generation and load-balancing of grids based and also contains simple routines for allocation and deallocation of memory. 

:ref:`Chap:amr_mesh` is an integral part of `PlasmaC`, and users will never have the need to modify it unless they are implementing something entirely new. The behavior of :ref:`Chap:amr_mesh` is modified through it's available input parameters, listed below:

Main functionality
------------------

There are two main functionalities in ``amr_mesh``:

1. Building grid hierarchies, and providing geometric information
2. Providing AMR operators.

In practice, users will not interact directly with this functionality, it is called by ``driver`` at the appropriate stages of regrids.

The AMR operators are, for example, coarsening operators, interpolation operators, ghost cell interpolators etc.
To save some regrid time, we don't always build every AMR operator that we might ever need, but have solvers *register* the ones that they specifically need.

Registering operators
---------------------

To register an operator, one must call a public member function of ``amr_mesh``:

.. code-block:: c++

   void register_operator(const std::string a_operator, const phase::which_phase a_phase);

where the string identifier is the name of the operator and ``a_phase`` is the phase on which the operator will live.
Currently, the following operators are supported:

1. *eb_gradient* for allocating stencils for computing the cell-centered gradient. 
2. *eb_irreg_interp* for allocating interpolation stencils in irregular cells, e.g. interpolation to centroids or boundary centroids. 
3. *eb_coar_ave* for conservative coarsening of data. 
4. *eb_quad_cfi* for quadratic filling of ghost cells. 
5. *eb_fill_patch* for linear interpolation of ghost cells. 
6. *eb_pwl_interp* for piecewise linear interpolation during e.g. regrids. 
7. *eb_flux_reg* for holding fluxes on refinement boundaries. 
8. *eb_redist* for holding redistribution objects (for e.g. particle deposition or divergence computatoins). 
9. *eb_copier* for adding the contents in ghost cells to the valid region on the same AMR level. 
10. *eb_ghostcloud* for adding the contents in ghost cells on the refinement boundary to the coarser AMR level. 
11. *eb_non_cons_div* for computing stencils for doing the non-conservative divergence. 


Class options
-------------

.. literalinclude:: links/amr_mesh.options

We now discuss the various ``amr_mesh`` class options.

* ``amr_mesh.verbosity`` controls the verbosity of this class. ``amr_mesh`` can potentially do a lot of output, so it is best to leave this to the default value (-1) unless you are debugging. 
* ``amr_mesh.coarsest_domain`` is the partitioning of the *coarsest* grid level that discretizes your problem domain. The entries in this option must all be integers of ``amr_mesh.max_box_size``.
* ``amr_mesh.blocking_factor`` sets the minimum box size that can be generated by the mesh generation algorithm. We remark that if you are doing particle deposition, ``amr_mesh.blocking_factor`` and ``amr_mesh.max_box_size`` MUST be equal. 
* ``amr_mesh.max_box_size`` sets the maximum box size that can be generated by the mesh generation algorithm. 
* ``amr_mesh.max_ebis_box`` sets the maximum box size that will be used in the geometry generation step. A smaller box will consume less memory, but geometry generation runtime will be longer. 
* ``amr_mesh.max_amr_depth`` defines the largest possible number of grids that can be used. 
* ``amr_mesh.max_sim_depth`` defines the maximum simulation depth for the simulation. This options exists because you may want to run one part of a simulation using a coarser resolution than ``amr_mesh.max_amr_depth``. 
* ``amr_mesh.refine_all_lvl`` is deprecated class option. 
* ``amr_mesh.mg_coarsen`` is a "pre-coarsening" method for multigrid solvers. The deeper multigrids levels are there to facilitate convergence, and it often helps to use fairly large box sizes on some of these levels before aggregating boxes. 
* ``amr_mesh.fill_ratio`` is the fill ratio for the mesh refinement algorithm. This value must be between 0 and 1; a smaller value will result in larger grids. A higher value results in more compact grids, but possibly with more boxes. 
* ``amr_mesh.irreg_growth`` controls how much irregular tags (e.g. boundary tags) are grown before being passed into the mesh refinement algorithm. 
* ``amr_mesh.buffer_size`` is the minimum number of cells between grid levels. 
* ``amr_mesh.ref_rat`` is the refinement factor between levels. Values 2 and 4 are supported, and you may use mixed refinement ratios. The length of this vector must be at least equal to the number of refinement levels. 
* ``amr_mesh.num_ghost`` indicates how many ghost cells to use for all data holders. The typical value is 3 for EB-applications, but non-EB applications might get away with fewer ghost cells. 
* ``amr_mesh.eb_ghost`` controls how ghost cells are used for the EB generation. 
* ``amr_mesh.centroid_sten`` controls which stencil is used for interpolating data to irregular cell centroids. Currently available options are 'pwl' (piecewise linear), 'linear' (bi/trilinear), 'taylor' (higher order Taylor expansion), and 'lsq' which is a least squares fit. Only 'pwl' is guaranteed to have positive weights in the stencil. 
* ``amr_mesh.eb_sten`` controls which stencil is used for interpolation/extrapolation to embedded boundary centroids. We cannot guarantee that the stencils have only positive weights. 
* ``amr_mesh.redist_radius`` is the redistribution radius for hyperbolic redistribution. 
* ``amr_mesh.ghost_interp`` defines the ghost cell interpolation type. Algorithms that require very specific ghost cell interpolation schemes (advection, for example) use their own interpolation method that is outside user control. The available options are 'pwl' (piecewise linear) and 'quad' (quadratic). 
* ``amr_mesh.load_balance`` tells ``amr_mesh`` how to load balance the grids. 
* ``amr_mesh.ebcf`` allows ``amr_mesh`` to turn on certain optimizations when there are **not** crossing between embedded boundaries and grid refinement boundaries. If such crossings exist, and you set this flag to false, `PlasmaC` *will* compute incorrect answers.
