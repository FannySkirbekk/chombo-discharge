

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Convection-Diffusion-Reaction &mdash; PlasmaC 19.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="_static/my_theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Poisson" href="Poisson.html" />
    <link rel="prev" title="Solver" href="Solver.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> PlasmaC
          

          
          </a>

          
            
            
              <div class="version">
                19.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">PlasmaC introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="GettingStarted.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="Model.html">The <code class="docutils literal notranslate"><span class="pre">PlasmaC</span></code> code</a></li>
<li class="toctree-l1"><a class="reference internal" href="Basics.html">Chombo basics</a></li>
</ul>
<p class="caption"><span class="caption-text">Using PlasmaC</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Realm.html">Realm</a></li>
<li class="toctree-l1"><a class="reference internal" href="MeshData.html">Understanding mesh data</a></li>
<li class="toctree-l1"><a class="reference internal" href="ParticleData.html">Understanding particle data</a></li>
<li class="toctree-l1"><a class="reference internal" href="Control.html">Controlling <code class="docutils literal notranslate"><span class="pre">PlasmaC</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="Visualization.html">Visualization</a></li>
</ul>
<p class="caption"><span class="caption-text">PlasmaC design</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Driver.html">driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="AmrMesh.html">amr_mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="ComputationalGeometry.html">computational_geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="TimeStepper.html">time_stepper</a></li>
<li class="toctree-l1"><a class="reference internal" href="CellTagger.html">cell_tagger</a></li>
</ul>
<p class="caption"><span class="caption-text">Supported solvers</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Solver.html">Solver</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Convection-Diffusion-Reaction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#cdr-solver">cdr_solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-cdr-solver">Using cdr_solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-the-solver">Setting up the solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filling-the-solver">Filling the solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adjusting-output">Adjusting output</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cdr-species">cdr_species</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discretization-details">Discretization details</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#computing-explicit-divergences">Computing explicit divergences</a></li>
<li class="toctree-l3"><a class="reference internal" href="#maintaining-non-negative-densities">Maintaining non-negative densities</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-advection">Explicit advection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-diffusion">Explicit diffusion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explicit-advection-diffusion">Explicit advection-diffusion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implicit-diffusion">Implicit diffusion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-a-stochastic-flux">Adding a stochastic flux</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Poisson.html">Poisson</a></li>
<li class="toctree-l1"><a class="reference internal" href="RTE.html">Radiative transfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="Sigma.html">Surface charge solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="Ito.html">Îto diffusion</a></li>
</ul>
<p class="caption"><span class="caption-text">Implemented models</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="PoissonModel.html">Poisson model</a></li>
<li class="toctree-l1"><a class="reference internal" href="AdvectionDiffusionModel.html">Advection diffusion model</a></li>
<li class="toctree-l1"><a class="reference internal" href="BrownianWalkerModel.html">Brownian walker model</a></li>
<li class="toctree-l1"><a class="reference internal" href="MinimalPlasmaModel.html">Minimal plasma model</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Tutorial.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Tutorial.html#setting-up-time-stepper">Setting up <code class="docutils literal notranslate"><span class="pre">time_stepper</span></code></a></li>
</ul>
<p class="caption"><span class="caption-text">References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="References.html">References</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PlasmaC</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Convection-Diffusion-Reaction</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/CDR.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="convection-diffusion-reaction">
<span id="chap-cdr"></span><h1>Convection-Diffusion-Reaction<a class="headerlink" href="#convection-diffusion-reaction" title="Permalink to this headline">¶</a></h1>
<p>Here, we discuss the discretization of the equation</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t} + \nabla\cdot\left(\mathbf{v} \phi - D\nabla \phi + \sqrt{2D\phi}\mathbf{Z}\right) = S.\]</div>
<p>We assume that <span class="math notranslate nohighlight">\(\phi\)</span> is discretized by cell-centered averages (note that cell centers may lie inside solid boundaries), and use finite volume methods to construct fluxes in a cut-cells and regular cells.</p>
<p>Here, <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> indicates a drift velocity, <span class="math notranslate nohighlight">\(D\)</span> is the diffusion coefficient, and the term <span class="math notranslate nohighlight">\(\sqrt{2D\phi}\mathbf{Z}\)</span> is a stochastic diffusion flux. <span class="math notranslate nohighlight">\(S\)</span> is the source term.</p>
<div class="section" id="cdr-solver">
<span id="chap-cdr-solver"></span><h2>cdr_solver<a class="headerlink" href="#cdr-solver" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cdr_solver</span></code> class contains the interface for solving advection-diffusion-reaction problems.
The class is abstract and resides in <code class="file docutils literal notranslate"><span class="pre">/src/cdr_solver/cdr_solver.H(cpp)</span></code> together with specific implementations.
By design <code class="docutils literal notranslate"><span class="pre">cdr_solver</span></code> does not contain any specific advective and diffusive discretization, and these are supposed to be added through inheritance.
For example, <code class="docutils literal notranslate"><span class="pre">cdr_tga</span></code> inherits from <code class="docutils literal notranslate"><span class="pre">cdr_solver</span></code> and adds a second order diffusive discretization together with multigrid code for performing implicit diffusion.
Below that, the classes <code class="docutils literal notranslate"><span class="pre">cdr_gdnv</span></code> and <code class="docutils literal notranslate"><span class="pre">cdr_muscl</span></code> inherit everything from <code class="docutils literal notranslate"><span class="pre">cdr_tga</span></code> and also adds in the advective discretization.
Thus, adding new advection code is done by inheriting from <code class="docutils literal notranslate"><span class="pre">cdr_tga</span></code> and implementing new advection schemes.
This is much more lightweight than rewriting all of <code class="docutils literal notranslate"><span class="pre">cdr_solver</span></code> (which is several thousand lines of code).</p>
<div align="center" class="align-center"><div class="graphviz"><img src="_images/graphviz-b6224a760d1dbe37493fcb7c9a5f4aface8a0927.png" alt="digraph {
   rankdir=&quot;LR&quot;;
   &quot;cdr_solver&quot; -&gt; &quot;cdr_tga&quot; -&gt; {&quot;cdr_gdnv&quot;, &quot;cdr_muscl&quot;};
}" class="graphviz" /></div>
</div>
<p>Currently, we mostly use the implementation given in <code class="file docutils literal notranslate"><span class="pre">/src/cdr_solver/cdr_gdnv.H(cpp)</span></code> which contains a second order accurate discretization with slope limiters which was distributed by the Chombo team.
The alternative implementation in <code class="file docutils literal notranslate"><span class="pre">/src/cdr_muscl.H(cpp)</span></code> contains a MUSCL implementation with van Leer slope limiting (i.e. much the same as the Chombo code).</p>
</div>
<div class="section" id="using-cdr-solver">
<h2>Using cdr_solver<a class="headerlink" href="#using-cdr-solver" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cdr_solver</span></code> is intended to be used in a method-of-lines context where the user will</p>
<ol class="arabic simple">
<li><p>Fill the solver with relevant data (e.g. velocities, diffusion coefficients, source terms etc.).</p></li>
<li><p>Call public member functions for computing advective or diffusive derivates, or perform implicit diffusion advances.</p></li>
</ol>
<p>There are on time integration algorithms built into the <code class="docutils literal notranslate"><span class="pre">cdr_solver</span></code>, and the user will have to supply these through <code class="docutils literal notranslate"><span class="pre">time_stepper</span></code>.
It is up to the developer to ensure that the solver is filled with appropriate data before calling the public member functions.
This would typically look something like this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">vel</span> <span class="o">=</span> <span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">get_velo_cell</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">lvl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lvl</span> <span class="o">&lt;=</span> <span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">get_finest_level</span><span class="p">();</span> <span class="n">lvl</span><span class="o">++</span><span class="p">){</span>
   <span class="k">const</span> <span class="n">DisjointBoxLayout</span><span class="o">&amp;</span> <span class="n">dbl</span> <span class="o">=</span> <span class="n">m_amr</span><span class="o">-&gt;</span><span class="n">get_grids</span><span class="p">()[</span><span class="n">lvl</span><span class="p">];</span>

   <span class="k">for</span> <span class="p">(</span><span class="n">DataIterator</span> <span class="n">dit</span> <span class="o">=</span> <span class="n">dbl</span><span class="p">.</span><span class="n">dataIterator</span><span class="p">();</span> <span class="n">dit</span><span class="p">.</span><span class="n">ok</span><span class="p">();</span> <span class="o">++</span><span class="n">dit</span><span class="p">){</span>
      <span class="n">EBCellFAB</span><span class="o">&amp;</span> <span class="n">patchVel</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">vel</span><span class="p">[</span><span class="n">lvl</span><span class="p">])[</span><span class="n">dit</span><span class="p">()];</span>

      <span class="c1">// Set velocity of some patch</span>
      <span class="n">callSomeFunction</span><span class="p">(</span><span class="n">patchVel</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Compute div(v*phi)</span>
<span class="n">compute_divF</span><span class="p">(....)</span>
</pre></div>
</div>
<p>More complete code is given in the physics module for advection-diffusion problems in <code class="file docutils literal notranslate"><span class="pre">/physics/advection_diffusion/advection_diffusion_stepper</span></code>.
This code is also part of a regression test found in <code class="file docutils literal notranslate"><span class="pre">/regression/advection_diffusion</span></code>.</p>
</div>
<div class="section" id="setting-up-the-solver">
<h2>Setting up the solver<a class="headerlink" href="#setting-up-the-solver" title="Permalink to this headline">¶</a></h2>
<p>To set up the <code class="docutils literal notranslate"><span class="pre">cdr_solver</span></code>, the following commands are usually included in <code class="docutils literal notranslate"><span class="pre">time_stepper::setup_solvers()</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assume m_solver and m_species are pointers to a cdr_solver and cdr_species</span>
<span class="n">m_solver</span>  <span class="o">=</span> <span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">cdr_solver</span><span class="o">&gt;</span>  <span class="p">(</span><span class="k">new</span> <span class="n">my_cdr_solver</span><span class="p">());</span>
<span class="n">m_species</span> <span class="o">=</span> <span class="n">RefCountedPtr</span><span class="o">&lt;</span><span class="n">cdr_species</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">new</span> <span class="n">my_cdr_species</span><span class="p">());</span>

<span class="c1">// Solver setup</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">set_verbosity</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">set_species</span><span class="p">(</span><span class="n">m_species</span><span class="p">);</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">parse_options</span><span class="p">();</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">set_phase</span><span class="p">(</span><span class="n">phase</span><span class="o">::</span><span class="n">gas</span><span class="p">);</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">set_amr</span><span class="p">(</span><span class="n">m_amr</span><span class="p">);</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">set_computational_geometry</span><span class="p">(</span><span class="n">m_compgeom</span><span class="p">);</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">sanity_check</span><span class="p">();</span>
<span class="n">m_solver</span><span class="o">-&gt;</span><span class="n">allocate_internals</span><span class="p">();</span>
</pre></div>
</div>
<p>To see an example, the advection-diffusion code in <code class="file docutils literal notranslate"><span class="pre">/physics/advection_diffusion/advection_diffusion_stepper</span></code> shows how to set up the solver.</p>
</div>
<div class="section" id="filling-the-solver">
<h2>Filling the solver<a class="headerlink" href="#filling-the-solver" title="Permalink to this headline">¶</a></h2>
<p>In order to obtain mesh data from the <code class="docutils literal notranslate"><span class="pre">cdr_solver</span></code>, the user should use the following public member functions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">get_state</span><span class="p">();</span>        <span class="c1">// Return  phi</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">get_velo_cell</span><span class="p">();</span>    <span class="c1">// Get cell-centered velocity</span>
<span class="n">EBAMRFluxData</span><span class="o">&amp;</span> <span class="n">get_diffco_face</span><span class="p">();</span>  <span class="c1">// Returns D</span>
<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">get_source</span><span class="p">();</span>       <span class="c1">// Returns S</span>
<span class="n">EBAMRIVData</span><span class="o">&amp;</span> <span class="n">get_ebflux</span><span class="p">();</span>         <span class="c1">// Returns flux at EB</span>
<span class="n">EBAMRIFData</span><span class="o">&amp;</span> <span class="n">get_domainflux</span><span class="p">();</span>     <span class="c1">// Returns flux at domain boundaries</span>
</pre></div>
</div>
<p>To set the drift velocities, the user will fill the <em>cell-centered</em> velocities.
Interpolation to face-centered transport fluxes are done by <code class="docutils literal notranslate"><span class="pre">cdr_solver</span></code> when needed.</p>
<p>The general way of setting the velocity is to get a direct handle to the velocity data:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cdr_solver</span> <span class="nf">solver</span><span class="p">(...);</span>

<span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">velo_cell</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">get_velo_cell</span><span class="p">();</span>
</pre></div>
</div>
<p>Then, <code class="docutils literal notranslate"><span class="pre">velo_cell</span></code> can be filled with the cell-centered velocity.
The same procedure goes for the source terms, diffusion coefficients, boundary conditions and so on.</p>
</div>
<div class="section" id="adjusting-output">
<h2>Adjusting output<a class="headerlink" href="#adjusting-output" title="Permalink to this headline">¶</a></h2>
<p>It is possible to adjust solver output when plotting data.
This is done through the input file for the class that you’re using (e.g. <code class="file docutils literal notranslate"><span class="pre">/src/cdr_solver/cdr_gdnv.options</span></code>):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cdr_gdnv.plt_vars <span class="o">=</span> phi vel src dco ebflux  <span class="c1"># Plot variables. Options are &#39;phi&#39;, &#39;vel&#39;, &#39;dco&#39;, &#39;src&#39;, &#39;ebflux&#39;</span>
</pre></div>
</div>
<p>Here, you adjust the plotted variables by adding or omitting them from your input script.
E.g. if you only want to plot the cell-centered states you would do:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cdr_gdnv.plt_vars <span class="o">=</span> phi  <span class="c1"># Plot variables. Options are &#39;phi&#39;, &#39;vel&#39;, &#39;dco&#39;, &#39;src&#39;, &#39;ebflux&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="cdr-species">
<span id="chap-cdr-species"></span><h2>cdr_species<a class="headerlink" href="#cdr-species" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">cdr_species</span></code> class is a supporting class that passes information and initial conditions into <code class="docutils literal notranslate"><span class="pre">cdr_solver</span></code> instances.</p>
</div>
<div class="section" id="discretization-details">
<h2>Discretization details<a class="headerlink" href="#discretization-details" title="Permalink to this headline">¶</a></h2>
<div class="section" id="computing-explicit-divergences">
<span id="chap-explicitdivergence"></span><h3>Computing explicit divergences<a class="headerlink" href="#computing-explicit-divergences" title="Permalink to this headline">¶</a></h3>
<p>Computing explicit divergences for equations like</p>
<div class="math notranslate nohighlight">
\[\frac{\partial \phi}{\partial t} + \nabla\cdot\mathbf{G} = 0\]</div>
<p>is problematic because of the arbitarily small volume fractions of cut cells.
In general, we seek to update <span class="math notranslate nohighlight">\(\phi^{k+1} = \phi^k - \Delta t \left[\nabla\cdot \mathbf{G}^k\right]\)</span> where <span class="math notranslate nohighlight">\(\left[\nabla\cdot\mathbf{G}\right]\)</span> is a numerical approximation based on some finite volume approximation.
Recall that in finite volume methods we usually seek the update</p>
<div class="math notranslate nohighlight" id="equation-conservativeupdate">
<span class="eqno">(1)<a class="headerlink" href="#equation-conservativeupdate" title="Permalink to this equation">¶</a></span>\[\phi^{k+1} = \phi^k - \frac{\Delta t}{\kappa \Delta x^{\textrm{DIM}}}\int_V\nabla\cdot\mathbf{G}dV,\]</div>
<p>where <span class="math notranslate nohighlight">\(\kappa\)</span> is the volume fraction of a grid cell, <span class="math notranslate nohighlight">\(\textrm{DIM}\)</span> is the spatial dimension and the volume integral is written as discretized surface integral</p>
<div class="math notranslate nohighlight">
\[\int_V\nabla\cdot\mathbf{G}dV =\sum_{f\in f(V)}\left(\mathbf{G}_f\cdot \mathbf{n}_f\right)\alpha_f\Delta x^{\textrm{DIM} -1}.\]</div>
<p>The sum runs over all cell edges (faces in 3D) of the cell where <span class="math notranslate nohighlight">\(G_f\)</span> is the flux on the edge centroid and <span class="math notranslate nohighlight">\(\alpha_f\)</span> is the edge (face) aperture.</p>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="_images/cutCell.png"><img alt="_images/cutCell.png" src="_images/cutCell.png" style="width: 480px;" /></a>
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">Location of centroid fluxes for cut cells.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>However, taking <span class="math notranslate nohighlight">\([\nabla\cdot\mathbf{G}^k]\)</span> to be this sum leads to a time step constraint proportional to <span class="math notranslate nohighlight">\(\kappa\)</span>, which can be arbitrarily small.
This leads to an unacceptable time step constraint for <a class="reference internal" href="#equation-conservativeupdate">Eq.1</a>.
We use the Chombo approach and expand the range of influence of the cut cells in order to stabilize the discretization and allow the use of a normal time step constraint.
First, we compute the conservative divergence</p>
<div class="math notranslate nohighlight">
\[\kappa_{\mathbf{i}} D_\mathbf{i}^c =  \sum_f G_f\alpha_f\Delta x^{\textrm{DIM} -1},\]</div>
<p>where <span class="math notranslate nohighlight">\(G_f = \mathbf{G}_f\cdot \mathbf{n}_f\)</span>. Next, we compute a non-conservative divergence <span class="math notranslate nohighlight">\(D_{\mathbf{i}}^{nc}\)</span></p>
<div class="math notranslate nohighlight">
\[D_\mathbf{i}^{nc} =  \frac{\sum_{\mathbf{j}\in{N}\left(\mathbf{i}\right)}\kappa_{\mathbf{j}}D_\mathbf{i}^c}{\sum_{\mathbf{j}\in{N}\left(\mathbf{i}\right)}\kappa_{\mathbf{j}}}\]</div>
<p>where <span class="math notranslate nohighlight">\(N(\mathbf{i})\)</span> indicates some neighborhood of cells around cell <span class="math notranslate nohighlight">\(\mathbf{i}\)</span>. Next, we compute a hybridization of the divergences,</p>
<div class="math notranslate nohighlight">
\[D_{\mathbf{i}}^H = \kappa_{\mathbf{i}} D_{\mathbf{i}}^c + (1-\kappa_{\mathbf{i}})D_{\mathbf{i}}^{nc},\]</div>
<p>and perform an intermediate update</p>
<div class="math notranslate nohighlight">
\[\phi_{\mathbf{i}}^{k+1} = \phi_{\mathbf{i}}^k - \Delta tD_{\mathbf{i}}^H.\]</div>
<p>The hybrid divergence update fails to conserve mass by an amount <span class="math notranslate nohighlight">\(\delta M_{\mathbf{i}} = \kappa_{\mathbf{i}}\left(1-\kappa_{\mathbf{i}}\right)\left(D_{\mathbf{i}}^c - D_{\mathbf{i}}^{nc}\right)\)</span>.
In order to main overall conservation, the excess mass is redistributed into neighboring grid cells.
Let <span class="math notranslate nohighlight">\(\delta M_{\mathbf{i}, \mathbf{j}}\)</span> be the redistributed mass from <span class="math notranslate nohighlight">\(\mathbf{j}\)</span> to <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> where</p>
<div class="math notranslate nohighlight">
\[\delta M_{\mathbf{i}} = \sum_{\mathbf{j} \in N(\mathbf{i})}\delta M_{\mathbf{i}, \mathbf{i}}.\]</div>
<p>This mass is used as a local correction in the vicinity of the cut cells, i.e.</p>
<div class="math notranslate nohighlight">
\[\phi_{\mathbf{i}}^{k+1} \rightarrow \phi_{\mathbf{i}}^{k+1} + \delta M_{\mathbf{j}\in N(\mathbf{i}), \mathbf{i}},\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta M_{\mathbf{j}\in N(\mathbf{i}), \mathbf{i}}\)</span> is the total mass redistributed to cell <span class="math notranslate nohighlight">\(\mathbf{i}\)</span> from the other cells.
After these steps, we define</p>
<div class="math notranslate nohighlight">
\[\left[\nabla\cdot\mathbf{G}^k\right]_{\mathbf{i}} \equiv \frac{1}{\Delta t}\left(\phi_{\mathbf{i}}^{k+1} - \phi_{\mathbf{i}}^k\right)\]</div>
<p>Numerically, the above steps for computing a conservative divergence of a one-component flux <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> are implemented in the convection-diffusion-reaction solvers, which also respects boundary conditions (e.g. charge injection).
The user will need to call the function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="kt">void</span> <span class="n">cdr_solver</span><span class="o">::</span><span class="n">compute_divG</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_divG</span><span class="p">,</span> <span class="n">EBAMRFluxData</span><span class="o">&amp;</span> <span class="n">a_G</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRIVData</span><span class="o">&amp;</span> <span class="n">a_ebG</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">a_G</span></code> is the numerical representation of <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> over the cut-cell AMR hierarchy and must be stored on cell-centered faces, and <code class="docutils literal notranslate"><span class="pre">a_ebG</span></code> is the flux on the embedded boundary.
The above steps are performed by interpolating <code class="docutils literal notranslate"><span class="pre">a_G</span></code> to face centroids in the cut cells for computing the conservative divergence, and the remaining steps are then performed successively.
The result is put in <code class="docutils literal notranslate"><span class="pre">a_divG</span></code>.</p>
<p>Note that when refinement boundaries intersect with embedded boundaries, the redistribution process is far more complicated since it needs to account for mass that moves over refinement boundaries.
These additional complicated are taken care of inside <code class="docutils literal notranslate"><span class="pre">a_divG</span></code>, but are not discussed in detail here.</p>
</div>
<div class="section" id="maintaining-non-negative-densities">
<span id="chap-nonnegative"></span><h3>Maintaining non-negative densities<a class="headerlink" href="#maintaining-non-negative-densities" title="Permalink to this headline">¶</a></h3>
<p>Although the redistribution functionality is conservative, the cut-cells represent boundaries that make the evolution non-monotone.
In particular, the redistribution process does not guarantee monotonicity.
In some cases, negative values of <span class="math notranslate nohighlight">\(\phi\)</span> are non-physical and the lack of non-negativeness can lead to numerical issues.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cdr_solver</span></code> has an option to use mass-weighted redistribution in order to redistribute mass in the neighborhood of the cut cells.
To turn this one, one must use e.g. <code class="docutils literal notranslate"><span class="pre">cdr_gdnv.redist_mass_weighted</span> <span class="pre">=</span> <span class="pre">true</span></code> in the input script.
The default is false, in which case the redistribution uses volume-weighted redistribution.</p>
<p>As a last effort, we support another redistribution step in the cut cells that redistributes mass from regular cells and into the cut cells in order to maintain non-negative densities.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">redistribute_negative</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_phi</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that this <em>will</em> give give an <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span> error in the solution and so it is not a very attractive solution.
The alternative of maintaining non-negative densities through mass injection introduces the same error, but in addition to adding a <span class="math notranslate nohighlight">\(\mathcal{O}(1)\)</span> error into the solution, this also has the side-effect of being non-conservative.</p>
</div>
<div class="section" id="explicit-advection">
<span id="chap-explicitadvection"></span><h3>Explicit advection<a class="headerlink" href="#explicit-advection" title="Permalink to this headline">¶</a></h3>
<p>Scalar advective updates follows the computation of the explicit divergence discussed in <a class="reference internal" href="#chap-explicitdivergence"><span class="std std-ref">Computing explicit divergences</span></a>.
The face-centered fluxes <span class="math notranslate nohighlight">\(\mathbf{G} = \phi\mathbf{v}\)</span> are computed by instantiation classes for the convection-diffusion-reaction solvers.
These solvers may compute <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> in different ways.
There is, for example, support for low-order upwind methods as well as Godunov methods.
The function signature for explicit advection is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">compute_divF</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_divF</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_state</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">a_extrap_dt</span><span class="p">)</span>
</pre></div>
</div>
<p>where the face-centered fluxes are computed by using the velocities and boundary conditions that reside in the solver, and result is put in <code class="docutils literal notranslate"><span class="pre">a_divF</span></code> using the procedure outlined above.
For example, in order to perform an advective advance over a time step <span class="math notranslate nohighlight">\(\Delta t\)</span>, one would perform the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assume that data holders divF and phi are defined, and that &#39;solver&#39; is</span>
<span class="c1">// a valid convection-diffusion reaction solver with defined velocities.</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">compute_divF</span><span class="p">(</span><span class="n">divF</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Computes divF</span>
<span class="nl">data_ops</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divF</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">);</span>        <span class="c1">// makes phi -&gt; phi - dt*divF</span>
</pre></div>
</div>
</div>
<div class="section" id="explicit-diffusion">
<span id="chap-explicitdiffusion"></span><h3>Explicit diffusion<a class="headerlink" href="#explicit-diffusion" title="Permalink to this headline">¶</a></h3>
<p>Explicit diffusion is performed in much the same way as implicit advection, with the exception that the general flux <span class="math notranslate nohighlight">\(\mathbf{G} = D\nabla\phi\)</span> is computed by using centered differences on face centers.
The function signature for explicit diffusion is</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">compute_divD</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_divF</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_state</span><span class="p">)</span>
</pre></div>
</div>
<p>and we increment in the same way as for explicit advection:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assume that data holders divD and phi are defined, and that &#39;solver&#39; is</span>
<span class="c1">// a valid convection-diffusion reaction solver with defined diffusion coefficients</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">compute_divD</span><span class="p">(</span><span class="n">divD</span><span class="p">,</span> <span class="n">phi</span><span class="p">);</span> <span class="c1">// Computes divD</span>
<span class="nl">data_ops</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divD</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>    <span class="c1">// makes phi -&gt; phi + dt*divD</span>
</pre></div>
</div>
</div>
<div class="section" id="explicit-advection-diffusion">
<span id="chap-explicitadvectiondiffusion"></span><h3>Explicit advection-diffusion<a class="headerlink" href="#explicit-advection-diffusion" title="Permalink to this headline">¶</a></h3>
<p>There is also functionality for aggregating explicit advection and diffusion advances.
The reason for this is that the cut-cell overhead is only applied once on the combined flux <span class="math notranslate nohighlight">\(\phi\mathbf{v} - D\nabla\phi\)</span> rather than on the individual fluxes.
For non-split methods this leads to some performance improvement since the interpolation of fluxes on cut-cell faces only needs to be performed once.
The signature for this is precisely the same as for explicit advection only:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">compute_divJ</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_divJ</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_state</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">a_extrap_dt</span><span class="p">)</span>
</pre></div>
</div>
<p>where the face-centered fluxes are computed by using the velocities and boundary conditions that reside in the solver, and result is put in <code class="docutils literal notranslate"><span class="pre">a_divF</span></code>.
For example, in order to perform an advective advance over a time step <span class="math notranslate nohighlight">\(\Delta t\)</span>, one would perform the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assume that data holders divJ and phi are defined, and that &#39;solver&#39; is</span>
<span class="c1">// a valid convection-diffusion reaction solver with defined velocities and</span>
<span class="c1">// diffusion coefficients</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">compute_divJ</span><span class="p">(</span><span class="n">divJ</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Computes divF</span>
<span class="nl">data_ops</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divJ</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">);</span>        <span class="c1">// makes phi -&gt; phi - dt*divJ</span>
</pre></div>
</div>
<p>Often, time integrators have the option of using implicit or explicit diffusion.
If the time-evolution is non-split (i.e. not using a Strang or Godunov splitting), the integrators will often call <code class="docutils literal notranslate"><span class="pre">compute_divJ</span></code> rather separately calling <code class="docutils literal notranslate"><span class="pre">compute_divF</span></code> and <code class="docutils literal notranslate"><span class="pre">compute_divD</span></code>.
If you had a split-step Godunov method, the above procedure for a forward Euler method for both parts would be:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">compute_divF</span><span class="p">(</span><span class="n">divF</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Computes divF = div(n*phi)</span>
<span class="nl">data_ops</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divF</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">);</span>        <span class="c1">// makes phi -&gt; phi - dt*divF</span>

<span class="n">solver</span><span class="o">-&gt;</span><span class="n">compute_divD</span><span class="p">(</span><span class="n">divD</span><span class="p">,</span> <span class="n">phi</span><span class="p">);</span>      <span class="c1">// Computes divD = div(D*nabla(phi))</span>
<span class="nl">data_ops</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divD</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>         <span class="c1">// makes phi -&gt; phi + dt*divD</span>
</pre></div>
</div>
<p>However, the cut-cell redistribution dance (flux interpolation, hybrid divergence, and redistribution) would be performed twice.</p>
</div>
<div class="section" id="implicit-diffusion">
<span id="chap-implicitdiffusion"></span><h3>Implicit diffusion<a class="headerlink" href="#implicit-diffusion" title="Permalink to this headline">¶</a></h3>
<p>Occasionally, the use of implicit diffusion is necessary.
The convection-diffusion-reaction solvers support two basic diffusion solves:
Backward Euler and the Twizel-Gumel-Arigu (TGA) methods (it should be straightforward for the user to change the backward Euler method into a Crank-Nicholson scheme).
The function signatures for these are</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">advance_euler</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiNew</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiOld</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">advance_tga</span><span class="p">(</span>  <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiNew</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiOld</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span><span class="p">)</span>

<span class="kt">void</span> <span class="n">advance_euler</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiNew</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiOld</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span><span class="p">)</span>
<span class="kt">void</span> <span class="n">advance_tga</span><span class="p">(</span>  <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiNew</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">phiOld</span><span class="p">,</span> <span class="k">const</span> <span class="n">Real</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">phiNew</span></code> is the state at the new time <span class="math notranslate nohighlight">\(t + \Delta t\)</span>, <code class="docutils literal notranslate"><span class="pre">phiOld</span></code> is the state at time <span class="math notranslate nohighlight">\(t\)</span> and <code class="docutils literal notranslate"><span class="pre">src</span></code> is the source term which strictly speaking should be centered at time <span class="math notranslate nohighlight">\(t + \Delta t\)</span> for the Euler update and at time <span class="math notranslate nohighlight">\(t + \Delta t/2\)</span> for the TGA update.
This may or may not be possible for your particular problem.</p>
<p>For example, performing a split step Godunov method for advection-diffusion is as simple as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">compute_divF</span><span class="p">(</span><span class="n">divF</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Computes divF = div(n*phi)</span>
<span class="nl">data_ops</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divF</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">);</span>        <span class="c1">// makes phi -&gt; phi - dt*divF</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">redistribute_negative</span><span class="p">(</span><span class="n">phi</span><span class="p">);</span>   <span class="c1">// Redist negative mass in cut cells</span>

<span class="n">data_ops</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">phiOld</span><span class="p">,</span> <span class="n">phi</span><span class="p">);</span>            <span class="c1">// Copy state</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">advance_euler</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">phiOld</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span> <span class="c1">// Backward Euler diffusion solve</span>
</pre></div>
</div>
</div>
<div class="section" id="adding-a-stochastic-flux">
<h3>Adding a stochastic flux<a class="headerlink" href="#adding-a-stochastic-flux" title="Permalink to this headline">¶</a></h3>
<p>It is possible to add a stochastic flux through the public member functions of <code class="docutils literal notranslate"><span class="pre">cdr_solver</span></code> in the odd case that one wants to use fluctuating hydrodynamics (FHD).
This is done by calling a function that computes the term <span class="math notranslate nohighlight">\(\sqrt{2D\phi}\mathbf{Z}\)</span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">GWN_diffusion_source</span><span class="p">(</span><span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_ransource</span><span class="p">,</span> <span class="k">const</span> <span class="n">EBAMRCellData</span><span class="o">&amp;</span> <span class="n">a_cell_states</span><span class="p">);</span>
</pre></div>
</div>
<p>When FHD is used, there is no guarantee that the evolution leads to non-negative values.
We do our best to ensure that the stochastic flux is turned off when <span class="math notranslate nohighlight">\(\phi \Delta V\)</span> approaches 0 by computing the face-centered states for the stochastic term using an arithmetic mean that goes to zero as <span class="math notranslate nohighlight">\(\phi\)</span> approaches 0.</p>
<p>In the above function, <code class="docutils literal notranslate"><span class="pre">a_ransource</span></code> can be used directly in a MOL context, e.g.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">compute_divF</span><span class="p">(</span><span class="n">divF</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Computes divF = div(n*phi)</span>
<span class="nl">data_ops</span><span class="p">:</span><span class="n">incr</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">divF</span><span class="p">,</span> <span class="o">-</span><span class="n">dt</span><span class="p">);</span>        <span class="c1">// makes phi -&gt; phi - dt*divF</span>

<span class="n">solver</span><span class="o">-&gt;</span><span class="n">GWN_diffusion_source</span><span class="p">(</span><span class="n">ransource</span><span class="p">,</span> <span class="n">phi</span><span class="p">);</span> <span class="c1">// Compute stochastic flux</span>
<span class="n">data_ops</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">phiOld</span><span class="p">,</span> <span class="n">phi</span><span class="p">);</span>                  <span class="c1">// phiOld = phi - dt*divF</span>
<span class="n">data_ops</span><span class="o">::</span><span class="n">incr</span><span class="p">(</span><span class="n">phiOld</span><span class="p">,</span> <span class="n">ransource</span><span class="p">,</span> <span class="n">a_dt</span><span class="p">);</span>      <span class="c1">// phiOld = phi - dt*divF + dt*sqrt(2D*phi)Z</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">advance_euler</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">phiOld</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>       <span class="c1">// Backward Euler diffusion solve</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Poisson.html" class="btn btn-neutral float-right" title="Poisson" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Solver.html" class="btn btn-neutral float-left" title="Solver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Robert Marskar

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>