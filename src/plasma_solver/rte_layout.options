# ====================================================================================================
# RTE_LAYOUT CLASS OPTIONS
# ====================================================================================================
rte_layout.which_solver = eddington_sp1 # Solver type. Available option is "eddington_sp1"
rte_layout.stationary   = true          # Stationary solver ot no.

# ---------------------------
# eddington_sp1 class options
#----------------------------
eddington_sp1.stationary         = true      # Stationary solver
eddington_sp1.reflectivity       = 0.        # Reflectivity
eddington_sp1.use_tga            = false     # Second order integration (if transient)
eddington_sp1.gmg_verbosity      = -1        # GMG verbosity
eddington_sp1.gmg_pre_smooth     = 6         # Number of relaxations in downsweep
eddington_sp1.gmg_post_smooth    = 6         # Number of relaxations in upsweep
eddington_sp1.gmg_bott_smooth    = 6         # NUmber of relaxations before dropping to bottom solver
eddington_sp1.gmg_min_iter       = 5         # Minimum number of iterations
eddington_sp1.gmg_max_iter       = 32        # Maximum number of iterations
eddington_sp1.gmg_tolerance      = 1.E-8     # Residue tolerance
eddington_sp1.gmg_hang           = 0.2       # Solver hang
eddington_sp1.gmg_bottom_drop    = 16        # Bottom drop
eddington_sp1.gmg_bottom_solver  = bicgstab  # Bottom solver type. Valid options are 'simple' and 'bicgstab'
eddington_sp1.gmg_bottom_relax   = 32        # Number of relaxations in bottom solve ('simple' solver only)

eddington_sp1.stochastic_photons = false     # Draw discrete photons from continuum distribution
eddington_sp1.seed               = 0         # Seed

eddington_sp1.bc_x_low  = robin              # Boundary on domain. 'neumann' or 'robin'
eddington_sp1.bc_x_high = robin              # Boundary on domain. 'neumann' or 'robin'              
eddington_sp1.bc_y_low  = robin              # Boundary on domain. 'neumann' or 'robin'
eddington_sp1.bc_y_high = robin              # Boundary on domain. 'neumann' or 'robin'
eddington_sp1.bc_z_low  = robin              # Boundary on domain. 'neumann' or 'robin'
eddington_sp1.bc_z_high = robin              # Boundary on domain. 'neumann' or 'robin'

# ----------------------
# mc_photo class options
# ----------------------
mc_photo.max_photons    = 1           # Maximum no. generated in a cell (<= 0 yields physical photons)
mc_photo.pvr_buffer     = 2           # Buffer for PVR. Prevents clouds from leaking onto coarse levels. 
mc_photo.random_kappa   = true        # Randomize absorption length (taken from photon implementation)
mc_photo.bisect_step    = 1.E-4       # Bisection step length for intersection tests
mc_photo.seed           = 0           # Seed for RNG
mc_photo.bc_x_low       = outflow     # Boundary condition. 'outflow', 'symmetry', or 'wall'
mc_photo.bc_x_high      = outflow     # Boundary condition
mc_photo.bc_y_low       = outflow     # Boundary condition
mc_photo.bc_y_high      = outflow     # Boundary condition
mc_photo.bc_z_low       = outflow     # Boundary condition
mc_photo.bc_z_high      = outflow     # Boundary condition
mc_photo.poiss_exp_swap = 100         # Swap out Poisson with exponential distribution above this mean
mc_photo.deposition     = cic         # 'ngp' = nearest grid point
                                      # 'cic' = cloud-in-cell
                                      # 'tsc' = triangle-shaped-cloud
                                      # 'w4'  = 3rd order interpolation