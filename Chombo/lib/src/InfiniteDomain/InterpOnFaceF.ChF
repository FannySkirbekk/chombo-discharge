C      _______              __
C     / ___/ /  ___  __ _  / /  ___
C    / /__/ _ \/ _ \/  V \/ _ \/ _ \
C    \___/_//_/\___/_/_/_/_.__/\___/
C    Please refer to Copyright.txt, in Chombo's root directory.

#include "CONSTANTS.H"

      subroutine interp2dface(
     &     CHF_FRA1[fine],
     &     CHF_CONST_FRA1[crse],
     &     CHF_CONST_INT[iref],
     &     CHF_CONST_INT[idim],
     &     CHF_BOX[cbx1e],
     &     CHF_BOX[cbx1n],
     &     CHF_BOX[icbx1],
     &     CHF_BOX[ifbx1],
     &     CHF_CONST_FRA[wt1],
     &     CHF_FRA1[fc],
     &     CHF_BOX[cfbx2e],
     &     CHF_BOX[cfbx2n],
     &     CHF_BOX[icbx2],
     &     CHF_BOX[ifbx2],
     &     CHF_CONST_FRA[wt2],
     &     CHF_CONST_INTVECT[shift])
!     Interpolates from coarse to fine data on a face.
!
!     => inputs, <= outputs
!     fine <= data at fine NODEs
!     crse => data at coarse NODEs
!            (grown by border in both parallel directions)
!     iref => refinement ratio
!     idim => normal direction to face (0, 1, or 2)
!     cbx1e => box of coarse EDGEs,
!             CELL-centered in first parallel direction,
!             NODE-centered and grown by border in second parallel direction,
!             NODE-centered in normal direction
!     cbx1n => box of coarse NODEs,
!             grown by border in second parallel direction.
!     icbx1 => [-border:border+1] in first parallel direction, [0] in others.
!     ifbx1 => [1:iref-1] in first parallel direction, [0] in others.
!     wt1 => weights of coarse NODEs, lives on icbx1.
!     fc => work array, lives on cfbx2n, has iref-1 components.
!     cfbx2e => box with coordinates that are
!              coarse CELLs in the second parallel direction,
!              fine NODEs in the other two directions.
!     cfbx2n => box of NODEs with coordinates that are
!              coarse in the second parallel direction,
!              fine in the other two directions.
!     icbx2 => [-border:border+1] in second parallel direction, [0] in others.
!     ifbx2 => [1:iref-1] in second parallel direction, [0] in others.
!     wt2 => weights of coarse NODEs, lives on icbx2.
!     shift => shift from refined coarse domain to fine domain
!
!     If the mesh spacing is h, then the error in the approximation is
!     O((iref*h)^(2*border+2)).
      integer CHF_DDECL[ic; jc; kc]
      integer CHF_DDECL[icf; jcf; kcf]
      integer CHF_DDECL[if1; jf1; kf1]
      integer CHF_DDECL[if2; jf2; kf2]
      integer CHF_DDECL[ifine; jfine; kfine]
      integer CHF_DDECL[ifbase; jfbase; kfbase]
      integer CHF_DDECL[iw; jw; kw]
      integer pt1, pt2, ipar1, ipar2
      integer ref1(0:CH_SPACEDIM-1), ref2(0:CH_SPACEDIM-1)
      integer sh1(0:CH_SPACEDIM-1), sh2(0:CH_SPACEDIM-1)
      REAL_T  fchere, fihere

      if (idim .eq. 0) then
         ipar1 = 1
         ipar2 = 2
      elseif (idim .eq. 1) then
         ipar1 = 0
         ipar2 = 2
      elseif (idim .eq. 2) then
         ipar1 = 0
         ipar2 = 1
      else
         call MAYDAY_ERROR()
      endif

!     Refinement ratio from crse to fc.
      ref1(idim) = 1
      ref1(ipar1) = iref
      ref1(ipar2) = 1
!     Refinement ratio from fc to fine.
      ref2(idim) = iref
      ref2(ipar1) = 1
      ref2(ipar2) = iref

!     Shift from refined domain of crse to domain of fc.
      sh1(idim) = 0
      sh1(ipar1) = shift(ipar1)
      sh1(ipar2) = 0
!     Shift from domain of fc to domain of fine.
      sh2(idim) = shift(idim)
      sh2(ipar1) = 0
      sh2(ipar2) = shift(ipar2)

!     Project at points that are coarse in both parallel directions:
!     from crse[cbx1n] to fc[ref1*cbx1n + sh1].
!     cbx1n is box of coarse NODEs,
!     grown by border in second parallel direction.
      CHF_MULTIDO[cbx1n; ic; jc; kc]
         CHF_DTERM[
         icf = ref1(0)*ic + sh1(0) ;
         jcf = ref1(1)*jc + sh1(1) ;
         kcf = ref1(2)*kc + sh1(2) ]
         fc(CHF_IX[icf; jcf; kcf]) = crse(CHF_IX[ic; jc; kc])
      CHF_ENDDO

!     cbx1e:  box of coarse EDGEs, grown in second parallel direction:
!             CELL-centered in first parallel direction,
!             NODE-centered in others.
!     icbx1:  [-border:border+1] in first parallel direction, [0] in others.
!     ifbx1:  [1:iref-1] in first parallel direction, [0] in others.
!     Interpolate from nodes of crse[cbx1e + icbx1] to fc[ref1*cbx1e + ifbx1].
      CHF_MULTIDO[cbx1e; ic; jc; kc]
         CHF_DTERM[
         icf = ref1(0)*ic + sh1(0) ;
         jcf = ref1(1)*jc + sh1(1) ;
         kcf = ref1(2)*kc + sh1(2) ]
!     At points that are coarse in both parallel directions, just project.
         fc(CHF_IX[icf; jcf; kcf]) = crse(CHF_IX[ic; jc; kc])
!     pt1 is index into ifbx1
         pt1 = 0
!     ifbx1:  [1:iref-1] in first parallel direction, [0] in others.
         CHF_MULTIDO[ifbx1; if1; jf1; kf1]
            fchere = zero
!     icbx1:  [-border:border+1] in first parallel direction, [0] in others.
!     wt1(iw, jw, kw, pt1) holds weight of coarse point (iw, jw, kw) for
!     fine point indexed by pt1 into ifbx1.
            CHF_MULTIDO[icbx1; iw; jw; kw]
               fchere = fchere +
     &           wt1(CHF_IX[iw; jw; kw], pt1) *
     &           crse(CHF_IX[ic + iw; jc + jw; kc + kw])
            CHF_ENDDO
            fc(CHF_IX[icf + if1; jcf + jf1; kcf + kf1]) = fchere
            pt1 = pt1 + 1
         CHF_ENDDO
      CHF_ENDDO

!     Project at points that are coarse in second parallel direction:
!     from fc[cfbx2n] to fc[ref2*cfbx2n + sh2].
      CHF_MULTIDO[cfbx2n; icf; jcf; kcf]
         CHF_DTERM[
         ifbase = ref2(0)*icf + sh2(0) ;
         jfbase = ref2(1)*jcf + sh2(1) ;
         kfbase = ref2(2)*kcf + sh2(2) ]
         fine(CHF_IX[ifbase; jfbase; kfbase]) =
     &        fc(CHF_IX[icf; jcf; kcf])
      CHF_ENDDO

!     cfbx2n:  box of coarse NODEs, with coordinates that are
!              coarse in the second parallel direction,
!              fine in the other two directions.
!     icbx2:  [-border:border+1] in second parallel direction, [0] in others.
!     ifbx2:  [1:iref-1] in second parallel direction, [0] in others.
!     Now interpolate from fc[cfbx2n] to fine[ref2*cbx2e + sh2 + ifbx2].
      CHF_MULTIDO[cfbx2e; icf; jcf; kcf]
         CHF_DTERM[
         ifbase = ref2(0)*icf + sh2(0) ;
         jfbase = ref2(1)*jcf + sh2(1) ;
         kfbase = ref2(2)*kcf + sh2(2) ]
!     pt2 is index into ifbx2
         pt2 = 0
!     ifbx2:  [1:iref-1] in second parallel direction, [0] in others.
         CHF_MULTIDO[ifbx2; if2; jf2; kf2]
            CHF_DTERM[
            ifine = ifbase + if2 ;
            jfine = jfbase + jf2 ;
            kfine = kfbase + kf2 ]

            fihere = zero
!     icbx2:  [-border:border+1] in second parallel direction, [0] in others.
!     wt2(iw, jw, kw, pt2) holds weight of coarse point (iw, jw, kw) for
!     fine point indexed by pt2 into ifbx2.
            CHF_MULTIDO[icbx2; iw; jw; kw]
               fihere = fihere +
     &           wt2(CHF_IX[iw; jw; kw], pt2) *
     &           fc(CHF_IX[icf + iw; jcf + jw; kcf + kw])
            CHF_ENDDO
            fine(CHF_IX[ifine; jfine; kfine]) = fihere
            pt2 = pt2 + 1
         CHF_ENDDO
      CHF_ENDDO

      return
      end



      subroutine getweightsinterp(
     &     CHF_FRA[wt],
     &     CHF_BOX[icbx],
     &     CHF_CONST_INT[iref],
     &     CHF_CONST_INT[border],
     &     CHF_CONST_INT[idim])
!     Gets weight for interpolating from coarse to fine data on a line.
!
!     => inputs, <= outputs
!     wt <= weights of coarse NODEs, lives on icbx.
!     icbx => [-border:border+1] in interpolation direction, [0] in others.
!     iref => refinement ratio
!     border => width of border
!     idim => interpolation dimension of icbx
      integer pt, ifine, icrse, icrso
      integer CHF_DDECL[iw; jw; kw]
      REAL_T prd, xcrse, xcrso, xfine

!     pt is index into fine box
      pt = 0
      do ifine = 1, iref-1
!     xfine = physical coordinate of point in interval (0, 1).
         xfine = (ifine * one) / (iref * one)
!     icbx is [-border:border+1] in direction of interpolation,
!     and [0] in the other directions.  These are the source points.
         CHF_MULTIDO[icbx; iw; jw; kw]
            if (idim .eq. 0) then
               icrse = iw
            elseif (idim .eq. 1) then
               icrse = jw
            elseif (idim .eq. 2) then
               icrse = kw
            else
               call MAYDAY_ERROR()
            endif
!     xcrse = physical coordinate of source point
            xcrse = icrse * one
!     Get wt(indw, pt), the weight applied to
!     coarse point indw for the pt'th point (= (pt+1)/iref ).
            prd = one
            do icrso = -border, border+1
               if (icrso .ne. icrse) then
!     xcrso = physical coordinate of other source point
                  xcrso = icrso * one
                  prd = prd * (xfine - xcrso) / (xcrse - xcrso)
               endif
            enddo
            wt(CHF_IX[iw; jw; kw], pt) = prd
         CHF_ENDDO
         pt = pt + 1
      enddo

      return
      end
