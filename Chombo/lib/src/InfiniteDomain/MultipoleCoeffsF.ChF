C      _______              __
C     / ___/ /  ___  __ _  / /  ___
C    / /__/ _ \/ _ \/  V \/ _ \/ _ \
C    \___/_//_/\___/_/_/_/_.__/\___/
C    Please refer to Copyright.txt, in Chombo's root directory.

#include "CONSTANTS.H"

      subroutine multipolecoeffs(
     &     CHF_FRA[coeffs],
     &     CHF_CONST_INTVECT[ipatch],
     &     CHF_BOX[points],
     &     CHF_CONST_FRA1[charge],
     &     CHF_CONST_FRA[weight])
!     Calculates multipole coefficients from charges.
!
!     => inputs, <= outputs
!     coeffs <= multipole coefficients for the patch;
!               modified ONLY at index ipatch
!     ipatch => index of this patch
!     points => NODEs on which the patch's charges and weights lie
!     charge => charges on this patch
!     weight => weights on charges
      integer CHF_DDECL[i; j; k]
      integer ncoef, var
      REAL_T thisc

      ncoef = CHF_NCOMP[weight]
      do var = 0, ncoef-1
         thisc = zero
         CHF_MULTIDO[points; i; j; k]
            thisc = thisc +
     &        weight(CHF_IX[i; j; k], var) * charge(CHF_IX[i; j; k])
         CHF_ENDDO
         coeffs(CHF_IX[ipatch(0); ipatch(1); ipatch(2)], var) = thisc
      enddo

      return
      end


      subroutine weightcoeffs(
     &     CHF_FRA[weight],
     &     CHF_CONST_INT[deg],
     &     CHF_CONST_REALVECT[h],
     &     CHF_CONST_REALVECT[center],
     &     CHF_BOX[points],
     &     CHF_CONST_FRA1[wtsint])
!     Retrieves the weights by which to multiply charges in order to
!     obtain multipole coefficients.
!
!     => inputs, <= outputs
!     weight <= weights on charges
!     deg => degree of multipole expansion
!     h => mesh spacing in each dimension
!     center => coordinates of center of patch
!     points => NODEs on which the patch's charges lie
!     wtsint => weights of integration; lives on points
      integer CHF_DDECL[ipt; jpt; kpt]
      integer CHF_DDECL[id; jd; kd]
      integer CHF_DDECL[idmax; jdmax; kdmax]
      integer pind
      REAL_T CHF_DDECL[x; y; z]
      REAL_T CHF_DDECL[xpow(0:deg); ypow(0:deg); zpow(0:deg)]

!     Set idmax, jdmax, kdmax to deg in parallel directions,
!     0 in normal direction.
      if (CHF_LBOUND[points; 0] .eq. CHF_UBOUND[points; 0]) then
         idmax = 0
      else
         idmax = deg
      endif
      if (CHF_LBOUND[points; 1] .eq. CHF_UBOUND[points; 1]) then
         jdmax = 0
      else
         jdmax = deg
      endif
      if (CHF_LBOUND[points; 2] .eq. CHF_UBOUND[points; 2]) then
         kdmax = 0
      else
         kdmax = deg
      endif

      CHF_MULTIDO[points; ipt; jpt; kpt]

!     Note that if x, for example, is in the normal direction,
!     we'll have x = 0 and xpow(0) = 1, and
!     we won't use xpow(1:deg), because idmax = 0.

         CHF_DTERM[
         x = ipt * h(0) - center(0) ;
         y = jpt * h(1) - center(1) ;
         z = kpt * h(2) - center(2) ]

!     xpow(id) = ((-1)^id / id!) * x^id
!     ypow(jd) = ((-1)^jd / jd!) * x^jd
!     zpow(kd) = ((-1)^kd / kd!) * x^kd

         CHF_DTERM[
         xpow(0) = one ;
         ypow(0) = one ;
         zpow(0) = one ]

         do id = 1, idmax
            xpow(id) = -x * xpow(id-1) / (id * one)
         enddo
         do jd = 1, jdmax
            ypow(jd) = -y * ypow(jd-1) / (jd * one)
         enddo
         do kd = 1, kdmax
            zpow(kd) = -z * zpow(kd-1) / (kd * one)
         enddo

         pind = 0
         do id = 0, idmax
            do jd = 0, jdmax
               do kd = 0, kdmax
                  if (id + jd + kd .le. deg) then
                     weight(CHF_IX[ipt; jpt; kpt], pind) =
     &                    wtsint(CHF_IX[ipt; jpt; kpt]) *
     &                    xpow(id) * ypow(jd) * zpow(kd)
                     pind = pind + 1
                  endif
               enddo
            enddo
         enddo

      CHF_ENDDO

      return
      end
