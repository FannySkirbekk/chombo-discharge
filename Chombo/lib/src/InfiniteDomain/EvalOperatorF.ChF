C      _______              __
C     / ___/ /  ___  __ _  / /  ___
C    / /__/ _ \/ _ \/  V \/ _ \/ _ \
C    \___/_//_/\___/_/_/_/_.__/\___/
C    Please refer to Copyright.txt, in Chombo's root directory.

#include "CONSTANTS.H"

!=======================================================
!     subroutine EVALOP
!     evaluate a discrete Laplacian operator
!     => inputs,  <= outputs
!     lofphi  <=  evaluation of the operator
!     Op       => operator code, 1 or 2 or 3:
!                 1 for 19-point, 2 for 7-point, 3 for 27-point
!     Dx       => mesh spacing in the three dimensions
!     Bx       => NODE-centered box on which to evaluate operator
!     Phi      => NODE-centered data to evalute
!
!     The domain of Phi must be at least element larger than Bx,
!     in each dimension.
!
!     petermc, 3 Feb 2004
!=======================================================

      subroutine EVALOP( CHF_FRA1[lofphi]
     &                  ,CHF_CONST_INT[Op]
     &                  ,CHF_CONST_REALVECT[Dx]
     &                  ,CHF_BOX[Bx]
     &                  ,CHF_CONST_FRA1[Phi]
     &                 )
      integer CHF_DDECL[i; j; k]
      REAL_T lphi
      REAL_T CHF_DDECL[invdxsqrd0; invdxsqrd1; invdxsqrd2]
      logical IsotropicGrid

      IsotropicGrid = ABS( Dx(0) / Dx(1) - one ) .LT. 1d-6 .AND.
     &                ABS( Dx(0) / Dx(2) - one ) .LT. 1d-6


      if( Op .eq. 1 .AND. IsotropicGrid )then
!       op 1 is 19-point operator
!       coefficients are:
!        -4 * invdxsqrd for self
!       1/3 * invdxsqrd for points differing by 1 in one coordinate
!       1/6 * invdxsqrd for points differing by 1 in two coordinates
!       0 for points differing by 1 in three coordinates
        ![NOTE: assume all Dx values are identical.]
        invdxsqrd0 = one / ( Dx(0) * Dx(0) )
        CHF_MULTIDO[bx; i; j; k]
          lphi = ( -four * phi(CHF_IX[i; j; k])
     &           + third * (
     &                phi(CHF_IX[i-1; j; k]) + phi(CHF_IX[i+1; j; k]) +
     &                phi(CHF_IX[i; j-1; k]) + phi(CHF_IX[i; j+1; k]) +
     &                phi(CHF_IX[i; j; k-1]) + phi(CHF_IX[i; j; k+1]) )
     &           + sixth * (
     &                phi(CHF_IX[i-1;j-1;k]) + phi(CHF_IX[i-1;j+1;k]) +
     &                phi(CHF_IX[i+1;j-1;k]) + phi(CHF_IX[i+1;j+1;k]) +
     &                phi(CHF_IX[i-1;j;k-1]) + phi(CHF_IX[i-1;j;k+1]) +
     &                phi(CHF_IX[i+1;j;k-1]) + phi(CHF_IX[i+1;j;k+1]) +
     &                phi(CHF_IX[i;j-1;k-1]) + phi(CHF_IX[i;j-1;k+1]) +
     &                phi(CHF_IX[i;j+1;k-1]) + phi(CHF_IX[i;j+1;k+1]) )
     &                )
     &        * invdxsqrd0
          ![NOTE: lphi is used _only_ because the stupid debugger cant evaluate array refs.]
          lofphi(CHF_IX[i; j; k]) =  lphi
        CHF_ENDDO

      elseif( Op .EQ. 1 .AND. .NOT. IsotropicGrid )then
        ! Same stencil structure, but different values because Dx is not
        ! constant.
        ! Let:
        !  u   = u(i,j,k)
        !  ui  = u(i-1,j,k) + u(i+1,j,k)
        !  uij = u(i-1,j-1,k) + u(i+1,j-1,k) + u(i-1,j+1,k) + u(i+1,j+1,k)
        ! The stencil for anisotropic grids is:
        !  uxx + uyy + uzz =
        !   (  8ui - 4uj + 2uk + 4uij - 2ujk +  uik - 24u )/( 18 Dx(0)^2 )
        ! + (  2ui + 8uj - 4uk +  uij + 4ujk - 2uik - 24u )/( 18 Dx(1)^2 )
        ! + ( -4ui + 2uj + 8uk - 2uij +  ujk + 4uik - 24u )/( 18 Dx(2)^2 )
        invdxsqrd0 = one / ( Dx(0) * Dx(0) * 18 )
        invdxsqrd1 = one / ( Dx(1) * Dx(1) * 18 )
        invdxsqrd2 = one / ( Dx(2) * Dx(2) * 18 )
        CHF_MULTIDO[ Bx; i;j;k ]
          lphi = ( ( phi(CHF_IX[i-1;j;k])+phi(CHF_IX[i+1;j;k]) )*8
     &           + ( phi(CHF_IX[i;j-1;k])+phi(CHF_IX[i;j+1;k]) )*(-4)
     &           + ( phi(CHF_IX[i;j;k-1])+phi(CHF_IX[i;j;k+1]) )*2
     &           + ( phi(CHF_IX[i-1;j-1;k])+phi(CHF_IX[i+1;j-1;k])
     &             + phi(CHF_IX[i-1;j+1;k])+phi(CHF_IX[i+1;j+1;k]) )*4
     &           + ( phi(CHF_IX[i;j-1;k-1])+phi(CHF_IX[i;j-1;k-1])
     &             + phi(CHF_IX[i;j+1;k-1])+phi(CHF_IX[i;j+1;k+1]) )*2
     &           + ( phi(CHF_IX[i-1;j;k-1])+phi(CHF_IX[i+1;j;k-1])
     &             + phi(CHF_IX[i-1;j;k+1])+phi(CHF_IX[i+1;j;k+1]) )
     &           + phi(CHF_IX[i;j;k])*(-24) ) * invdxsqrd0
     &         + ( ( phi(CHF_IX[i-1;j;k])+phi(CHF_IX[i+1;j;k]) )*2
     &           + ( phi(CHF_IX[i;j-1;k])+phi(CHF_IX[i;j+1;k]) )*8
     &           + ( phi(CHF_IX[i;j;k-1])+phi(CHF_IX[i;j;k+1]) )*(-4)
     &           + ( phi(CHF_IX[i-1;j-1;k])+phi(CHF_IX[i+1;j-1;k])
     &             + phi(CHF_IX[i-1;j+1;k])+phi(CHF_IX[i+1;j+1;k]) )
     &           + ( phi(CHF_IX[i;j-1;k-1])+phi(CHF_IX[i;j-1;k-1])
     &             + phi(CHF_IX[i;j+1;k-1])+phi(CHF_IX[i;j+1;k+1]) )*4
     &           + ( phi(CHF_IX[i-1;j;k-1])+phi(CHF_IX[i+1;j;k-1])
     &             + phi(CHF_IX[i-1;j;k+1])+phi(CHF_IX[i+1;j;k+1]) )*2
     &           + phi(CHF_IX[i;j;k])*(-24) ) * invdxsqrd1
     &         + ( ( phi(CHF_IX[i-1;j;k])+phi(CHF_IX[i+1;j;k]) )*(-4)
     &           + ( phi(CHF_IX[i;j-1;k])+phi(CHF_IX[i;j+1;k]) )*2
     &           + ( phi(CHF_IX[i;j;k-1])+phi(CHF_IX[i;j;k+1]) )*8
     &           + ( phi(CHF_IX[i-1;j-1;k])+phi(CHF_IX[i+1;j-1;k])
     &           + phi(CHF_IX[i-1;j+1;k])+phi(CHF_IX[i+1;j+1;k]))*(-2)
     &           + ( phi(CHF_IX[i;j-1;k-1])+phi(CHF_IX[i;j-1;k-1])
     &             + phi(CHF_IX[i;j+1;k-1])+phi(CHF_IX[i;j+1;k+1]) )
     &           + ( phi(CHF_IX[i-1;j;k-1])+phi(CHF_IX[i+1;j;k-1])
     &             + phi(CHF_IX[i-1;j;k+1])+phi(CHF_IX[i+1;j;k+1]) )*4
     &           + phi(CHF_IX[i;j;k])*(-24) ) * invdxsqrd2
        CHF_ENDDO

      elseif( Op .EQ. 2 )then
!       Op 2 is 7-point operator (standard)
!       coefficients are:
!       -2 / dx[d]^2 for self for each direction
!        1 / dx[d]^2 for points differing by 1 in one coordinate
!        0 for points differing by 1 in two coordinates
!        0 for points differing by 1 in three coordinates
        invdxsqrd0 = one / ( Dx(0) * Dx(0) )
        invdxsqrd1 = one / ( Dx(1) * Dx(1) )
        Invdxsqrd2 = one / ( Dx(2) * Dx(2) )
        CHF_MULTIDO[ Bx; i;j;k ]
          CHF_DTERM[lphi = ( phi(CHF_IX[i-1;j  ;k  ])
     &                     - phi(CHF_IX[i  ;j  ;k  ])
     &                     - phi(CHF_IX[i  ;j  ;k  ])
     &                     + phi(CHF_IX[i+1;j  ;k  ]) ) * invdxsqrd0 ;
     &                   + ( phi(CHF_IX[i  ;j-1;k  ])
     &                     - phi(CHF_IX[i  ;j  ;k  ])
     &                     - phi(CHF_IX[i  ;j  ;k  ])
     &                     + phi(CHF_IX[i  ;j+1;k  ]) ) * invdxsqrd1 ;
     &                   + ( phi(CHF_IX[i  ;j  ;k-1])
     &                     - phi(CHF_IX[i  ;j  ;k  ])
     &                     - phi(CHF_IX[i  ;j  ;k  ])
     &                     + phi(CHF_IX[i  ;j  ;k+1]) ) * invdxsqrd2 ]
          lofphi(CHF_IX[i;j;k]) = lphi
        CHF_ENDDO

      elseif( Op .EQ. 3 )then
        if( .not. IsotropicGrid )then
          print *,'fatalerror: EVALOP: 27point stencil is not '
     &           ,'implemented for anisotropic grids'
          call MAYDAYERROR()
        endif
!       Op 3 is 27-point operator for isotropic grids only
!       coefficients are:
!       -128/30 / dx[d]^2 for self
!          7/15 / dx[d]^2 for points differing by 1 in one coordinate
!          1/10 / dx[d]^2 for points differing by 1 in two coordinates
!          1/30 / dx[d]^2 for points differing by 1 in three coordinates
        invdxsqrd0 = one / ( Dx(0) * Dx(0) )
        CHF_MULTIDO[bx; i; j; k]
          lphi = (- (ten*ten + twenty + eight) / (three * ten) *
     &         phi(CHF_IX[i; j; k]) +
     &         seven / fifteen * (
     &         phi(CHF_IX[i-1; j; k]) + phi(CHF_IX[i+1; j; k]) +
     &         phi(CHF_IX[i; j-1; k]) + phi(CHF_IX[i; j+1; k]) +
     &         phi(CHF_IX[i; j; k-1]) + phi(CHF_IX[i; j; k+1])) +
     &         tenth * (
     &         phi(CHF_IX[i-1; j-1; k]) + phi(CHF_IX[i-1; j+1; k]) +
     &         phi(CHF_IX[i+1; j-1; k]) + phi(CHF_IX[i+1; j+1; k]) +
     &         phi(CHF_IX[i-1; j; k-1]) + phi(CHF_IX[i-1; j; k+1]) +
     &         phi(CHF_IX[i+1; j; k-1]) + phi(CHF_IX[i+1; j; k+1]) +
     &         phi(CHF_IX[i; j-1; k-1]) + phi(CHF_IX[i; j-1; k+1]) +
     &         phi(CHF_IX[i; j+1; k-1]) + phi(CHF_IX[i; j+1; k+1]) ) +
     &         tenth / three * (
     &         phi(CHF_IX[i-1; j-1; k-1]) + phi(CHF_IX[i-1; j-1; k+1]) +
     &         phi(CHF_IX[i-1; j+1; k-1]) + phi(CHF_IX[i-1; j+1; k+1]) +
     &         phi(CHF_IX[i+1; j-1; k-1]) + phi(CHF_IX[i+1; j-1; k+1]) +
     &         phi(CHF_IX[i+1; j+1; k-1]) + phi(CHF_IX[i+1; j+1; k+1])))
     &         * invdxsqrd0
          lofphi(CHF_IX[i; j; k]) =  lphi
        CHF_ENDDO

      else
        print *, 'fatalerror: EVALOP: Op must be 1,2 or 3, not ', Op
        call MAYDAYERROR()
      endif

      return
      end
