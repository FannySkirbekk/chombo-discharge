C      _______              __
C     / ___/ /  ___  __ _  / /  ___
C    / /__/ _ \/ _ \/  V \/ _ \/ _ \
C    \___/_//_/\___/_/_/_/_.__/\___/
C    Please refer to Copyright.txt, in Chombo's root directory.

#include "CONSTANTS.H"

      subroutine getnormal(
     &     CHF_FRA1[deriv],
     &     CHF_CONST_FRA1[f],
     &     CHF_BOX[drvbox],
     &     CHF_CONST_R1D[coeff],
     &     CHF_CONST_INT[idir],
     &     CHF_CONST_INT[side])
!     Returns an approximation to normal derivatives of f on a faces
!     of a domain.
!
!     => inputs, <= outputs
!     deriv <= the discrete normal derivative of data
!     f => the data
!     drvbox => the box on which the normal derivative is calculated
!     coeff => coefficients of discrete normal derivative approximation
!     deg => degree of approximation of derivatives
!     idir => the direction of the derivative (0, 1, 2)
!     side => side (-1, 1)
!
!     The error in the approximation is O(h^deg).
      integer CHF_DDECL[i; j; k]
      integer CHF_DDECL[ii; jj; kk]
      integer p, deg
      REAL_T drvpt

      deg = CHF_UBOUND[coeff]
!     If high side, one of ii, jj, kk is +1, and the others are 0.
!     If low side, one of ii, jj, kk is -1, and the others are 0.
      CHF_DTERM[
      ii = side * CHF_ID(idir, 0) ;
      jj = side * CHF_ID(idir, 1) ;
      kk = side * CHF_ID(idir, 2) ]

      CHF_MULTIDO[drvbox; i; j; k]
         drvpt = zero
         do p = 0, deg
            drvpt = drvpt - coeff(p) *
     &           f(CHF_IX[i - ii*p; j - jj*p; k - kk*p])
         enddo
         deriv(CHF_IX[i; j; k]) = drvpt
      CHF_ENDDO

      return
      end


      subroutine getnormalextra(
     &     CHF_FRA1[deriv],
     &     CHF_CONST_FRA1[f],
     &     CHF_CONST_FRA1[fext],
     &     CHF_BOX[drvbox],
     &     CHF_CONST_R1D[coeff],
     &     CHF_CONST_INT[idir],
     &     CHF_CONST_INT[side])
!     Returns an approximation to normal derivatives of f on a faces
!     of a domain.
!
!     => inputs, <= outputs
!     deriv <= the discrete normal derivative of data
!     f => the data
!     fext => the data on an outer layer
!     drvbox => the box on which the normal derivative is calculated
!     coeff:  coefficients of discrete normal derivative approximation
!     deg => degree of approximation of derivatives
!     idir => the direction of the derivative (0 or 1 or 2)
!     side => side (-1 or 1)
!
!     The error in the approximation is O(h^deg).
      integer CHF_DDECL[i; j; k]
      integer CHF_DDECL[ii; jj; kk]
      integer p, deg
      REAL_T drvpt

      deg = CHF_UBOUND[coeff]
!     If high side, one of ii, jj, kk is +1, and the others are 0.
!     If low side, one of ii, jj, kk is -1, and the others are 0.
      CHF_DTERM[
      ii = side * CHF_ID(idir, 0) ;
      jj = side * CHF_ID(idir, 1) ;
      kk = side * CHF_ID(idir, 2) ]

      CHF_MULTIDO[drvbox; i; j; k]
         drvpt = -coeff(0) * fext(CHF_IX[i + ii; j + jj; k + kk])
         do p = 0, deg-1
            drvpt = drvpt - coeff(p+1) *
     &           f(CHF_IX[i - ii*p; j - jj*p; k - kk*p])
         enddo
         deriv(CHF_IX[i; j; k]) = drvpt
      CHF_ENDDO

      return
      end
