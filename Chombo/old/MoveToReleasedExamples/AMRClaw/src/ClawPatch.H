#ifdef CH_LANG_CC
/*
 *      _______              __
 *     / ___/ /  ___  __ _  / /  ___
 *    / /__/ _ \/ _ \/  V \/ _ \/ _ \
 *    \___/_//_/\___/_/_/_/_.__/\___/
 *    Please refer to Copyright.txt, in Chombo's root directory.
 */
#endif

#ifndef _CLAWPATCH_H_
#define _CLAWPATCH_H_

#include <iostream>
using std::ifstream;
using std::ios;


#include "ParmParse.H"
#include "Box.H"
#include "IntVectSet.H"
#include "Vector.H"
#include "FArrayBox.H"

#include "UsingNamespace.H"

// The following are the parameters needed by Clawpack.  Most of these are included
// as member data items in the class ClawPatch, defined below.  Several are not used
// in the current implemenation, but are put in for future use (e.g. aux and maux).
//
//  c    meqn is the number of equations in the system of
//  c         conservation laws.
//  c
//  c    mwaves is the number of waves that result from the
//  c           solution of each Riemann problem.  Often mwaves = meqn but
//  c           for some problems these may be different, e.g. for the Euler
//  c           equations meqn = 5 but mwaves =  since there are only 3
//  c           distinct wave speeds.
//  c
//  c    mbc is the number of "ghost cells" that must be added on to each
//  c       side of the domain to handle boundary conditions.  The cells
//  c       actually in the physical domain are labelled from 1 to mx in x,
//  c       from 1 to my in y, and from 1 to mz in z.
//  c       The arrays are dimensioned actually indexed
//  c       from 1-mbc to mx+mbc, from 1-mbc to my+mbc and from 1-mbc
//  c       to mz+mbc.
//  c       For the methods currently implemented, mbc = 2 should be used.
//  c       If the user implements another method that has a larger stencil and
//  c       hence requires more ghost cells, a larger value of mbc could be used.
//  c       q is extended from the physical domain to the ghost cells by the
//  c       user-supplied routine bc2.
//  c
//  c    method(1:7) = array of values specifying the numerical method to use
//  c                  and also indicating whether source terms, capacity
//  c                  function, auxiliary variables are present in the equation.
//
// -----------------------------------------------------------------------------------
// ChomboClaw Notes : Only method(2:3) below are currently used. method(6:7) will
//                    be added later, when aux arrays and capacity form differencing
//                    are implemented
// -----------------------------------------------------------------------------------
//
//  c
//  c         method(1) = 0 if fixed size time steps are to be taken.
//  c                       In this case, dt = dtv(1) in all steps.
//  c                   = 1 if variable time steps are to be used.
//  c
//  c         method(2) = 1 if only first order increment waves are to be used.
//  c                   = 2 if second order correction terms are to be added, with
//  c                       a flux limiter as specified by mthlim.
//  c
//  c         method(3) <  0 Gives dimensional splitting using Godunov
//  c                        splitting, i.e. formally first order
//  c                        accurate.
//  c                      0 Gives the Donor cell method. No transverse
//  c                        propagation of neither the increment wave
//  c                        nor the correction wave.
//  c                   = 10 Transverse propagation of the increment wave
//  c                        as in 2D. Note that method (2,10) is
//  c                        unconditionally unstable.
//  c                   = 11 Corner transport upwind of the increment
//  c                        wave. Note that method (2,11) also is
//  c                        unconditionally unstable.
//  c                   = 20 Both the increment wave and the correction
//  c                        wave propagate as in the 2D case. Only to
//  c                        be used with method(2) = 2.
//  c                   = 21 Corner transport upwind of the increment wave,
//  c                        and the correction wave propagates as in 2D.
//  c                        Only to be used with method(2) = 2.
//  c                   = 22 3D propagation of both the increment wave and
//  c                        the correction wave. Only to be used with
//  c                        method(2) = 2.
//  c
//  c         method(4) = 0 to suppress printing
//  c                   = 1 to print dt and Courant number every time step
//  c
//  c         method(5) = 0 if there is no source term psi.  In this case
//  c                       the subroutine src2 is never called so a dummy
//  c                       parameter can be given.
//  c                   = 1 if there is a source term.  In this case
//  c                       the subroutine src2 must be provided.
//  c
//  c         method(6) = 0 if there is no capacity function capa.
//  c                   = mcapa > 0 if there is a capacity function.  In this case
//  c                       aux(i,j,k,mcapa) is the capacity of cell (i,j,k)
//  c                       and you must also specify method(7) .ge. mcapa
//  c                       and set aux.
//  c
//  c         method(7) = 0 if there is no aux array used.
//  c                   = maux > 0  if there are maux auxiliary variables.
//  c
//  c         The recommended choice of methods for most problems is
//  c            method(1) = 1,  method(2) = 2,  method(3) = 22.
//  c
//  c    mthlim(1:mwaves) = array of values specifying the flux limiter to be used
//  c                     in each wave family mw.  Often the same value will be used
//  c                     for each value of mw, but in some cases it may be
//  c                     desirable to use different limiters.  For example,
//  c                     for the Euler equations the superbee limiter might be
//  c                     used for the contact discontinuity (mw=2) while another
//  c                     limiter is used for the nonlinear waves.  Several limiters
//  c                     are built in and others can be added by modifying the
//  c                     subroutine philim.
//  c
//  c        mthlim(mw) = 0 for no limiter
//  c                   = 1 for minmod
//  c                   = 2 for superbee
//  c                   = 3 for van Leer
//  c                   = 4 for monotonized centered
//  c
//  c    aux(1-mbc:maxmx+mbc, 1-mbc:maxmy+mbc, 1-mbc:maxmy+mbc,maux)
//  c        Array of auxiliary variables that are used in specifying the problem.
//  c        If method(7) = 0 then there are no auxiliary variables and aux
//  c                         can be a dummy variable.
//  c        If method(7) = maux > 0 then there are maux auxiliary variables
//  c                         and aux must be dimensioned as above.
//  c
//  c        Capacity functions are one particular form of auxiliary variable.
//  c        These arise in some applications, e.g. the
//  c        determinant of the Jacobian if a mapped grid is used, or a density
//  c        or porosity function in some advection problems.
//  c        See Clawpack Note # 5 for examples.
//  c
//  c        If method(6) = 0 then there is no capacity function.
//  c        If method(6) = mcapa > 0  then there is a capacity function and
//  c            capa(i,j,k), the "capacity" of the (i,j,k) cell, is assumed to be
//  c            stored in aux(i,j,k,mcapa).
//  c            In this case we require method(7).ge.mcapa.
//  c

extern "C"
{
    void set_common_levels_(const int& maxlevel,
                            const int& a_level,
                            const int* refratios);

#if CH_SPACEDIM==2
    void qinit_(const int& maxmx,
                 const int& maxmy,
                 const int& meqn,
                 const int& mbc,
                 const int& mx,
                 const int& my,
                 const Real& xlower,
                 const Real& ylower,
                 const Real& dx,
                 const Real& dy,
                 Real q[],
                 const int& maux,
                 Real aux[]);


        //       subroutine setaux(maxmx,maxmy,mbc,mx,my,xlower,ylower,dx,dy,
        //      &                  maux,aux)

    void setaux_(const int& maxmx,
                 const int& maxmy,
                 const int& mbc,
                 const int& mx,
                 const int& my,
                 const Real& xlower,
                 const Real& ylower,
                 const Real& dx,
                 const Real& dy,
                 const int& maux,
                 Real aux[]);

    void setprob_();

    void bc2_(const int& maxmx,
              const int& maxmy,
              const int& meqn,
              const int& mbc,
              const int& mx,
              const int& my,
              const Real& xlower,
              const Real& ylower,
              const Real& dx,
              const Real& dy,
              const Real q[],
              const int& maux,
              const Real aux[],
              const Real& t,
              const Real& dt,
              const int mthbc[]);

    void clawpatch2_(const int& maxm,
                     const int& meqn,
                     const int& maux,
                     const int& mbc,
                     int method[],
                     int mthlim[],
                     const int& mcapa,
                     const int& mwaves,
                     const int& mx,
                     const int& my,
                     Real qold[],
                     Real auxold[],
                     const Real& dx,
                     const Real& dy,
                     const Real& dt,
                     const Real& cfl,
                     Real work[],
                     const int& mwork,
                     Real qold_coarse[],
                     Real auxold_coarse[],
                     Real qadd_x[],
                     Real qadd_y[],
                     const int auxtype_int[],
                     const Real& xlower,
                     const Real& ylower,
                     int* intersectsBoundaries,
                     const int& level,
                     const int mthbc[],
                     const Real& t,
                     const int& mxc,
                     const int& myc,
                     Real fp[],
                     Real fm[],
                     Real gp[],
                     Real gm[],
                     Real fp_chombo[],
                     Real fm_chombo[],
                     Real gp_chombo[],
                     Real gm_chombo[],
                     Real fpc_chombo[],
                     Real fmc_chombo[],
                     Real gpc_chombo[],
                     Real gmc_chombo[]);


    void estimate_error2_(const int& mx,
                         const int& my,
                         const int& mbc,
                         const int& meqn,
                         const Real& xlower,
                         const Real& ylower,
                         const Real& dx,
                         const Real& dy,
                         const Real& t,
                         const int& level,
                         const int isBoundary[],
                         const Real& a_refineThresh,
                         const Real *q,
                         Real em[]);


#elif CH_SPACEDIM==3
    void qinit_(const int& maxmx, const int& maxmy, const int& maxmz,
               const int& meqn,const int& mbc,
               const int& mx, const int& my, const int& mz,
               const Real& xlower, const Real& ylower, const Real& zlower,
               const Real& dx, const Real& dy, const Real& dz,
               Real q[], const int& maux, Real aux[]);

    void setaux_(const int& maxmx,
                 const int& maxmy,
                 const int& maxmz,
                 const int& mbc,
                 const int& mx,
                 const int& my,
                 const int& mz,
                 const Real& xlower,
                 const Real& ylower,
                 const Real& zlower,
                 const Real& dx,
                 const Real& dy,
                 const Real& dz,
                 const int& maux,
                 Real aux[]);

    void setprob_();

    void bc3_(const int& maxmx,
              const int& maxmy,
              const int& maxmz,
              const int& meqn,
              const int& mbc,
              const int& mx,
              const int& my,
              const int& mz,
              const Real& xlower,
              const Real& ylower,
              const Real& zlower,
              const Real& dx,
              const Real& dy,
              const Real& dz,
              const Real q[],
              const int& maux,
              const Real aux[],
              const Real& t,
              const Real& dt,
              const int mthbc[]);

    void clawpatch3_(const int& maxm,
                     const int& meqn,
                     const int& maux,
                     const int& mbc,
                     int method[],
                     int mthlim[],
                     const int& mcapa,
                     const int& mwaves,
                     const int& mx,
                     const int& my,
                     const int& mz,
                     Real qold[],
                     Real aux[],
                     const Real& dx,
                     const Real& dy,
                     const Real& dz,
                     const Real& dt,
                     const Real& cfl,
                     Real work[],
                     const int& mwork,
                     Real qold_coarse[],
                     Real auxold_coarse[],
                     Real qadd_x[],
                     Real qadd_y[],
                     Real qadd_z[],
                     const int auxtype_int[],
                     const Real& xlower,
                     const Real& ylower,
                     const Real& zlower,
                     int* intersectsBoundaries,
                     const int& level,
                     const int mthbc[],
                     const Real& t,
                     const int& mxc,
                     const int& myc,
                     const int& mzc,
                     Real fp[],
                     Real fm[],
                     Real gp[],
                     Real gm[],
                     Real hm[],
                     Real hp[],
                     Real fp_chombo[],
                     Real fm_chombo[],
                     Real gp_chombo[],
                     Real gm_chombo[],
                     Real hp_chombo[],
                     Real hm_chombo[],
                     Real fpc_chombo[],
                     Real fmc_chombo[],
                     Real gpc_chombo[],
                     Real gmc_chombo[],
                     Real hpc_chombo[],
                     Real hmc_chombo[]);


    void estimate_error3_(const int& mx,
                         const int& my,
                         const int& mz,
                         const int& mbc,
                         const int& meqn,
                         const Real& xlower,
                         const Real& ylower,
                         const Real& zlower,
                         const Real& dx,
                         const Real& dy,
                         const Real& dz,
                         const Real& t,
                         const int& level,
                         const int isBoundary[],
                         const Real& a_refineThresh,
                         const Real* q,
                         Real em[]);

#endif



}

class ClawPatch
{

public :
    ClawPatch();
    ~ClawPatch();

    // Do I need this?
    // void define(ProblemDomain& a_domain, const Real& a_dx);
    void define(const ClawPatch& a_clawPatch);
    bool isDefined();

    void get_inputParams(); // Read from input file
    void print_inputParams();  // Print out for beginning info

    void set_mx(int mx);
    void set_my(int my);
#if CH_SPACEDIM == 3
    void set_mz(int mz);
#endif
    void set_order(std::vector<int> order);
    void set_src(int src);
    void set_mcapa(int mcapa);
    void set_maux(int maux);
    void set_mbc(int mbc);
    void set_meqn(int meqn);
    void set_mwaves(int mwaves);
    void set_mthlim(std::vector<int> mthlim);
    void set_mthbc(std::vector<int> mthbc);
    void set_stateNames(std::vector<std::string> a_stateNames);
    void set_auxtype(std::vector<std::string> a_auxtype);
    void set_xlower(Real xlower);
    void set_ylower(Real ylower);
#if CH_SPACEDIM == 3
    void set_zlower(Real zlower);
#endif
    void set_xupper(Real xupper);
    void set_yupper(Real yupper);
#if CH_SPACEDIM == 3
    void set_zupper(Real zupper);
#endif

    void set_initial_dt(Real a_initial_dt);
    int get_mx() const;
    int get_my() const;
#if CH_SPACEDIM == 3
    int get_mz() const;
#endif

    Real get_initial_dt() const;
    int get_meqn() const;
    int get_mbc() const;
    int get_maux() const;
    int get_mcapa() const;
    int get_mwaves() const;
    int* get_mthbc() const;
    Real get_xlower() const;
    Real get_ylower() const;
#if CH_SPACEDIM == 3
    Real get_zlower() const;
#endif
    Real get_xupper() const;
    Real get_yupper() const;
#if CH_SPACEDIM == 3
    Real get_zupper() const;
#endif

    void set_refratios(std::vector<int> a_refratios);
    void set_maxlevel(const int& a_maxlevel);
    int* get_refratios() const;
    int get_maxlevel() const;

    Real get_max_cfl() const;
    void set_max_cfl(const Real& max_cfl);

    std::vector<std::string> get_stateNames() const;
    std::vector<std::string> get_auxtype() const;

    //    void initialize(LevelData<FArrayBox>& a_phi, LevelData<FArrayBox>& a_aux, Real dx);
    void initialize(FArrayBox& a_phi,FArrayBox& a_aux, const Box& a_box, Real dx);

    void setAuxArray(FArrayBox& a_aux,
                     const Box& a_box,
                     Real a_dx,
                     const int& a_level);

    Real ClawPatchIntegrator(FArrayBox& a_phiPatch,
                             FArrayBox& a_auxPatch,
                             FArrayBox a_fluxp[],
                             FArrayBox a_fluxmc[],
                             FArrayBox a_fluxpc[],
                             FArrayBox a_fluxm[],
                             FArrayBox& a_phiCoarse,
                             FArrayBox& a_auxCoarse,
                             FArrayBox a_qadd[],
                             const Box& a_patchBox,
                             const ProblemDomain& a_domain,
                             const Real& a_time,
                             const Real& a_dt,
                             const Real& a_dx,
                             const int& refRatio,const int& a_level);

    void estimateError(const FArrayBox& a_phiPatch,
                       const Box& a_patchBox,
                       const ProblemDomain& a_domain,
                       const Real& a_time,
                       const Real& a_dt,
                       const Real& a_dx,
                       const int& a_level,
                       const int isBoundary[],
                       const Real& a_refineThresh,
                       FArrayBox& a_error_measure);


protected :

    // Parameters needed by Clawpack code.  These are described above.
    // some options described above may not be available here...
    // These are the initial m_mx, m_my.  Not the values for an individual patch
    int  m_mx;
    int  m_my;
#if CH_SPACEDIM == 3
    int m_mz;
#endif
    Real m_initial_dt;

    int  m_mbc;        // Number of ghost cells

    int  m_meqn;       // Number of equations (nComp())
    int  m_mwaves;     // Number of waves (<= meqn)
    bool m_mwavesIsSet;

    int *m_mthlim;  // Limiters used for each wave.
    int *m_method;  // Numerical method to use;
                                 // Only method(2:3) (.e.g. method[1:2] in C indexing)
                                 // are use in current implementation.

    int  m_maux;
    int  m_mcapa;
    int *m_mthbc; // boundary conditions

    int *m_refratios;
    int m_maxlevel;
    bool m_maxlevelIsSet;

    std::vector<std::string> m_stateNames;
    std::vector<std::string> m_auxtype;
    int* m_auxtype_int;  // for communication with fortran

    Real m_xlower;
    Real m_ylower;
#if CH_SPACEDIM == 3
    Real m_zlower;
#endif

    Real m_xupper;
    Real m_yupper;
#if CH_SPACEDIM == 3
    Real m_zupper;
#endif

    Real m_max_cfl;

    bool m_isDefined;

private :
#if CH_SPACEDIM ==2
    void get_clawvars(const Box& a_box, const Real& dx, const Real& dy,
                      Real& xlower, Real& ylower, int& mx, int& my);
#elif CH_SPACEDIM == 3
    void get_clawvars(const Box& a_box, const Real& dx, const Real& dy, const Real& dz,
                      Real& xlower, Real& ylower, Real& zlower,
                      int& mx, int& my, int& mz);
#endif

    void set_method(std::vector<int> a_method);

    // These should only be called when we have the dimension
    void set_method(int* a_method);
    void set_mthbc(int* mthbc);
    void set_mthlim(int* mthlim);
    void set_refratios(int* refratios);

}; // End class ClawPatch

#endif
