C      _______              __
C     / ___/ /  ___  __ _  / /  ___
C    / /__/ _ \/ _ \/  V \/ _ \/ _ \
C    \___/_//_/\___/_/_/_/_.__/\___/
C    Please refer to Copyright.txt, in Chombo's root directory.

#include "CONSTANTS.H"

      subroutine GETUNITNORMALS(
     &     CHF_FRA[unitNormal],
     &     CHF_CONST_FRA[faceMetric],
     &     CHF_CONST_INTVECT[normalComponents],
     &     CHF_CONST_INT[dirn],
     &     CHF_BOX[box])

      integer CHF_DDECL[compx;compy;compz]
      integer CHF_DDECL[i;j;k]
      integer idir
      integer CHF_DDECL[base0;base1;base2]
      real_t CHF_DDECL[nx;ny;nz]
      real_t CHF_DDECL[nvecx;nvecy;nvecz]
      real_t nmag
#if CH_SPACEDIM >= 3
      integer indmin
      real_t ndir, nmin, tanvec(0:2), tmag
#endif

!     Use compx, compy, compz to index into faceMetric.
      CHF_DTERM[
      compx = normalComponents(0) ;
      compy = normalComponents(1) ;
      compz = normalComponents(2) ]

!     base0, base1, base2 are the base indices within unitNormal
!     of the first, second, and third basis vectors.
      CHF_DTERM[
      base0 = CH_SPACEDIM * dirn ;
      base1 = mod(base0 + CH_SPACEDIM, CH_SPACEDIM*CH_SPACEDIM) ;
      base2 = mod(base1 + CH_SPACEDIM, CH_SPACEDIM*CH_SPACEDIM) ]

      CHF_MULTIDO[box;i;j;k]
!     Start with NON-unit normal vector nvec, of magnitude nmag.
         CHF_DTERM[
         nvecx = faceMetric(CHF_IX[i;j;k], compx) ;
         nvecy = faceMetric(CHF_IX[i;j;k], compy) ;
         nvecz = faceMetric(CHF_IX[i;j;k], compz) ]

         nmag = sqrt(CHF_DTERM[
     &        nvecx*nvecx ;
     &        + nvecy*nvecy ;
     &        + nvecz*nvecz ])

!     FIRST basis vector in unitNormal :  normalized nvec.
         CHF_DTERM[
         nx = nvecx / nmag ;
         ny = nvecy / nmag ;
         nz = nvecz / nmag ]

         CHF_DTERM[
         unitNormal(CHF_IX[i;j;k], base0    ) = nx ;
         unitNormal(CHF_IX[i;j;k], base0 + 1) = ny ;
         unitNormal(CHF_IX[i;j;k], base0 + 2) = nz ]

#if (CH_SPACEDIM == 2)
!     In 2D, SECOND basis vector is (ny, -nx).
         unitNormal(CHF_IX[i;j;k], base1    ) = ny
         unitNormal(CHF_IX[i;j;k], base1 + 1) = -nx
#elif (CH_SPACEDIM >= 3)
!     In 3D, SECOND basis vector is normalized e^d - (n dot e^d) n
!     where n is the first basis vector, and d is the index of n's
!     smallest component in absolute value.

!     indmin is index of smallest component of (nx, ny, nz).
!     initial indmin and nmin are bogus and WILL be replaced.
         indmin = -1
         nmin = two
         do idir = 0, CH_SPACEDIM-1
            ndir = unitNormal(CHF_IX[i;j;k], base0 + idir)
            if (ndir*ndir .lt. nmin*nmin) then
               indmin = idir
               nmin = ndir
            endif
         enddo
!     Work it out:  magnitude of unnormalized tanvec is sqrt(1 - nmin^2).
         tmag = sqrt(one - nmin*nmin)
         do idir = 0, CH_SPACEDIM-1
            if (idir .eq. indmin) then
               tanvec(idir) = (one - nmin*nmin) / tmag
            else
               tanvec(idir) = -nmin *
     &              unitNormal(CHF_IX[i;j;k], base0 + idir) / tmag
            endif
         enddo
         unitNormal(CHF_IX[i;j;k], base1    ) = tanvec(0);
         unitNormal(CHF_IX[i;j;k], base1 + 1) = tanvec(1);
         unitNormal(CHF_IX[i;j;k], base1 + 2) = tanvec(2);

!     The THIRD basis vector is the cross product of the first two.
         unitNormal(CHF_IX[i;j;k], base2    ) =
     &        ny*tanvec(2) - nz*tanvec(1)
         unitNormal(CHF_IX[i;j;k], base2 + 1) =
     &        nz*tanvec(0) - nx*tanvec(2)
         unitNormal(CHF_IX[i;j;k], base2 + 2) =
     &        nx*tanvec(1) - ny*tanvec(0)
#endif
      CHF_ENDDO

      return
      end


!     Simplified from MappedGridPPMAMRGodunov
      subroutine FORWARDTRANSFORMF(
     &     CHF_FRA[data],
     &     CHF_CONST_FRA[basis],
     &     CHF_BOX[box])

      integer CHF_DDECL[i;j;k]
      real_t CHF_DDECL[datax;datay;dataz]

      CHF_MULTIDO[box;i;j;k]
         CHF_DTERM[
         datax = data(CHF_IX[i;j;k], 0) ;
         datay = data(CHF_IX[i;j;k], 1) ;
         dataz = data(CHF_IX[i;j;k], 2) ]

         CHF_DSELECT[
!     1D:  set 0
         data(CHF_IX[i;j;k], 0) =
     &          datax * basis(CHF_IX[i;j;k], 0) ;
!     2D:  set 0 and 1
         data(CHF_IX[i;j;k], 0) =
     &          datax * basis(CHF_IX[i;j;k], 0)
     &        + datay * basis(CHF_IX[i;j;k], 1)
         data(CHF_IX[i;j;k], 1) =
     &          datax * basis(CHF_IX[i;j;k], 2)
     &        + datay * basis(CHF_IX[i;j;k], 3) ;
!     3D:  set 0 and 1 and 2
         data(CHF_IX[i;j;k], 0) =
     &          datax * basis(CHF_IX[i;j;k], 0)
     &        + datay * basis(CHF_IX[i;j;k], 1)
     &        + dataz * basis(CHF_IX[i;j;k], 2)
         data(CHF_IX[i;j;k], 1) =
     &          datax * basis(CHF_IX[i;j;k], 3)
     &        + datay * basis(CHF_IX[i;j;k], 4)
     &        + dataz * basis(CHF_IX[i;j;k], 5)
         data(CHF_IX[i;j;k], 2) =
     &          datax * basis(CHF_IX[i;j;k], 6)
     &        + datay * basis(CHF_IX[i;j;k], 7)
     &        + dataz * basis(CHF_IX[i;j;k], 8) ]
      CHF_ENDDO

      return
      end


!     Simplified from MappedGridPPMAMRGodunov
      subroutine REVERSETRANSFORMF(
     &     CHF_FRA[data],
     &     CHF_CONST_FRA[basis],
     &     CHF_BOX[box])

      integer CHF_DDECL[i;j;k]
      real_t CHF_DDECL[datax;datay;dataz]

      CHF_MULTIDO[box;i;j;k]
         CHF_DTERM[
         datax = data(CHF_IX[i;j;k], 0) ;
         datay = data(CHF_IX[i;j;k], 1) ;
         dataz = data(CHF_IX[i;j;k], 2) ]

         CHF_DSELECT[
!     1D:  set 0
         data(CHF_IX[i;j;k], 0) =
     &          datax * basis(CHF_IX[i;j;k], 0) ;
!     2D:  set 0 and 1
         data(CHF_IX[i;j;k], 0) =
     &          datax * basis(CHF_IX[i;j;k], 0)
     &        + datay * basis(CHF_IX[i;j;k], 2)
         data(CHF_IX[i;j;k], 1) =
     &          datax * basis(CHF_IX[i;j;k], 1)
     &        + datay * basis(CHF_IX[i;j;k], 3) ;
!     3D:  set 0 and 1 and 2
         data(CHF_IX[i;j;k], 0) =
     &          datax * basis(CHF_IX[i;j;k], 0)
     &        + datay * basis(CHF_IX[i;j;k], 3)
     &        + dataz * basis(CHF_IX[i;j;k], 6)
         data(CHF_IX[i;j;k], 1) =
     &          datax * basis(CHF_IX[i;j;k], 1)
     &        + datay * basis(CHF_IX[i;j;k], 4)
     &        + dataz * basis(CHF_IX[i;j;k], 7)
         data(CHF_IX[i;j;k], 2) =
     &          datax * basis(CHF_IX[i;j;k], 2)
     &        + datay * basis(CHF_IX[i;j;k], 5)
     &        + dataz * basis(CHF_IX[i;j;k], 8) ]
        CHF_ENDDO

        return
        end
