assert(SpaceDim == 2)

verbosity = 1

# Time stepping
max_step = 10
max_time = 2.0
fixed_dt = 0.06  # Use dt ~ 1.6/num_cells
cfl = 0.75
initial_cfl = 0.75
max_dt_growth = 1.1
dt_tolerance_factor = 1.1

# Computational domain and coordinate system.
coord_sys = 'cubed_sphere'
num_cells = 24

# AMR
max_level = 1
ref_ratio = 2

# Regridding parameters
regrid_interval = 2
tag_buffer_size = 2
refine_thresh = 0.15
refinement_is_scaled = 1

# Grid generation parameters
block_factor = 8
max_grid_size = 32
fill_ratio = 0.75
grid_buffer_size = 0

#use_subcycling = False
useHyperviscosity = 0
hyperviscosity = 0.01

limitFaceValues = 1
enforceMinVal = 1
minVal = 0.0

# Great circle distance between two points on the unit sphere.
# (This uses the Vincenty formula.)
def gcd(ll1, ll2):
    lambda1, lambda2 = ll1[0], ll2[0] # Longitudes
    phi1, phi2 = ll1[1], ll2[1]       # Latitudes
    deltaLambda = lambda2-lambda1
    cosDeltaLambda, sinDeltaLambda = cos(deltaLambda),sin(deltaLambda)
    cosPhi1, sinPhi1 = cos(phi1),sin(phi1)
    cosPhi2, sinPhi2 = cos(phi2),sin(phi2)
    return atan2(sqrt((cosPhi2*sinDeltaLambda)**2 + \
                      (cosPhi1*sinPhi2 - sinPhi1*cosPhi2*cosDeltaLambda)**2), \
                 sinPhi1*sinPhi2 + cosPhi1*cosPhi2*cosDeltaLambda)

# Gaussian initial conditions in (lon, lat) coordinates.
center = (0,0)
def phi0(ll, t):
#    return 1
    if ll[0] > pi: # Fix the longtitude to the interval [-pi, pi]
        ll = (ll[0]-2*pi, ll[1])
    r = gcd(ll, center)
    return 1 + exp(-8*r*r)

# Let's go around the equator.
# velocity = (vlambda, vphi)
def velocity(ll, t):
    lon, lat = ll
    return (cos(lat),0)

# Velocity stream function.
#def stream_function(ll, t):
#    return 0

# Output
checkpoint_interval = -1
plot_interval = 1
plot_prefix = 'plot/Gaussian-advection-sphere.%d.'%num_cells
chk_prefix  = 'checkpoint/Gaussian-advection-sphere.%d.'%num_cells

