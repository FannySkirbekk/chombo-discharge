import distutils.sysconfig
print distutils.sysconfig.get_python_lib()

assert(SpaceDim == 2)

verbosity = 1
#forward_euler = True

# Time stepping
max_step = 2
max_time = 1.0
fixed_dt = 0.005
cfl = 0.75
initial_cfl = 0.75
max_dt_growth = 1.1
dt_tolerance_factor = 1.1

# Computational domain.
coord_sys = 'double_cartesian'
num_cells = 24  # Minimum allowed is 24 for proper nesting

# Start from corners? 
corners = False

# AMR
max_level = 1
ref_ratio = 2 

# Fixed box layouts.
# ------------------

# Easiest: refinement patches in the middle of blocks
#boxes = [[Box(lo = (0, 0), hi = (num_cells-1, num_cells-1)),
#          Box(lo = (2*num_cells, 0), hi = (3*num_cells-1, num_cells-1)),
#          Box(lo = (0, 2*num_cells), hi = (num_cells-1, 3*num_cells-1)),
#          Box(lo = (2*num_cells, 2*num_cells), hi = (3*num_cells-1, 3*num_cells-1))], # Level 0
#         [Box(lo = (ref_ratio*num_cells/4, ref_ratio*num_cells/4), hi = (3*ref_ratio*num_cells/4-1, 3*ref_ratio*num_cells/4-1)),
#          Box(lo = (9*ref_ratio*num_cells/4, ref_ratio*num_cells/4), hi = (ref_ratio*11*num_cells/4-1, 3*ref_ratio*num_cells/4-1)),
#          Box(lo = (ref_ratio*num_cells/4, 9*ref_ratio*num_cells/4), hi = (3*ref_ratio*num_cells/4-1, 11*ref_ratio*num_cells/4-1)),
#          Box(lo = (9*ref_ratio*num_cells/4, 9*ref_ratio*num_cells/4), hi = (11*ref_ratio*num_cells/4-1, 11*ref_ratio*num_cells/4-1))]] # Level 1

# 2 coarse and 2 fine blocks.
#boxes = [[Box(lo = (0, 0), hi = (num_cells-1, num_cells-1)),
#          Box(lo = (2*num_cells, 0), hi = (3*num_cells-1, num_cells-1)),
#          Box(lo = (0, 2*num_cells), hi = (num_cells-1, 3*num_cells-1)),
#          Box(lo = (2*num_cells, 2*num_cells), hi = (3*num_cells-1, 3*num_cells-1))], # Level 0
#         [Box(lo = (0, 0), hi = (ref_ratio*num_cells-1, ref_ratio*num_cells-1)),
#          Box(lo = (ref_ratio*2*num_cells, ref_ratio*2*num_cells), hi = (ref_ratio*3*num_cells-1, ref_ratio*3*num_cells-1))]] # Level 1

# Horizontal inter-block "bars" of refinement
boxes = [[Box(lo = (0, 0), hi = (num_cells-1, num_cells-1)),
          Box(lo = (2*num_cells, 0), hi = (3*num_cells-1, num_cells-1)),
          Box(lo = (0, 2*num_cells), hi = (num_cells-1, 3*num_cells-1)),
          Box(lo = (2*num_cells, 2*num_cells), hi = (3*num_cells-1, 3*num_cells-1))], # Level 0
         [Box(lo = (ref_ratio*num_cells/4, ref_ratio*num_cells/4), hi = (ref_ratio*num_cells-1, 3*ref_ratio*num_cells/4-1)),
#          Box(lo = (2*ref_ratio*num_cells, ref_ratio*num_cells/4), hi = (11*ref_ratio*num_cells/4-1, 3*ref_ratio*num_cells/4-1)),
#          Box(lo = (ref_ratio*num_cells/4, 9*ref_ratio*num_cells/4), hi = (ref_ratio*num_cells-1, 11*ref_ratio*num_cells/4-1)),
          Box(lo = (2*ref_ratio*num_cells, 9*ref_ratio*num_cells/4), hi = (11*ref_ratio*num_cells/4-1, 11*ref_ratio*num_cells/4-1))]] # Level 1

use_subcycling = True
initial_average = True
useHyperviscosity = 0
hyperviscosity = 0.01

limitFaceValues = 1
enforceMinVal = 1
minVal = 0.0

# Initial condition
radius = 0.25
magnitude = 1.0
if not corners:
    center = (1, 1)
    def phi0(x, t):
        return 1
        r = sqrt((x[0]-center[0])**2 + (x[1]-center[1])**2)
        return exp(-8*r*r)

# Alternate version -- starts at corners
else:
    centers = [(1./3, 1./3), (-1./3, 1./3), (-1./3, -1./3), (1./3, -1./3)]
    def phi0(x, t):
        rs = [sqrt((x[0]-c[0])**2 + (x[1]-c[1])**2) for c in centers]
        return sum([exp(-8*r*r) for r in rs])

# Velocity function: pure advection.
velocity = (2, 2)

# Output
checkpoint_interval = -1
plot_interval = 1
if corners:
    plot_prefix = 'plot/Gaussian-advection-2x2-corners.%d.'%num_cells
    chk_prefix  = 'Gaussian-advection-2x2-corners.%d.'%num_cells
else:
    plot_prefix = 'plot/Gaussian-advection-2x2.%d.'%num_cells
    chk_prefix  = 'Gaussian-advection-2x2.%d.'%num_cells

