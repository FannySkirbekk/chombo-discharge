# example from example/fourthOrderMappedGrids/execAdvection/cosinebelladvection.cubedsphere2d.032.inputs
assert(SpaceDim == 2)

multiblock = True
verbosity = 1

# Time stepping
max_step = 20000
max_time = 12.0
cfl = 1.0
initial_cfl = 0.75
max_dt_growth = 1.1
dt_tolerance_factor = 1.1

# Computational domain and coordinate system.
coord_sys = 'cubed_sphere'
domain_length = 1.0
num_cells = 32
# fixed_dt = 3.84 / num_cells
fixed_dt = 0.192 / num_cells
max_grid_size = 64

# AMR
max_level = 1
ref_ratio = 2 

# Fixed box layouts.
# ------------------

boxes = [[Box(lo = (           0, 0), hi = (   num_cells-1, num_cells-1)),
          Box(lo = ( 2*num_cells, 0), hi = ( 3*num_cells-1, num_cells-1)),
          Box(lo = ( 4*num_cells, 0), hi = ( 5*num_cells-1, num_cells-1)),
          Box(lo = ( 6*num_cells, 0), hi = ( 7*num_cells-1, num_cells-1)),
          Box(lo = ( 8*num_cells, 0), hi = ( 9*num_cells-1, num_cells-1)),
          Box(lo = (10*num_cells, 0), hi = (11*num_cells-1, num_cells-1))], # Level 0
         [Box(lo = ( 3*ref_ratio*num_cells/4,   ref_ratio*num_cells/4), hi = ( 4*ref_ratio*num_cells/4-1, 3*ref_ratio*num_cells/4-1)),
          Box(lo = ( 8*ref_ratio*num_cells/4,   ref_ratio*num_cells/4), hi = ( 9*ref_ratio*num_cells/4-1, 3*ref_ratio*num_cells/4-1)),
          Box(lo = (   ref_ratio*num_cells/4, 3*ref_ratio*num_cells/4), hi = ( 3*ref_ratio*num_cells/4-1, 4*ref_ratio*num_cells/4-1)),
          Box(lo = (33*ref_ratio*num_cells/4,                     0  ), hi = (35*ref_ratio*num_cells/4-1,   ref_ratio*num_cells/4-1))]] # Level 1
#          Box(lo = (11*ref_ratio*num_cells/4,   ref_ratio*num_cells/4), hi = (12*ref_ratio*num_cells/4-1, 3*ref_ratio*num_cells/4-1)),
#          Box(lo = (16*ref_ratio*num_cells/4,   ref_ratio*num_cells/4), hi = (17*ref_ratio*num_cells/4-1, 3*ref_ratio*num_cells/4-1))]] # Level 1

useHyperviscosity = 0
hyperviscosity = 0.01

# REMOVED limitFaceValues setting!  Set use_prim_limiting instead.
# limitFaceValues = 0
use_prim_limiting = 1
enforceMinVal = 1
minVal = 0.0

ambientDensity = 0.0
deltaDensity = 1000.0
bellSize = 0.3
advectVelocity = pi / 6.0
advectAngle = 0.0
evalTime = 0.0

# These are in (longitude, latitude) coordinates.
# center point
# center = (0.0, 0.7853981633974483)
center = (0.0, 0.0)
# advection velocity
# velocity = (1.0, 1.0)

# Advect Cosine Bell initial conditions.
def phi0(lonlat, t):
    lon = lonlat[0]
    lat = lonlat[1]
    lonc = center[0]
    latc = center[1]
#   great circle distance between (lon, lat) and center (lonc, latc).
    arc = acos(sin(latc)*sin(lat) + cos(latc)*cos(lat)*cos(lon-lonc))
    dens = ambientDensity
    if arc <= bellSize:
        fac = (1.0 + cos(pi * arc / bellSize)) / 2.0
        dens = dens + deltaDensity * fac*fac*fac
    return dens

def velocity(lonlat, t):
    lon = lonlat[0]
    lat = lonlat[1]
    vlon = advectVelocity * cos(lat) * \
           ( cos(advectAngle) + cos(lon) * tan(lat) * sin(advectAngle) )
    vlat = -advectVelocity * sin(lon) * sin(advectAngle)
    return (vlon, vlat)

# Output
checkpoint_interval = -1
plot_interval = 1
plot_prefix  = 'AdvectCosineBell.center_lim.2lev.%d.'%num_cells
chk_prefix = 'chkAdvectCosineBell.center_lim.2lev.%d.'%num_cells
