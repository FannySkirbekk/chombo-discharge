# RossbyHaurwitz64adapt0r.inputs
# Rossby-Haurwitz wave.
# This test was taken from Case 6 in Williamson et. al., 
# "A Standard Test Set for Numerical Approximations to the Shallow Water 
#  Equations in Spherical Geometry", JCP 102:211-224 (1992).

num_cells = 64
plot_prefix = "RossbyHaurwitz64adapt0r."
plot_interval = 1
verbosity = 2
max_level = 0
ref_ratio = 2
max_grid_size = 32
# Show longitude-latitude maps.
lonlat = True

normal_predictor = 'PPM'
forward_euler = False

cfl = 0.8
initial_cfl = 0.1

use_subcycling = False
use_prim_limiting = False

# ------------------
# Initial conditions
# ------------------

a     = 6.37122e6     # Sphere radius (in meters)
day   = 86164.1   # seconds in a sidereal day
# Omega = 7.292e-5      # Rotational velocity (rad/sec)
# Omega = 2.0*pi      # Rotational velocity (radians/day)
Omega = 6.300288
# g     = 9.80616*day*day/a # Gravitational acceleration (earth radii/day**2)
g     = 11489.57

# alpha is the angle between the axis of solid body rotation and the polar
# axis of the spherical coordinate system.
# This test should be run with alpha = 0.0, 0.05, pi/2 - 0.05, and pi/2.
alpha = 0.0

# Center coordinates.
(lonc, latc) = (1.5*pi, 0)

# Rossby-Haurwitz wave test pattern in longitude (lon) and 
# latitude (lat) representation.
# In papers, lon = lambda, and lat = theta.

omega = 7.848e-6*day
K = omega
h0 = 8e3/a
R = 4

def A(theta):
    cos2 = (cos(theta))**2
    result = omega/2.0 * (2*Omega + omega) * cos2 \
           + (K*K * (cos2**R) / 4.0) * \
             ((R + 1.0) * cos2 + (2*R*R - R - 2) - 2*R*R/cos2)
    return result

def B(theta):
    cos2 = (cos(theta))**2
    cosr = (cos(theta))**R
    result = ( 2 * (Omega + omega) * K / ((R + 1) * (R + 2)) ) * \
             cosr * ( (R*R + 2*R + 2) - (R + 1)**2 * cos2)
    return result

def C(theta):
    cos2 = (cos(theta))**2
    cos2r = (cos(theta))**(2*R)
    result = (K*K*cos2r/4.0) * ( (R + 1) * cos2 - (R + 2) )
    return result

def RossbyHaurwitz(lonlat):
    lon = lonlat[0]
    lat = lonlat[1]
    h = h0 + (A(lat) + B(lat) * cos(R*lon) + C(lat) * cos(2*R*lon)) / g
    return h

# Advecting wind speed (in sphere radii/day).
# In papers, lon = lambda, and lat = theta.
def windVelocity(lonlat):
    lon = lonlat[0]
    lat = lonlat[1]
    cosrm1 = (cos(lat))**(R-1)
    u = omega * cos(lat) + \
        K * cosrm1 * (R * (sin(lat))**2 - (cos(lat))**2) * cos(R*lon)
    v = - K * R * cosrm1 * sin(lat) * sin(R*lon)
    return (u, v)

height = RossbyHaurwitz
velocity = windVelocity

# Examine after one full rotation.
max_time = 1.0
max_step = 1000
