# CosineBell.inputs
# This advection test was taken from Case 1 in Williamson et. al., 
# "A Standard Test Set for Numerical Approximations to the Shallow Water 
#  Equations in Spherical Geometry", JCP 102:211-224 (1992).

num_cells = 64
plot_prefix = "CosineBell64adapt0r."
plot_interval = 1
verbosity = 2
max_level = 0
ref_ratio = 2
max_grid_size = 64

normal_predictor = 'PPM'
forward_euler = False

cfl = 0.8
initial_cfl = 0.1

use_subcycling = False
use_prim_limiting = False

# ------------------
# Initial conditions
# ------------------

a     = 6.37122e6     # Sphere radius (in meters)
day   = 86164.1   # seconds in a sidereal day
# Omega = 7.292e-5      # Rotational velocity (rad/sec)
Omega = 2.0*pi      # Rotational velocity (radians/day)
g     = 9.80616*day*day/a # Gravitational acceleration (earth radii/day**2)

# alpha is the angle between the axis of solid body rotation and the polar
# axis of the spherical coordinate system.
# This test should be run with alpha = 0.0, 0.05, pi/2 - 0.05, and pi/2.
alpha = 0.0

# Center coordinates.
(lonc, latc) = (1.5*pi, 0)

# Cosine Bell test pattern in longitude (lon) and 
# latitude (lat) representation.
# In papers, lon = lambda, and lat = theta.
h0 = 1000.0/a  # ("Height" of Cosine Bell in sphere radii.
R  = 1./3.     # Bell radius in sphere radii
def CosineBell(lonlat):
    lon = lonlat[0]
    lat = lonlat[1]
    r = acos(sin(latc)*sin(lat) + cos(latc)*cos(lat)*cos(lon-lonc))
    if r < R:
        return 0.5 * h0 * (1 + cos(pi*r/R))
    else:
        return 0

# Advecting wind speed (in sphere radii/day).
# In papers, lon = lambda, and lat = theta.
u0 = 2.0*pi/12.
def windVelocity(lonlat):
    lon = lonlat[0]
    lat = lonlat[1]
    u = u0 * (cos(lat)*cos(alpha) + sin(lat)*cos(lon)*sin(alpha))
    v = -u0 * sin(lon)*sin(alpha)
    return (u, v)

height = CosineBell
velocity = windVelocity

# Examine after one full rotation.
max_time = 1.0
max_step = 1000
