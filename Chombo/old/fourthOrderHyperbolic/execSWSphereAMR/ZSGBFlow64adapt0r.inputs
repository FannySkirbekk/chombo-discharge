# ZSGBFlow64adapt0r.inputs
# Zonally symmetric geostrophically balanced flow.
# This test was taken from Case 2 in Williamson et. al., 
# "A Standard Test Set for Numerical Approximations to the Shallow Water 
#  Equations in Spherical Geometry", JCP 102:211-224 (1992).

num_cells = 64
plot_prefix = "ZSGBFlow64adapt0r."
plot_interval = 1
verbosity = 2
max_level = 0
ref_ratio = 2
max_grid_size = 64

normal_predictor = 'PPM'
forward_euler = False

cfl = 0.8
initial_cfl = 0.1

use_subcycling = False
use_prim_limiting = False

# ------------------
# Initial conditions
# ------------------

# a     = 6.37122e6     # Sphere radius (in meters)
# day   = 86164.1   # seconds in a sidereal day
# Omega = 7.292e-5      # Rotational velocity (rad/sec)
# Omega = 2.0*pi      # Rotational velocity (radians/day)
Omega = 6.300288
# g     = 9.80616*day*day/a # Gravitational acceleration (earth radii/day**2)
g     = 11489.57

# alpha is the angle between the axis of solid body rotation and the polar
# axis of the spherical coordinate system.
# This test should be run with alpha = 0.0, 0.05, pi/2 - 0.05, and pi/2.
alpha = 0.0

# Center coordinates.
(lonc, latc) = (1.5*pi, 0)

# Test pattern in longitude (lon) and 
# latitude (lat) representation.
# In papers, lon = lambda, and lat = theta.
h0 = 4.7057e-4
u0 = pi/6.0
def ZSGBFlow(lonlat):
    lon = lonlat[0]
    lat = lonlat[1]
    fac = -cos(lon)*cos(lat)*sin(alpha) + sin(lat)*cos(alpha)
    h = h0 - (1.0/g) * u0 * (Omega + u0/2.0) * fac * fac
    return h

# Advecting wind speed (in sphere radii/day).
# In papers, lon = lambda, and lat = theta.
def windVelocity(lonlat):
    lon = lonlat[0]
    lat = lonlat[1]
    u = u0 * (cos(lat)*cos(alpha) + sin(lat)*cos(lon)*sin(alpha))
    v = -u0 * sin(lon)*sin(alpha)
    return (u, v)

height = ZSGBFlow
velocity = windVelocity

# Examine after one full rotation.
max_time = 1.0
max_step = 1000
