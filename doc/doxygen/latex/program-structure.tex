PlasmaC is a program for performing Cartesian 2D and 3D transient simulations of fluid plasmas in complex geometries. The code is flexible with regards to geometries and plasma kinetics, and is thus applicable to a comparatively broad range of research fields. PlasmaC is built on top of the Chombo platform, and therefore has A\+MR capabilities. However, subcycling in time is not supported. Because PlasmaC is a large source code, most of the code documentation resides in the source code itself, which cannot be discussed in full. Instead, we provide an outline to the structure of PlasmaC below. In broad strokes, we require that the user


\begin{DoxyItemize}
\item Builds an executable
\item Provides options to this executable when it is run.
\end{DoxyItemize}

We do have a \hyperlink{worked-example}{worked example}, but we strongly recommend that you finish reading this page before working your way through that example.

The typical use of PlasmaC consists of building and running mini-\/applications (i.\+e. executables) which obtain simulation options through an input script or the command line. These applications consist of a main file that instantiates various C++ implementations of important base classes, and the must therefore be built by the user. Because the main-\/files are almost identical across mini-\/apps, we have a python script that automates the generation of the main file; the makefile, and a default options file through which the user controls his application. The main file always contains instantiation of the following important classes\+:


\begin{DoxyItemize}
\item \hyperlink{classplasma__kinetics}{plasma\+\_\+kinetics} An abstract class that defines the overall kinetics; this includes description of source terms, velocities, diffusion coefficients, surface kinetics (e.\+g. secondary emission) and so on. Currently, we only have kinetic models for $\textrm{N}_2-\textrm{O}_2$ mixtures.
\item \hyperlink{classcomputational__geometry}{computational\+\_\+geometry} An implementation of the geometry that will be simulated. Various implementation of this class exist, which you may immediately use. Descriptions of new geometries must be done by the user by either implementing a new \hyperlink{classcomputational__geometry}{computational\+\_\+geometry} class, or use the scripted geometry class.
\item \hyperlink{classphysical__domain}{physical\+\_\+domain} The physical domain to be simulated. This is a very lightweight class that only describes the axis-\/aligned box that you wish to simulate. There is no need to reimplement this class.
\item \hyperlink{classtime__stepper}{time\+\_\+stepper} The temporal integrator; the class includes an implementation of the time stepping scheme. Implementation of new integration schemes is time consuming, and additional implementations of this class is a developer task. Currently, we support some implicit-\/explicit schemes and Runge-\/\+Kutta schemes. Most users will find the second order Runge-\/\+Kutta scheme to be sufficient. This class owns all the individual solvers, and has access to \hyperlink{classamr__mesh}{amr\+\_\+mesh}.
\item \hyperlink{classcell__tagger}{cell\+\_\+tagger} Class that is responsible for refinement and coarsening decision.
\item \hyperlink{classamr__mesh}{amr\+\_\+mesh} The A\+MR mesh engine. This class includes grid generators, coarsening operators, ghost cell interpolation operators and so on. This class is one of the most important base class, and is responsible for orchestratic all spatial operations.
\end{DoxyItemize}

The above classes are used to instantiate another class


\begin{DoxyItemize}
\item \hyperlink{classplasma__engine}{plasma\+\_\+engine} Class that runs the entire simulation by advancing the solvers through \hyperlink{classtime__stepper}{time\+\_\+stepper}. \hyperlink{classplasma__engine}{plasma\+\_\+engine} is also responsible for obtaining refinement and coarsening flags from cell-\/tagger when \hyperlink{classamr__mesh}{amr\+\_\+mesh} calls for a regrid operation. Additional responsibilities of this class include writing plot and checkpoint files.
\end{DoxyItemize}

For a more thorough description of these classes, see \hyperlink{base-classes}{Base classes}. Most users will find it sufficient to modify only two of the above classes\+: \hyperlink{classplasma__kinetics}{plasma\+\_\+kinetics} and \hyperlink{classcomputational__geometry}{computational\+\_\+geometry}. Because some of the above classes will be left unmodified by the user (e.\+g. \hyperlink{classphysical__domain}{physical\+\_\+domain} and \hyperlink{classamr__mesh}{amr\+\_\+mesh}), they might be taken out of the user interface in later design. Setting up a mini-\/app from existing pieces of code (i.\+e. pre-\/defined geometries and plasma kinetics) is very simple. The code snippet below is a full mini-\/app for simulation of a discharge from a needle electrode with a dielectric sphere placed in the middle of the gap. \begin{DoxyVerb}  #include "plasma_engine.H"   // Load plasma_engine class
  #include "rk2.H"             // Load temporal integrator instance (derived from time_stepper)
  #include "field_tagger.H"    // Load the cell tagger (derived from cell_tagger)
  #include "morrow_lowke.H"    // Load the plasma kinetics (derived from plasma_kinetics)
  #include "rod_sphere.H"      // Load the geometry (derived from computational_geometry)

  #include <ParmParse.H>       // Input parameters parsing class. 

  Real g_potential;    
  Real potential_curve(const Real a_time){ // Potential curve to be simulated. This returns
    return g_potential;                    // a single value which is obtained through the input script. 
  }

  int main(int argc, char* argv[]){

  #ifdef CH_MPI
    MPI_Init(&argc,&argv);  // Initialize MPI
  #endif

    // Build argument list from input file and command line
    char* inputFile = argv[1];
    ParmParse PP(argc-2,argv+2,NULL,inputFile);

    { // Get the potential curve to be simulated (constant in this case)
      ParmParse pp("rod_sphere2d");
      pp.get("potential", g_potential);
    }

    // Load the classes discussed above
    RefCountedPtr<plasma_kinetics> plaskin         = RefCountedPtr<plasma_kinetics> (new morrow_lowke());
    RefCountedPtr<computational_geometry> compgeom = RefCountedPtr<computational_geometry> (new rod_sphere());
    RefCountedPtr<physical_domain> physdom         = RefCountedPtr<physical_domain> (new physical_domain());
    RefCountedPtr<time_stepper> timestepper        = RefCountedPtr<time_stepper>(new rk2());
    RefCountedPtr<cell_tagger> tagger              = RefCountedPtr<cell_tagger> (new field_tagger());   
    RefCountedPtr<amr_mesh> amr                    = RefCountedPtr<amr_mesh> (new amr_mesh());
    RefCountedPtr<plasma_engine> engine            = RefCountedPtr<plasma_engine> (new plasma_engine(physdom, compgeom, plaskin, timestepper, amr, tagger));

    // Give the potential curve the plasma_engine and run simulation
    engine->set_potential(potential_curve);
    engine->setup_and_run();


  #ifdef CH_MPI
    CH_TIMER_REPORT();
    MPI_Finalize();
  #endif
  }
\end{DoxyVerb}


In the above example, all tunable parameters for the simulation are hidden from the view of the mini-\/app (with the exception of the potential curve). To avoid cluttering of mini-\/app main files, all tunable parameters are implemented as class options which are loaded on class construction. The options are usually provided by means of an input script (although the command line is also supported) which is loaded by Chombo\textquotesingle{}s Parm\+Parse class (which is instantiated in the example above). Upon construction, this class reads an input (and possible also command-\/line parameters) and build an internal table of available options. This table is then read in the default constructors of each base class. Each option contains the name of the class, and then the name of the variable. For example\+: \begin{DoxyVerb}  amr.coarsest_domain = 128 128 128
\end{DoxyVerb}


defines a coarsest domain of $(128)^3$ cells. Furthermore, \hyperlink{classamr__mesh}{amr\+\_\+mesh} requires certain information about the maximum number of A\+MR levels that we will use, blocking factors, refinement ratios and so on. These are all passed through an input script, which may e.\+g. contain \begin{DoxyVerb}  amr.max_amr_depth   = 4           # Maximum amr depth
  amr.max_sim_depth   = 2           # Maximum simulation depth
  amr.blocking_factor = 8           # Blocking factor
  amr.max_box_size    = 16          # Maximum allowed box size
  amr.ref_rat         = 2 2 2 2 2   # Refinement ratios
\end{DoxyVerb}


The first line above restricts that maximum number of A\+MR levels to 4 (i.\+e. 5 levels in total), and the second line places another restriction\+: We will only use 2 of these levels during the simulation. The rationale for this design is that certain temporal parts of a simulation may safely simulated using a coarse resolution, for example when a streamer crosses a pure gas gap. Other parts may require a finer spatial resolution, for example when the streamer strikes a dielectric surface. Thus, argument amr.\+max\+\_\+sim\+\_\+depth allows you to change the number of A\+MR levels when you checkpoint/restart one of your simulations. The third line contains the blocking factor; this is essentially the smallest box size that will be allowed by the grid generator. Likewise, the fourth line amr.\+max\+\_\+box\+\_\+size provides information on the largest box size. Finally, amr.\+ref\+\_\+rat defines the refinement ratios between levels; you may use refinement ratios of 2 or 4 (and they may even be mixed). Of course, a simulation case may consist of several hundres of options. Currently, one needs to obtain these either by recycling input scripts, or directly in the class header file. In the future, we will most likely implement a mini-\/app automated builder that obtain all class options for you. 