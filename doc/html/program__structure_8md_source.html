<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>PlasmaC: doc/program_structure.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="html_extra_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PlasmaC
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="doxy-contents.html"><span>Contents</span></a></li>
      <li><a href="gallery.html"><span>Gallery</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">doc/program_structure.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="program__structure_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;Program description {#program-structure}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;==============================</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;chombo-streamer is a program for performing Cartesian 2D and 3D transient simulations of fluid plasmas in complex geometries. The code is flexible with regards to geometries and plasma kinetics, and is thus applicable to a comparatively broad range of research fields. chombo-streamer is built on top of the Chombo platform, and therefore has AMR capabilities. However, subcycling in time is not supported. Because chombo-streamer is a large source code, most of the code documentation resides in the source code itself, which cannot be discussed in full. Instead, we provide an outline to the structure of chombo-streamer below. In broad strokes, we require that the user</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;* Builds an executable</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;* Provides options to this executable when it is run. </div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;We do have a @ref worked-example, but we strongly recommend that you finish reading this page before working your way through that example. </div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;The typical use of chombo-streamer consists of building and running mini-applications (i.e. executables) which obtain simulation options through an input script or the command line. These applications consist of a main file that instantiates various C++ implementations of important base classes, and the must therefore be built by the user. Because the main-file is almost identical across mini-apps, we do have a python script that automates the generation of the main file; the makefile, and a default options file through which the user controls his application. The main file always contains instantiation of the following important classes:</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;* plasma_kinetics An abstract class that defines the overall kinetics; this includes description of source terms, velocities, diffusion coefficients, surface kinetics (e.g. secondary emission) and so on. Currently, we only have kinetic models for \f$\textrm{N}_2-\textrm{O}_2\f$ mixtures. </div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;* computational_geometry An implementation of the geometry that will be simulated. Various implementation of this class exist, which you may immediately use. Descriptions of new geometries must be done by the user by either implementing a new computational_geometry class, or use the scripted geometry class. </div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;* physical_domain The physical domain to be simulated. This is a very lightweight class that only describes the axis-aligned box that you wish to simulate. There is no need to reimplement this class. </div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;* time_stepper The temporal integrator; the class includes an implementation of the time stepping scheme. Implementation of new integration schemes is time consuming, and additional implementations of this class is a developer task. Currently, we support some implicit-explicit schemes and Runge-Kutta schemes. Most users will find the second order Runge-Kutta scheme to be sufficient. This class owns all the individual solvers, and has access to amr_mesh.</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;* cell_tagger Class that is responsible for refinement and coarsening decision. </div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;* amr_mesh The AMR mesh engine. This class includes grid generators, coarsening operators, ghost cell interpolation operators and so on. This class the most important base class, and is responsible for orchestratic all spatial operations.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;The above classes are used to instantiate another class</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;* plasma_engine Class that runs the entire simulation by advancing the solvers through time_stepper. plasma_engine is also responsible for obtaining refinement and coarsening flags from cell-tagger when amr_mesh calls for a regrid operation. Additional responsibilities of this class include writing plot and checkpoint files. </div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;For a more thorough description of these classes, see @ref base-classes. Most users will find it sufficient to modify only two of the above classes: plasma_kinetics and computational_geometry. Because some of the above classes will be left unmodified by the user (e.g. physical_domain and amr_mesh), they might be taken out of the user interface in later design. Setting up a mini-app from existing pieces of code (i.e. pre-defined geometries and plasma kinetics) is very simple. The code snippet below is a full mini-app for simulation</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;of a discharge from a needle electrode with a dielectric sphere placed in the middle of the gap. </div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;      #include &quot;plasma_engine.H&quot;   // Load plasma_engine class</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;      #include &quot;rk2.H&quot;             // Load temporal integrator instance (derived from time_stepper)</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;      #include &quot;field_tagger.H&quot;    // Load the cell tagger (derived from cell_tagger)</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;      #include &quot;morrow_lowke.H&quot;    // Load the plasma kinetics (derived from plasma_kinetics)</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;      #include &quot;rod_sphere.H&quot;      // Load the geometry (derived from computational_geometry)</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;      #include &lt;ParmParse.H&gt;       // Input parameters parsing class. </div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;      Real g_potential;    </div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;      Real potential_curve(const Real a_time){ // Potential curve to be simulated. This returns</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        return g_potential;                    // a single value which is obtained through the input script. </div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;      }</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;      int main(int argc, char* argv[]){</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;      #ifdef CH_MPI</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        MPI_Init(&amp;argc,&amp;argv);  // Initialize MPI</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;      #endif</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        // Build argument list from input file and command line</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        char* inputFile = argv[1];</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        ParmParse PP(argc-2,argv+2,NULL,inputFile);</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;      </div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        { // Get the potential curve to be simulated (constant in this case)</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;          ParmParse pp(&quot;rod_sphere2d&quot;);</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;          pp.get(&quot;potential&quot;, g_potential);</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        }</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;       // Load the classes discussed above</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        RefCountedPtr&lt;plasma_kinetics&gt; plaskin         = RefCountedPtr&lt;plasma_kinetics&gt; (new morrow_lowke());</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        RefCountedPtr&lt;computational_geometry&gt; compgeom = RefCountedPtr&lt;computational_geometry&gt; (new rod_sphere());</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        RefCountedPtr&lt;physical_domain&gt; physdom         = RefCountedPtr&lt;physical_domain&gt; (new physical_domain());</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        RefCountedPtr&lt;time_stepper&gt; timestepper        = RefCountedPtr&lt;time_stepper&gt;(new rk2());</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        RefCountedPtr&lt;cell_tagger&gt; tagger              = RefCountedPtr&lt;cell_tagger&gt; (new field_tagger());  </div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        RefCountedPtr&lt;amr_mesh&gt; amr                    = RefCountedPtr&lt;amr_mesh&gt; (new amr_mesh());</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        RefCountedPtr&lt;plasma_engine&gt; engine            = RefCountedPtr&lt;plasma_engine&gt; (new plasma_engine(physdom, compgeom, plaskin, timestepper, amr, tagger));</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;       // Give the potential curve the plasma_engine and run simulation</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        engine-&gt;set_potential(potential_curve);</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        engine-&gt;setup_and_run();</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;      </div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;      </div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      #ifdef CH_MPI</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;        CH_TIMER_REPORT();</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        MPI_Finalize();</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;      #endif</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;      }</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;In the above example, all tunable parameters for the simulation are hidden from the view of the mini-app (with the exception of the potential curve). To avoid cluttering of mini-app main files, all tunable parameters are implemented as class options which are loaded on class construction. The options are usually provided by means of an input script (although the command line is also supported) which is loaded by Chombo&#39;s ParmParse class (which is instantiated in the example above). Upon construction, this class reads an input (and possible also command-line parameters) and build an internal table of available options. This table is then read in the default constructors of each base class. Each option contains the name of the class, and then the name of the variable. For example:</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;      amr.coarsest_domain = 128 128 128</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;defines a coarsest domain of \f$(128)^3\f$ cells. Furthermore, amr_mesh requires certain information about the maximum number of AMR levels that we will use, blocking factors, refinement ratios and so on. These are all passed through an input script, which may e.g. contain</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;      amr.max_amr_depth   = 4           # Maximum amr depth</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;      amr.max_sim_depth   = 2           # Maximum simulation depth</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;      amr.blocking_factor = 8           # Blocking factor</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;      amr.max_box_size    = 16          # Maximum allowed box size</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;      amr.ref_rat         = 2 2 2 2 2   # Refinement ratios</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;The first line above restricts that maximum number of AMR levels to 4 (i.e. 5 levels in total), and the second line places another restriction: We will only use 2 of these levels during the simulation. The rationale for this design is that certain temporal parts of a simulation may safely simulated using a coarse resolution, for example when a streamer crosses a pure gas gap. Other parts may require a finer spatial resolution, for example when the streamer strikes a dielectric surface. Thus, argument amr.max_sim_depth allows you to change the number of AMR levels when you checkpoint/restart one of your simulations. The third line contains the blocking factor; this is essentially the smallest box size that will be allowed by the grid generator. Likewise, the fourth line amr.max_box_size provides information on the largest box size. Finally, amr.ref_rat defines the refinement ratios between levels; you may use refinement ratios of 2 or 4 (and they may even be mixed). Of course, a simulation case may consist of several hundres of options. Currently, one needs to obtain these either by recycling input scripts, or directly in the class header file. In the future, we will most likely implement a mini-app automated builder that obtain all class options for you. </div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 26 2018 13:27:07 for PlasmaC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
