<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>PlasmaC: Program description</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSsymbols.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="html_extra_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PlasmaC
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home</span></a></li>
      <li><a href="doxy-contents.html"><span>Contents</span></a></li>
      <li><a href="gallery.html"><span>Gallery</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Program description </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>chombo-streamer is a program for performing Cartesian 2D and 3D transient simulations of fluid plasmas in complex geometries. The code is flexible with regards to geometries and plasma kinetics, and is thus applicable to a comparatively broad range of research fields. chombo-streamer is built on top of the Chombo platform, and therefore has AMR capabilities. However, subcycling in time is not supported. Because chombo-streamer is a large source code, most of the code documentation resides in the source code itself, which cannot be discussed in full. Instead, we provide an outline to the structure of chombo-streamer below. In broad strokes, we require that the user</p>
<ul>
<li>Builds an executable</li>
<li>Provides options to this executable when it is run.</li>
</ul>
<p>We do have a <a class="el" href="worked-example.html">Worked example</a>, but we strongly recommend that you finish reading this page before working your way through that example.</p>
<p>The typical use of chombo-streamer consists of building and running mini-applications (i.e. executables) which obtain simulation options through an input script or the command line. These applications consist of a main file that instantiates various C++ implementations of important base classes, and the must therefore be built by the user. Because the main-file is almost identical across mini-apps, we do have a python script that automates the generation of the main file; the makefile, and a default options file through which the user controls his application. The main file always contains instantiation of the following important classes:</p>
<ul>
<li><a class="el" href="classplasma__kinetics.html" title="Abstract base class for specifying plasma kinetics. ">plasma_kinetics</a> An abstract class that defines the overall kinetics; this includes description of source terms, velocities, diffusion coefficients, surface kinetics (e.g. secondary emission) and so on. Currently, we only have kinetic models for \(\textrm{N}_2-\textrm{O}_2\) mixtures.</li>
<li><a class="el" href="classcomputational__geometry.html" title="Abstract base class for geometries. ">computational_geometry</a> An implementation of the geometry that will be simulated. Various implementation of this class exist, which you may immediately use. Descriptions of new geometries must be done by the user by either implementing a new <a class="el" href="classcomputational__geometry.html" title="Abstract base class for geometries. ">computational_geometry</a> class, or use the scripted geometry class.</li>
<li><a class="el" href="classphysical__domain.html" title="Basic class that describes a physical domain. This is just the two corners of a box. ">physical_domain</a> The physical domain to be simulated. This is a very lightweight class that only describes the axis-aligned box that you wish to simulate. There is no need to reimplement this class.</li>
<li><a class="el" href="classtime__stepper.html" title="Abstract class for evolving in time across an amr mesh. ">time_stepper</a> The temporal integrator; the class includes an implementation of the time stepping scheme. Implementation of new integration schemes is time consuming, and additional implementations of this class is a developer task. Currently, we support some implicit-explicit schemes and Runge-Kutta schemes. Most users will find the second order Runge-Kutta scheme to be sufficient. This class owns all the individual solvers, and has access to <a class="el" href="classamr__mesh.html" title="Class for handling spatial operations for streamer equations. ">amr_mesh</a>.</li>
<li><a class="el" href="classcell__tagger.html" title="Abstract class for tagging cells across an AMR hierarchy. ">cell_tagger</a> Class that is responsible for refinement and coarsening decision.</li>
<li><a class="el" href="classamr__mesh.html" title="Class for handling spatial operations for streamer equations. ">amr_mesh</a> The AMR mesh engine. This class includes grid generators, coarsening operators, ghost cell interpolation operators and so on. This class the most important base class, and is responsible for orchestratic all spatial operations.</li>
</ul>
<p>The above classes are used to instantiate another class</p>
<ul>
<li><a class="el" href="classplasma__engine.html" title="Main class for time/space advancement of streamer equations. This class runs a timestepper and contro...">plasma_engine</a> Class that runs the entire simulation by advancing the solvers through <a class="el" href="classtime__stepper.html" title="Abstract class for evolving in time across an amr mesh. ">time_stepper</a>. <a class="el" href="classplasma__engine.html" title="Main class for time/space advancement of streamer equations. This class runs a timestepper and contro...">plasma_engine</a> is also responsible for obtaining refinement and coarsening flags from cell-tagger when <a class="el" href="classamr__mesh.html" title="Class for handling spatial operations for streamer equations. ">amr_mesh</a> calls for a regrid operation. Additional responsibilities of this class include writing plot and checkpoint files.</li>
</ul>
<p>For a more thorough description of these classes, see <a class="el" href="base-classes.html">Base classes</a>. Most users will find it sufficient to modify only two of the above classes: <a class="el" href="classplasma__kinetics.html" title="Abstract base class for specifying plasma kinetics. ">plasma_kinetics</a> and <a class="el" href="classcomputational__geometry.html" title="Abstract base class for geometries. ">computational_geometry</a>. Because some of the above classes will be left unmodified by the user (e.g. <a class="el" href="classphysical__domain.html" title="Basic class that describes a physical domain. This is just the two corners of a box. ">physical_domain</a> and <a class="el" href="classamr__mesh.html" title="Class for handling spatial operations for streamer equations. ">amr_mesh</a>), they might be taken out of the user interface in later design. Setting up a mini-app from existing pieces of code (i.e. pre-defined geometries and plasma kinetics) is very simple. The code snippet below is a full mini-app for simulation of a discharge from a needle electrode with a dielectric sphere placed in the middle of the gap. </p><pre class="fragment">  #include "plasma_engine.H"   // Load plasma_engine class
  #include "rk2.H"             // Load temporal integrator instance (derived from time_stepper)
  #include "field_tagger.H"    // Load the cell tagger (derived from cell_tagger)
  #include "morrow_lowke.H"    // Load the plasma kinetics (derived from plasma_kinetics)
  #include "rod_sphere.H"      // Load the geometry (derived from computational_geometry)

  #include &lt;ParmParse.H&gt;       // Input parameters parsing class. 

  Real g_potential;    
  Real potential_curve(const Real a_time){ // Potential curve to be simulated. This returns
    return g_potential;                    // a single value which is obtained through the input script. 
  }

  int main(int argc, char* argv[]){

  #ifdef CH_MPI
    MPI_Init(&amp;argc,&amp;argv);  // Initialize MPI
  #endif

    // Build argument list from input file and command line
    char* inputFile = argv[1];
    ParmParse PP(argc-2,argv+2,NULL,inputFile);

    { // Get the potential curve to be simulated (constant in this case)
      ParmParse pp("rod_sphere2d");
      pp.get("potential", g_potential);
    }

    // Load the classes discussed above
    RefCountedPtr&lt;plasma_kinetics&gt; plaskin         = RefCountedPtr&lt;plasma_kinetics&gt; (new morrow_lowke());
    RefCountedPtr&lt;computational_geometry&gt; compgeom = RefCountedPtr&lt;computational_geometry&gt; (new rod_sphere());
    RefCountedPtr&lt;physical_domain&gt; physdom         = RefCountedPtr&lt;physical_domain&gt; (new physical_domain());
    RefCountedPtr&lt;time_stepper&gt; timestepper        = RefCountedPtr&lt;time_stepper&gt;(new rk2());
    RefCountedPtr&lt;cell_tagger&gt; tagger              = RefCountedPtr&lt;cell_tagger&gt; (new field_tagger());   
    RefCountedPtr&lt;amr_mesh&gt; amr                    = RefCountedPtr&lt;amr_mesh&gt; (new amr_mesh());
    RefCountedPtr&lt;plasma_engine&gt; engine            = RefCountedPtr&lt;plasma_engine&gt; (new plasma_engine(physdom, compgeom, plaskin, timestepper, amr, tagger));

    // Give the potential curve the plasma_engine and run simulation
    engine-&gt;set_potential(potential_curve);
    engine-&gt;setup_and_run();


  #ifdef CH_MPI
    CH_TIMER_REPORT();
    MPI_Finalize();
  #endif
  }
</pre><p>In the above example, all tunable parameters for the simulation are hidden from the view of the mini-app (with the exception of the potential curve). To avoid cluttering of mini-app main files, all tunable parameters are implemented as class options which are loaded on class construction. The options are usually provided by means of an input script (although the command line is also supported) which is loaded by Chombo's ParmParse class (which is instantiated in the example above). Upon construction, this class reads an input (and possible also command-line parameters) and build an internal table of available options. This table is then read in the default constructors of each base class. Each option contains the name of the class, and then the name of the variable. For example: </p><pre class="fragment">  amr.coarsest_domain = 128 128 128
</pre><p>defines a coarsest domain of \((128)^3\) cells. Furthermore, <a class="el" href="classamr__mesh.html" title="Class for handling spatial operations for streamer equations. ">amr_mesh</a> requires certain information about the maximum number of AMR levels that we will use, blocking factors, refinement ratios and so on. These are all passed through an input script, which may e.g. contain </p><pre class="fragment">  amr.max_amr_depth   = 4           # Maximum amr depth
  amr.max_sim_depth   = 2           # Maximum simulation depth
  amr.blocking_factor = 8           # Blocking factor
  amr.max_box_size    = 16          # Maximum allowed box size
  amr.ref_rat         = 2 2 2 2 2   # Refinement ratios
</pre><p>The first line above restricts that maximum number of AMR levels to 4 (i.e. 5 levels in total), and the second line places another restriction: We will only use 2 of these levels during the simulation. The rationale for this design is that certain temporal parts of a simulation may safely simulated using a coarse resolution, for example when a streamer crosses a pure gas gap. Other parts may require a finer spatial resolution, for example when the streamer strikes a dielectric surface. Thus, argument amr.max_sim_depth allows you to change the number of AMR levels when you checkpoint/restart one of your simulations. The third line contains the blocking factor; this is essentially the smallest box size that will be allowed by the grid generator. Likewise, the fourth line amr.max_box_size provides information on the largest box size. Finally, amr.ref_rat defines the refinement ratios between levels; you may use refinement ratios of 2 or 4 (and they may even be mixed). Of course, a simulation case may consist of several hundres of options. Currently, one needs to obtain these either by recycling input scripts, or directly in the class header file. In the future, we will most likely implement a mini-app automated builder that obtain all class options for you. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 26 2018 13:27:07 for PlasmaC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
